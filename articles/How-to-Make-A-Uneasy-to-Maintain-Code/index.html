<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><script src="\js\src\custom\instantclick.min.js" data-no-instant></script><script data-no-instant>InstantClick.on("change",function(t){!1===t&&("undefined"!=typeof MathJax&&MathJax.Hub.Queue(["Typeset",MathJax.Hub]),"undefined"!=typeof prettyPrint&&prettyPrint(),"undefined"!=typeof _hmt&&_hmt.push(["_trackPageview",location.pathname+location.search]),"undefined"!=typeof ga&&ga("send","pageview",location.pathname+location.search))}),InstantClick.init()</script><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><script></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.png?v=5.1.3" color="#222"><meta name="keywords" content="优化,毒瘤,"><link rel="alternate" href="/atom.xml" title="Shq's Blog" type="application/atom+xml"><meta name="description" content="总体原则想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用qwq他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量让他难以找到他想找的代码。但更重要的是，要让他不能有把握忽略任何东西qwq程序员都被编程惯例"><meta name="keywords" content="优化,毒瘤"><meta property="og:type" content="article"><meta property="og:title" content="「代码规范」如何编写无法维护的代码"><meta property="og:url" content="https://blog.ishq.site/articles/How-to-Make-A-Uneasy-to-Maintain-Code/index.html"><meta property="og:site_name" content="Shq&#39;s Blog"><meta property="og:description" content="总体原则想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用qwq他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量让他难以找到他想找的代码。但更重要的是，要让他不能有把握忽略任何东西qwq程序员都被编程惯例"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2018-08-15T02:21:46.568Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「代码规范」如何编写无法维护的代码"><meta name="twitter:description" content="总体原则想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用qwq他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量让他难以找到他想找的代码。但更重要的是，要让他不能有把握忽略任何东西qwq程序员都被编程惯例"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.3",sidebar:{position:"left",display:"post",offset:10,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="https://blog.ishq.site/articles/How-to-Make-A-Uneasy-to-Maintain-Code/"><title>「代码规范」如何编写无法维护的代码 | Shq's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div id="vcomment" class="comment"></div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><a href="https://github.com/Blog-Shq/blog-shq.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70b7fd;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Shq's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Real Artists simplify</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-bandcamp"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-id-card"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签<span class="badge">201</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>系列<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-paste"></i><br>归档<span class="badge">93</span></a></li><li class="menu-item menu-item-frlink"><a href="/frlink/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br>友链</a></li><li class="menu-item menu-item-comments"><a href="/comments/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i><br>留言板</a></li><li class="menu-item menu-item-remittance"><a href="/remittance/" rel="section"><i class="menu-item-icon fa fa-fw fa-bitcoin"></i><br>给本站投食</a></li><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.ishq.site/articles/How-to-Make-A-Uneasy-to-Maintain-Code/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Shq"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Shq's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">「代码规范」如何编写无法维护的代码</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T08:30:57+08:00">2018-08-15 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">属于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/articles/How-to-Make-A-Uneasy-to-Maintain-Code/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/How-to-Make-A-Uneasy-to-Maintain-Code/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">12,290 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">43</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a>总体原则</h1><p>想挫败维护代码的程序员，你必须先明白他的思维方式。他接手了你的庞大程序，没有时间把它全部读一遍，更别说理解它了。他无非是想快速找到修改代码的位置、改代码、编译，然后就能交差，并希望他的修改不会出现意外的副作用qwq</p><p>他查看你的代码不过是管中窥豹，一次只能看到一小段而已。你要确保他永远看不到全貌。要尽量让他难以找到他想找的代码。但更重要的是，要让他不能有把握<strong>忽略</strong>任何东西qwq</p><p>程序员都被编程惯例洗脑了，还为此自鸣得意。每一次你处心积虑地违背编程惯例，都会迫使他必须用放大镜去仔细阅读你的每一行代码。你可能会觉得每个语言特性都可以用来让代码难以维护，其实不然。你必须精心地误用它们才行qwq</p><a id="more"></a><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><blockquote><p><em>Quidquid latine dictum sit, altum sonatur.</em></p><p><em>(随便用拉丁文写点啥都会显得高大上。)</em></p><p><em>“当我使用一个单词的时候” Humpty Dumpty 曾经用一种轻蔑的口气说, “它就是我想表达的意思，不多也不少。“</em></p><p><em>– Lewis Carroll — 《爱丽丝魔镜之旅》， 第6章</em></p></blockquote><p>编写无法维护代码的技巧的重中之重是变量和方法命名的艺术。如何命名是和编译器无关的。这就让你有巨大的自由度去利用它们迷惑维护代码的程序员</p><h2 id="妙用键盘"><a href="#妙用键盘" class="headerlink" title="妙用键盘"></a>妙用键盘</h2><p>买个好用的键盘，你就永远不缺变量名了（才不是脸滚键盘</p><p>比如 <code>trew</code> 就是个好名字，而且键盘输入它也省事。如果你就想找一些容易输入的变量名，可以试试 <code>adsf</code> 或者 <code>aoeu</code> 之类的</p><h2 id="单变量命名"><a href="#单变量命名" class="headerlink" title="单变量命名"></a>单变量命名</h2><p>如果你给变量起名为 <code>a,b,c</code> ，用简单的文本编辑器就没法搜索它们的引用</p><p>而且，没人能猜到它们的含义</p><h2 id="创造性的拼写错误"><a href="#创造性的拼写错误" class="headerlink" title="创造性的拼写错误"></a>创造性的拼写错误</h2><p>如果你必须使用描述性的变量和函数名，那就把它们都拼错。还可以把某些函数和变量名拼错，再把其他的拼对(例如 <code>SetPintleOpening()</code> 和 <code>SetPintalClosing()</code> ) ，我们就能有效地将 <code>grep</code> 或 <code>IDE</code> 搜索技术玩弄于股掌之上。这招超级管用。还可以混淆不同语言（比如 <code>colour</code> — 英国英语，和 <code>color</code> — 美国英语)</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>在命名函数和变量的时候，充分利用抽象单词，例如 <code>it</code> , <code>everything</code> , <code>data</code> , <code>handle</code> , <code>stuff</code> , <code>do</code> , <code>routine</code> , <code>perform</code> 和数字，像这样命名的好例子有 <code>routineX48</code> , <code>PerformDataFunction</code> , <code>DoIt</code> , <code>HandleStuff</code> 还有 <code>do_args_method</code></p><h2 id="首字母大写的缩写"><a href="#首字母大写的缩写" class="headerlink" title="首字母大写的缩写"></a>首字母大写的缩写</h2><p>用首字母大写缩写（比如 <code>GNU</code> 代表 <code>GNU’s Not Unix</code> ) 使代码简洁难懂。真正的汉子(<del>无论男女</del>)从来不说明这种缩写的含义，他们生下来就懂</p><h2 id="辞典大轮换"><a href="#辞典大轮换" class="headerlink" title="辞典大轮换"></a>辞典大轮换</h2><p>为了打破沉闷的编程气氛，你可以用一本辞典来查找尽量多的同义词。例如 <code>display</code> , <code>show</code> , <code>present</code> 。在注释里含糊其辞地暗示这些命名之间有细微的差别，其实根本没有。不过，如果有两个命名相似的函数真的有重大差别，那倒是一定要确保它们用相同的单词来命名(例如，对于 “写入文件”, “在纸上书写” 和 “屏幕显示” 都用 <code>print</code> 来命名)。 在任何情况下都不要屈服于编写明确的项目词汇表这种无理要求。你可以辩解说，这种要求是一种不专业的行为，它违反了结构化设计的信息隐藏原则</p><h2 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h2><p>随机地把单词中间某个音节的首字母大写。例如 <code>ComputeReSult()</code></p><h2 id="重用命名"><a href="#重用命名" class="headerlink" title="重用命名"></a>重用命名</h2><p>在语言规则允许的地方，尽量把 <code>类</code> 、<code>构造器</code> 、<code>方法</code> 、<code>成员变量</code> 、<code>参数</code> 和 <code>局部变量</code> 都命名成一样。更高级的技巧是在 <code>{}</code> 块中重用局部变量。这样做的目的是迫使维护代码的程序员认真检查每个实例的作用域。特别是在 <code>Java</code> 代码中，可以把普通方法伪装成构造器</p><h2 id="使用非英语字母"><a href="#使用非英语字母" class="headerlink" title="使用非英语字母"></a>使用非英语字母</h2><p>在命名中偷偷使用不易察觉的非英语字母，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> i; &#125; ínt;</span><br></pre></td></tr></table></figure><p>看上去没啥不对是吧？嘿嘿嘿…这里的第二个 <code>ínt</code> 的 <code>í</code> 实际上是东北欧字母，并不是英语中的 <code>i</code> 。在简单的文本编辑器里，想看出这一点点区别几乎是不可能的。</p><h2 id="利用编译器对于命名长度的限制"><a href="#利用编译器对于命名长度的限制" class="headerlink" title="利用编译器对于命名长度的限制"></a>利用编译器对于命名长度的限制</h2><p>如果编译器只区分命名的前几位，比如前 <code>8</code> 位，那么就把后面的字母写得不一样。比如，其实是同一个变量，有时候写成 <code>var_unit_update()</code> ，有时候又写成 <code>var_unit_setup()</code>，看起来是两个不同的函数调用。而在编译的时候，它们其实是同一个函数 <code>var_unit()</code></p><h2 id="下划线，真正的朋友"><a href="#下划线，真正的朋友" class="headerlink" title="下划线，真正的朋友"></a>下划线，真正的朋友</h2><p>可以拿 _ 和 __ 作为标示符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判素</span></span><br><span class="line"><span class="keyword">void</span> _(<span class="keyword">int</span> __, <span class="keyword">int</span> ___, <span class="keyword">int</span> ____, <span class="keyword">int</span> _____) &#123;</span><br><span class="line">    ((___ / __) &lt;= _____) ? _(__,___+_____,____,_____) : !(___ % __) ? _(__,___+_____,___ % __, _____) :</span><br><span class="line">    ((___ % __)==(___ / __) &amp;&amp; !____) ? (<span class="built_in">printf</span>(<span class="string">"%dt"</span>,(___ / __)),</span><br><span class="line">    _(__,___+_____,____,_____)) : ((___ % __) &gt; _____ &amp;&amp; (___ % __) &lt; (___ / __)) ?</span><br><span class="line">    _(__,___+_____,____,_____ + !((___ / __) % (___ % __))) : (___ &lt; __ * __) ?</span><br><span class="line">    _(__,___+_____,____,_____) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _(<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合多语言"><a href="#混合多语言" class="headerlink" title="混合多语言"></a>混合多语言</h2><p>随机地混用两种语言（人类语言或计算机语言都行）。如果老板要求使用他指定的语言，你就告诉他你用自己的语言更有利于组织你的思路，万一这招不管用，就去控诉这是语言歧视，并威胁起诉老板要求巨额精神损失赔偿</p><h2 id="扩展-ASCII-字符"><a href="#扩展-ASCII-字符" class="headerlink" title="扩展 ASCII 字符"></a>扩展 ASCII 字符</h2><p>扩展 <code>ASCII</code> 字符用于变量命名是完全合法的，包括 <code>ß,</code> <code>Ð</code>, 和 <code>ñ</code> 等。在简单的文本编辑器里，除了拷贝/粘贴，基本上没法输入</p><h2 id="其他语言的命名"><a href="#其他语言的命名" class="headerlink" title="其他语言的命名"></a>其他语言的命名</h2><p>使用外语字典作为变量名的来源。例如，可以用德语单词 <code>punkt</code> 代替 <code>point</code>。除非维护代码的程序员也像你一样熟练掌握了德语. 不然他就只能尽情地在代码中享受异域风情了</p><h2 id="数学命名"><a href="#数学命名" class="headerlink" title="数学命名"></a>数学命名</h2><p>用数学操作符的单词来命名变量。例如：</p><blockquote><p><code>openParen = (slash + asterix) / equals;</code></p><p><em>(左圆括号 = (斜杠 + 星号)/等号;)</em></p></blockquote><h2 id="令人眩晕的命名"><a href="#令人眩晕的命名" class="headerlink" title="令人眩晕的命名"></a>令人眩晕的命名</h2><p>用带有完全不相关的感情色彩的单词来命名变量。例如：</p><blockquote><p><code>marypoppins = (superman + starship) / god;</code></p><p><em>(欢乐满人间 = (超人 + 星河战队)/上帝;)</em></p></blockquote><p>这一招可以让阅读代码的人陷入迷惑之中，因为他们在试图想清楚这些命名的逻辑时，会不自觉地联系到不同的感情场景里而无法自拔</p><h2 id="何时使用-i"><a href="#何时使用-i" class="headerlink" title="何时使用 i"></a>何时使用 i</h2><p>永远不要把 <code>i</code> 用作最内层的循环变量。 用什么命名都行，就是别用 <code>i</code>。把 <code>i</code> 用在其他地方就随便了，用作非整数变量尤其好</p><h2 id="惯例-—-明修栈道，暗度陈仓"><a href="#惯例-—-明修栈道，暗度陈仓" class="headerlink" title="惯例 — 明修栈道，暗度陈仓"></a>惯例 — 明修栈道，暗度陈仓</h2><p>忽视 <code>Java</code> 编码惯例，<code>Sun</code> 自己就是这样做的。幸运的是，你违反了它编译器也不会打小报告。这一招的目的是搞出一些在某些特殊情况下有细微差别的名字来。如果你被强迫遵循驼峰法命名，你还是可以在某些模棱两可的情况下颠覆它</p><p>例如，<code>inputFilename</code> 和 <code>inputfileName</code> 两个命名都可以合法使用。在此基础上自己发明一套复杂到变态的命名惯例，然后就可以对其他人反咬一口，说他们违反了惯例</p><h2 id="小写的-l-看上去很像数字-1"><a href="#小写的-l-看上去很像数字-1" class="headerlink" title="小写的 l 看上去很像数字 1"></a>小写的 l 看上去很像数字 1</h2><p>用小写字母 <code>l</code> 标识 <code>long</code> 常数。例如 <code>10l</code> 更容易被误认为是 <code>101</code> 而不是 <code>10L</code> 。 禁用所有能让人准确区分 <code>uvw wW gq9 2z 5s il17|!j oO08 &#39;” ;,. m nn rn {[()]}</code> 的字体。要做个有创造力的人</p><h2 id="把全局命名重用为私有"><a href="#把全局命名重用为私有" class="headerlink" title="把全局命名重用为私有"></a>把全局命名重用为私有</h2><p>在 <code>A</code> 模块里声明一个全局数组，然后在 <code>B</code> 模块的头文件里再声明一个同名的私有数组，这样看起来你在 <code>B</code> 模块里引用的是那个全局数组，其实却不是。不要在注释里提到这个重复的情况</p><h2 id="误导性的命名"><a href="#误导性的命名" class="headerlink" title="误导性的命名"></a>误导性的命名</h2><p>让每个方法都和它的名字蕴含的功能有一些差异。例如，一个叫 <code>isValid(x)</code> 的方法在判断完参数 <code>x</code> 的合法性之后，还顺带着把它转换成二进制并保存到数据库里qwq（</p><h1 id="伪装"><a href="#伪装" class="headerlink" title="伪装"></a>伪装</h1><blockquote><p><em>当一个bug需要越长的时间才会暴露，它就越难被发现。</em></p><p><em>– Roedy Green</em></p></blockquote><p>编写无法维护代码的另一大秘诀就是伪装的艺术，即隐藏它或者让它看起来像其他东西。很多招式有赖于这样一个事实：编译器比肉眼或文本编辑器更有分辨能力。下面是一些伪装的最佳招式</p><p>把代码伪装成注释，反之亦然</p><p>下面包括了一些被注释掉的代码，但是一眼看去却像是正常代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; array_len; j += <span class="number">8</span>) &#123;</span><br><span class="line">    total += <span class="built_in">array</span>[j + <span class="number">0</span>];</span><br><span class="line">    total += <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">    total += <span class="built_in">array</span>[j + <span class="number">2</span>]; <span class="comment">/* Main body of</span></span><br><span class="line"><span class="comment">    total += array[j + 3]; * loop is unrolled</span></span><br><span class="line"><span class="comment">    total += array[j + 4]; * for greater speed.</span></span><br><span class="line"><span class="comment">    total += array[j + 5]; */</span></span><br><span class="line">    total += <span class="built_in">array</span>[j + <span class="number">6</span>];</span><br><span class="line">    total += <span class="built_in">array</span>[j + <span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是语法高亮，这个你会看出来吗（</p><h2 id="用连接符隐藏变量"><a href="#用连接符隐藏变量" class="headerlink" title="用连接符隐藏变量"></a>用连接符隐藏变量</h2><p>对于下面的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define local_var xy_z</span><br></pre></td></tr></table></figure><p>可以把 <code>xy_z</code> 打散到两行里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define local_var xy\</span><br><span class="line">_z // local_var OK</span><br></pre></td></tr></table></figure><p>这样全局搜索 <code>xy_z</code> 的操作在这个文件里就一无所获了。 对于 <code>C</code> 预处理器来说，第一行最后的 <code>\</code> 表示继续拼接下一行的内容</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><blockquote><p><em>任何傻瓜都能说真话，而要把谎编圆则需要相当的智慧。</em></p><p><em>– Samuel Butler (1835 – 1902)</em></p><p><em>不正确的文档往往比没有文档还糟糕。</em></p><p><em>– Bertrand Meyer</em></p></blockquote><p>既然计算机是忽略注释和文档的，你就可以在里边堂而皇之地编织弥天大谎，让可怜的维护代码的程序员彻底迷失</p><h2 id="在注释中撒谎"><a href="#在注释中撒谎" class="headerlink" title="在注释中撒谎"></a>在注释中撒谎</h2><p>实际上你不需要主动地撒谎，只要没有及时保持注释和代码更新的一致性就可以了</p><h2 id="只记录显而易见的东西"><a href="#只记录显而易见的东西" class="headerlink" title="只记录显而易见的东西"></a>只记录显而易见的东西</h2><p>往代码里掺进去类似于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 给 i 加 1 */</span></span><br></pre></td></tr></table></figure><p>这样的注释，但是永远不要记录包或者方法的整体设计这样的干货</p><h2 id="记录-How-而不是-Why"><a href="#记录-How-而不是-Why" class="headerlink" title="记录 How 而不是 Why"></a>记录 How 而不是 Why</h2><p>只解释一个程序功能的细节，而不是它要完成的任务是什么。这样的话，如果出现了一个bug，修复者就搞不清这里的代码应有的功能</p><h2 id="该写的别写"><a href="#该写的别写" class="headerlink" title="该写的别写"></a>该写的别写</h2><p>比如你在开发一套航班预定系统，那就要精心设计，让它在增加另一个航空公司的时候至少有 <code>25</code> 处代码需要修改。永远不要在文档里说明要修改的位置。后来的开发人员要想修改你的代码？门都没有，除非他们能把每一行代码都读懂</p><h2 id="计量单位"><a href="#计量单位" class="headerlink" title="计量单位"></a>计量单位</h2><p>永远不要在文档中说明任何变量、输入、输出或参数的计量单位，如 <code>英尺</code> 、<code>米</code> 、<code>加仑</code> 等。计量单位对数豆子不是太重要，但在工程领域就相当重要了</p><p>同理，永远不要说明任何转换常量的计量单位，或者是它的取值如何获得。要想让代码更乱的话，你还可以在注释里写上错误的计量单位，这是赤裸裸的欺骗，但是非常有效</p><p>如果你想做一个恶贯满盈的人，不妨自己发明一套计量单位，用自己或某个小人物的名字命名这套计量单位，但不要给出定义。万一有人挑刺儿，你就告诉他们，你这么做是为了把浮点数运算凑成整数运算而进行的转换</p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>永远不要记录代码中的坑。如果你怀疑某个类里可能有 <code>bug</code> ，天知地知你知就好。如果你想到了重构或重写代码的思路，看在老天爷的份上，千万别写出来</p><p>切记电影《小鹿斑比》里那句台词 “如果你不能说好听的话，那就什么也不要说。”。万一这段代码的原作者看到你的注释怎么办？万一老板看到了怎么办？万一客户看到了怎么办？搞不好最后你自己被解雇了。一句 <code>这里需要修改</code> 的匿名注释就好多了，尤其是当看不清这句注释指的是哪里需要修改的情况下。切记 <code>难得糊涂</code> 四个字，这样大家都不会感觉受到了批评</p><h2 id="说明变量"><a href="#说明变量" class="headerlink" title="说明变量"></a>说明变量</h2><p>永远不要对变量声明加注释。有关变量使用的方式、边界值、合法值、小数点后的位数、计量单位、显示格式、数据录入规则等等，后继者完全可以自己从程序代码中去理解和整理嘛</p><p>如果老板强迫你写注释，就在方法体里胡乱多写点，但绝对不要对变量声明写注释，即使是临时变量！</p><h2 id="在注释里挑拨离间"><a href="#在注释里挑拨离间" class="headerlink" title="在注释里挑拨离间"></a>在注释里挑拨离间</h2><p>为了阻挠任何雇佣外部维护承包商的倾向，可以在代码中散布针对其他同行软件公司的攻击和抹黑，特别是可能接替你工作的其中任何一家。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 优化后的内层循环</span></span><br><span class="line"><span class="comment">这套技巧对于 SSI 软件服务公司的那帮蠢材来说太高深了，他们只会</span></span><br><span class="line"><span class="comment">用 &lt;math.h&gt; 里的笨例程，消耗50倍的内存和处理时间。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clever_SSInc</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的话，除了注释之外，这些攻击抹黑的内容也要掺到代码里的重要语义部分，这样如果管理层想清理掉这些攻击性的言论然后发给外部承包商去维护，就会破坏代码结构</p><h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><blockquote><p><em>编写无法维护代码的基本规则就是：在尽可能多的地方，以尽可能多的方式表述每一个事实。</em></p><p><em>– Roedy Green</em></p></blockquote><p>编写可维护代码的关键因素是只在一个地方表述应用里的一个事实。如果你的想法变了，你也只在一个地方修改，这样就能保证整个程序正常工作。所以，编写无法维护代码的关键因素就是反复地表述同一个事实，在尽可能多的地方，以尽可能多的方式进行。令人高兴的是，像Java这样的语言让编写这种无法维护代码变得非常容易。例如，改变一个被引用很多的变量的类型几乎是不可能的，因为所有造型和转换功能都会出错，而且关联的临时变量的类型也不合适了。而且，如果变量值要在屏幕上显示，那么所有相关的显示和数据录入代码都必须一一找到并手工进行修改。类似的还有很多，比如由C和Java组成的Algol语言系列，Abundance甚至Smalltalk对于数组等结构的处理，都是大有可为的</p><h2 id="Java-造型"><a href="#Java-造型" class="headerlink" title="Java 造型"></a>Java 造型</h2><p><code>Java</code> 的造型机制是上帝的礼物。你可以问心无愧地使用它，因为 <code>Java</code> 语言本身就需要它。每次你从一个 <code>Collection</code> 里获取一个对象，你都必须把它造型为原始类型。这样这个变量的类型就必须在无数地方表述。如果后来类型变了，所有的造型都要修改才能匹配。如果倒霉的维护代码的程序员没有找全（或者修改太多），编译器能不能检测到也不好说。类似的，如果变量类型从 <code>short</code> 变成 <code>int</code>，所有匹配的造型也都要从( <code>short</code>) 改成 (<code>int</code>)</p><h2 id="利用Java的冗余"><a href="#利用Java的冗余" class="headerlink" title="利用Java的冗余"></a>利用Java的冗余</h2><p><code>Java</code> 要求你给每个变量的类型写两次表述。 <code>Java</code> 程序员已经习惯了这种冗余，他们不会注意到你的两次表述有细微的差别，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bubblegum b = <span class="keyword">new</span> Bubblegom();</span><br></pre></td></tr></table></figure><p>不幸的是 ++ 操作符的盛行让下面这种伪冗余代码得手的难度变大了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swimmer = swimner + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="永远不做校验"><a href="#永远不做校验" class="headerlink" title="永远不做校验"></a>永远不做校验</h2><p>永远不要对输入数据做任何的正确性或差异性检查。这样能表现你对公司设备的绝对信任，以及你是一位信任所有项目伙伴和系统管理员的团队合作者。总是返回合理的值，即使数据输入有问题或者错误</p><h2 id="有礼貌，无断言"><a href="#有礼貌，无断言" class="headerlink" title="有礼貌，无断言"></a>有礼貌，无断言</h2><p>避免使用 <code>assert()</code> 机制，因为它可能把三天的 <code>debug</code> 盛宴变成 <code>10</code> 分钟的快餐</p><h2 id="避免封装"><a href="#避免封装" class="headerlink" title="避免封装"></a>避免封装</h2><p>为了提高效率，不要使用封装。方法的调用者需要所有能得到的外部信息，以便了解方法的内部是如何工作的</p><h2 id="复制粘贴修改"><a href="#复制粘贴修改" class="headerlink" title="复制粘贴修改"></a>复制粘贴修改</h2><p>以效率的名义，使用 <code>复制</code> + <code>粘贴</code> + <code>修改</code>。这样比写成小型可复用模块效率高得多。在用代码行数衡量你的进度的小作坊里，这招尤其管用</p><h2 id="使用静态数组"><a href="#使用静态数组" class="headerlink" title="使用静态数组"></a>使用静态数组</h2><p>如果一个库里的模块需要一个数组来存放图片，就定义一个静态数组。没人会有比 <code>512 x 512</code> 更大的图片，所以固定大小的数组就可以了。为了最佳精度，就把它定义成 <code>double</code> 类型的数组</p><h2 id="傻瓜接口"><a href="#傻瓜接口" class="headerlink" title="傻瓜接口"></a>傻瓜接口</h2><p>编写一个名为 <code>WrittenByMe</code> 之类的空接口，然后让你的所有类都实现它。然后给所有你用到的 <code>Java</code> 内置类编写包装类。这里的思想是确保你程序里的每个对象都实现这个接口。最后，编写所有的方法，让它们的参数和返回类型都是这个 <code>WrittenByMe</code>。这样就几乎不可能搞清楚某个方法的功能是什么，并且所有类型都需要好玩的造型方法。更出格的玩法是，让每个团队成员编写它们自己的接口(例如 <code>WrittenByJoe</code>)，程序员用到的任何类都要实现他自己的接口。这样你就可以在大量无意义接口中随便找一个来引用对象了</p><h2 id="巨型监听器"><a href="#巨型监听器" class="headerlink" title="巨型监听器"></a>巨型监听器</h2><p>永远不要为每个组件创建分开的监听器。对所有按钮总是用同一个监听器，只要用大量的 <code>if…else</code> 来判断是哪一个按钮被点击就行了</p><h2 id="好事成堆"><a href="#好事成堆" class="headerlink" title="好事成堆"></a>好事成堆</h2><p>狂野地使用封装和 <code>OO</code> 思想。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myPanel.add( getMyButton() ); </span><br><span class="line"><span class="function"><span class="keyword">private</span> JButton <span class="title">getMyButton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> myButton; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段很可能看起来不怎么好笑。别担心，只是时候未到而已</p><h2 id="友好的朋友"><a href="#友好的朋友" class="headerlink" title="友好的朋友"></a>友好的朋友</h2><p>在 <code>C++</code> 里尽量多使用 <code>friend</code> 声明。再把创建类的指针传递给已创建类。现在你不用浪费时间去考虑接口了。另外，你应该用上关键字 <code>private</code> 和 <code>protected</code> 来表明你的类封装得很好</p><h2 id="使用三维数组"><a href="#使用三维数组" class="headerlink" title="使用三维数组"></a>使用三维数组</h2><p>大量使用它们。用扭曲的方式在数组之间移动数据，比如，用 <code>arrayA</code> 里的行去填充 <code>arrayB</code> 的列。这么做的时候，不管三七二十一再加上 <code>1</code> 的偏移值，这样很灵。让维护代码的程序员抓狂去吧</p><h2 id="混合与匹配"><a href="#混合与匹配" class="headerlink" title="混合与匹配"></a>混合与匹配</h2><p>存取方法和公共变量神马的都要给他用上。这样的话，你无需调用存取器的开销就可以修改一个对象的变量，还能宣称这个类是个 <code>Java Bean</code> 。对于那些试图添加日志函数来找出改变值的源头的维护代码的程序员，用这一招来迷惑他尤其有效</p><h2 id="没有秘密"><a href="#没有秘密" class="headerlink" title="没有秘密!"></a>没有秘密!</h2><p>把每个方法和变量都声明为 <code>public</code>。毕竟某个人某天可能会需要用到它。一旦方法被声明为 <code>public</code> 了，就很难缩回去。对不？这样任何它覆盖到的代码都很难修改了。它还有个令人愉快的副作用，就是让你看不清类的作用是什么。如果老板质问你是不是疯了，你就告诉他你遵循的是经典的透明接口原则</p><h2 id="全堆一块"><a href="#全堆一块" class="headerlink" title="全堆一块"></a>全堆一块</h2><p>把你所有的没用的和过时的方法和变量都留在代码里。毕竟说起来，既然你在 <code>1976</code> 年用过一次，谁知道你啥时候会需要再用到呢？当然程序是改了，但它也可能会改回来嘛，你 <code>不想要重新发明轮子</code>（领导们都会喜欢这样的口气）。如果你还原封不动地留着这些方法和变量的注释，而且注释写得又高深莫测，甭管维护代码的是谁，恐怕都不敢对它轻举妄动</p><h2 id="就是-Final"><a href="#就是-Final" class="headerlink" title="就是 Final"></a>就是 Final</h2><p>把你所有的叶子类都声明为 <code>final</code> 。毕竟说起来，你在项目里的活儿都干完了，显然不会有其他人会通过扩展你的类来改进你的代码。这种情况甚至可能有安全漏洞。 <code>java.lang.String</code> 被定义成 <code>final</code> 也许就是这个原因吧？如果项目组其他程序员有意见，告诉他们这样做能够提高运行速度</p><h2 id="避免布局"><a href="#避免布局" class="headerlink" title="避免布局"></a>避免布局</h2><p>永远不要用到布局。当维护代码的程序员想增加一个字段，他必须手工调整屏幕上显示所有内容的绝对坐标值。如果老板强迫你使用布局，那就写一个巨型的 <code>GridBagLayout</code> 并在里面用绝对坐标进行硬编码</p><h2 id="全局变量，怎么强调都不过分"><a href="#全局变量，怎么强调都不过分" class="headerlink" title="全局变量，怎么强调都不过分"></a>全局变量，怎么强调都不过分</h2><p>如果上帝不愿意我们使用全局变量，他就不会发明出这个东西。不要让上帝失望，尽量多使用全局变量。每个函数最起码都要使用和设置其中的两个，即使没有理由也要这么做。毕竟，任何优秀的维护代码的程序员都会很快搞清楚这是一种侦探工作测试，有利于让他们从笨蛋中脱颖而出</p><h2 id="再一次说说全局变量"><a href="#再一次说说全局变量" class="headerlink" title="再一次说说全局变量"></a>再一次说说全局变量</h2><p>全局变量让你可以省去在函数里描述参数的麻烦。充分利用这一点。在全局变量中选那么几个来表示对其他全局变量进行操作的类型。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>永远不要用局部变量。在你感觉想要用的时候，把它改成一个实例或者静态变量，并无私地和其他方法分享它。这样做的好处是，你以后在其他方法里写类似声明的时候会节省时间。<code>C++</code> 程序员可以百尺竿头更进一步，把所有变量都弄成全局的</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件通常是以 <code>关键字 = 值</code> 的形式出现。在加载时这些值被放入 <code>Java</code> 变量中。最明显的迷惑技术就是把有细微差别的名字用于关键字和 <code>Java</code> 变量.甚至可以在配置文件里定义运行时根本不会改变的常量。参数文件变量和简单变量比，维护它的代码量起码是后者的 <code>5</code> 倍。</p><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>对于编写无法维护代码的任务来说，面向对象编程的思想简直是天赐之宝。如果你有一个类，里边有10个属性（成员/方法），可以考虑写一个基类，里面只有一个属性，然后产生 <code>9</code> 层的子类，每层增加一个属性。等你访问到最终的子类时，你才能得到全部 <code>10</code> 个属性。如果可能，把每个类的声明都放在不同的文件里</p><h1 id="代码迷局"><a href="#代码迷局" class="headerlink" title="代码迷局"></a>代码迷局</h1><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>重载操作符可以让你的代码变得诡异，感谢 <code>CCTV</code> ，感谢 <code>C++</code>。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 <code>!</code> 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 <code>!!</code> 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。</p><h2 id="迷惑-C"><a href="#迷惑-C" class="headerlink" title="迷惑 C"></a>迷惑 C</h2><p>从互联网上的各种混乱 <code>C</code> 语言竞赛中学习，追随大师们的脚步。</p><h2 id="追求极致"><a href="#追求极致" class="headerlink" title="追求极致"></a>追求极致</h2><p>总是追求用最迷惑的方式来做普通的任务。例如，要用数组来把整数转换为相应的字符串，可以这么做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p; </span><br><span class="line"><span class="keyword">switch</span> (n) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">   p = <span class="string">"one"</span>; </span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span>) </span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">   p = <span class="string">"two"</span>; </span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span>) </span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">   p = <span class="string">"three"</span>; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s"</span>, p); </span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一致性的小淘气"><a href="#一致性的小淘气" class="headerlink" title="一致性的小淘气"></a>一致性的小淘气</h2><p>当你需要一个字符常量的时候，可以用多种不同格式： <code>‘ ‘</code> , <code>32</code>, <code>0x20</code>, <code>040</code>。在 <code>C</code> 或 <code>Java</code> 里 <code>10</code> 和 <code>010</code> 是不同的数（ <code>0</code> 开头的表示 <code>8</code> 进制），你也可以充分利用这个特性</p><h2 id="造型"><a href="#造型" class="headerlink" title="造型"></a>造型</h2><p>把所有数据都以 <code>void *</code> 形式传递，然后再造型为合适的结构。不用结构而是通过位移字节数来造型也很好玩</p><h2 id="嵌套-switch"><a href="#嵌套-switch" class="headerlink" title="嵌套 switch"></a>嵌套 switch</h2><p><code>switch</code> 里边还有 <code>switch</code>，这种嵌套方式是人类大脑难以破解的</p><h2 id="利用隐式转化"><a href="#利用隐式转化" class="headerlink" title="利用隐式转化"></a>利用隐式转化</h2><p>牢记编程语言中所有的隐式转化细节。充分利用它们。数组的索引要用浮点变量，循环计数器用字符，对数字执行字符串函数调用。不管怎么说，所有这些操作都是合法的，它们无非是让源代码更简洁而已。任何尝试理解它们的维护者都会对你感激不尽，因为他们必须阅读和学习整个关于隐式数据类型转化的章节，而这个章节很可能是他们来维护你的代码之前完全忽略了的。</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号!"></a>分号!</h2><p>在所有语法允许的地方都加上分号，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a); </span><br><span class="line"><span class="keyword">else</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> d; </span><br><span class="line">d = c; </span><br><span class="line">&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="使用八进制数"><a href="#使用八进制数" class="headerlink" title="使用八进制数"></a>使用八进制数</h2><p>把八进制数混到十进制数列表里，就像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;</span><br><span class="line">	<span class="number">111</span>, <span class="number">120</span>,</span><br><span class="line">	<span class="number">013</span>, <span class="number">121</span>, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>尽可能深地嵌套。优秀的程序员能在一行代码里写10层()，在一个方法里写20层{}。</p><h2 id="C数组"><a href="#C数组" class="headerlink" title="C数组"></a>C数组</h2><p><code>C</code> 编译器会把 <code>myArray[i]</code> 转换成 <code>*(myArray + i)</code> ，它等同于 <code>*(i + myArray)</code> 也等同于 <code>i[myArray]</code>。 高手都知道怎么用好这个招。可以用下面的函数来产生索引，这样就把代码搞乱了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p%q; &#125; </span><br><span class="line">... </span><br><span class="line">myfunc(<span class="number">6291</span>, <span class="number">8</span>)[Array];</span><br></pre></td></tr></table></figure><p>遗憾的是，这一招只能在本地 <code>C</code> 类里用，<code>Java</code> 还不行</p><h2 id="放长线钓大鱼"><a href="#放长线钓大鱼" class="headerlink" title="放长线钓大鱼"></a>放长线钓大鱼</h2><p>一行代码里堆的东西越多越好。这样可以省下临时变量的开销，去掉换行和空格还可以缩短源文件大小。记住，要去掉运算符两边的空格。优秀的程序员总是能突破某些编辑器对于 <code>255</code> 个字符行宽的限制</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在这里我要向你传授一个编程领域里鲜为人知的秘诀。异常是个讨厌的东西。良好的代码永远不会出错，所以异常实际上是不必要的。不要把时间浪费在这上面。子类异常是给那些知道自己代码会出错的低能儿用的。在整个应用里，你只用在 <code>main()</code> 里放一个 <code>try/catch</code> ，里边直接调用 <code>System.exit()</code> 就行了。在每个方法头要贴上标准的抛出集合定义，至于会不会抛出异常你就甭管了</p><h2 id="使用异常的时机"><a href="#使用异常的时机" class="headerlink" title="使用异常的时机"></a>使用异常的时机</h2><p>在非异常条件下才要使用异常。比如终止循环就可以用 <code>ArrayIndexOutOfBoundsException</code>。还可以从异常里的方法返回标准的结果</p><h2 id="狂热奔放地使用线程"><a href="#狂热奔放地使用线程" class="headerlink" title="狂热奔放地使用线程"></a>狂热奔放地使用线程</h2><p>如题</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在程序里留些 <code>bug</code> ，让后继的维护代码的程序员能做点有意思的事。精心设计的 <code>bug</code> 是无迹可寻的，而且谁也不知道它啥时候会冒出来。要做到这一点，最简单的办法的就是不要测试代码</p><h2 id="永不测试"><a href="#永不测试" class="headerlink" title="永不测试"></a>永不测试</h2><p>永远不要测试负责处理错误、当机或操作系统故障的任何代码。反正这些代码永远也不会执行，只会拖累你的测试。还有，你怎么可能测试处理磁盘错误、文件读取错误、操作系统崩溃这些类型的事件呢？为啥你要用特别不稳定的计算机或者用测试脚手架来模拟这样的环境？现代化的硬件永远不会崩溃，谁还愿意写一些仅仅用于测试的代码？这一点也不好玩。万一将来出了事用户抱怨，你就怪到操作系统或者硬件头上。他们永远不会知道真相的</p><h2 id="永远不要做性能测试"><a href="#永远不要做性能测试" class="headerlink" title="永远不要做性能测试"></a>永远不要做性能测试</h2><p>嘿，如果软件运行不够快，只要告诉客户买个更快的机器就行了。如果你真的做了性能测试，你可能会发现一个瓶颈，这会导致修改算法，然后导致整个产品要重新设计。谁想要这种结果？而且，在客户那边发现性能问题意味着你可以免费到外地旅游。你只要备好护照和最新照片就行了</p><h2 id="永远不要写任何测试用例"><a href="#永远不要写任何测试用例" class="headerlink" title="永远不要写任何测试用例"></a>永远不要写任何测试用例</h2><p>永远不要做代码覆盖率或路径覆盖率测试。自动化测试是给那些窝囊废用的。搞清楚哪些特性占到你的例程使用率的<code>90%</code> ，然后把 <code>90%</code> 的测试用在这些路径上。毕竟说起 来，这种方法可能只测试到了大约你代码的 <code>60%</code> ，这样你就节省了 <code>40%</code> 的测试工作。这能帮助你赶上项目后端的进度。等到有人发现所有这些漂亮的“市场特性”不能正常工作的时候，你早就跑路了。一些有名的大软件公司就是这样测试代码的，所以你也应该这样做。如果因为某种原因你还没走，那就接着看下一节</p><h2 id="测试是给懦夫用的"><a href="#测试是给懦夫用的" class="headerlink" title="测试是给懦夫用的"></a>测试是给懦夫用的</h2><p>勇敢的程序员会跳过这个步骤。太多程序员害怕他们的老板，害怕丢掉工作，害怕客户的投诉邮件，害怕遭到起诉。这种恐惧心理麻痹了行动，降低了生产率。有科学研究成果表明，取消测试阶段意味着经理有把握能提前确定交付时间，这对于规划流程显然是有利的。消除了恐惧心理，创新和实验之花就随之绽放。程序员的角色是生产代码，调试工作完全可以由技术支持和遗留代码维护组通力合作来进行</p><p>如果我们对自己的编程能力有充分信心，那么测试就没有必要了。如果我们逻辑地看待这个问题，随便一个傻瓜都能认识到测试根本都不是为了解决技术问题，相反，它是一种感性的信心问题。针对这种缺乏信心的问题，更有效的解决办法就是完全取消测试，送我们的程序员去参加自信心培训课程。毕竟说起来，如果我们选择做测试，那么我们就要测试每个程序的变更，但其实我们只需要送程序员去一次建立自信的培训课就行了。很显然这么做的成本收益是相当可观的</p><h1 id="选择你的编程语言"><a href="#选择你的编程语言" class="headerlink" title="选择你的编程语言"></a>选择你的编程语言</h1><p>计算机语言正在逐步进化，变得更加傻瓜化。使用最新的语言算什么好汉？尽可能坚持使用你会用的最老的语言，先考虑用穿孔纸带，不行就用汇编，再不行用FORTRAN 或者 COBOL，再不行就用C 还有 BASIC，实在不行再用 C++</p><h2 id="FORTRAN"><a href="#FORTRAN" class="headerlink" title="FORTRAN"></a>FORTRAN</h2><p>用 <code>FORTRAN</code> 写所有的代码。如果老板问你为啥，你可以回答说它有很多非常有用的库，你用它可以节约时间。不过，用 <code>FORTRAN</code> 写出可维护代码的概率是 <code>0</code>，所以，要达到不可维护代码编程指南里的要求就容易多了</p><h2 id="用-ASM"><a href="#用-ASM" class="headerlink" title="用 ASM"></a>用 ASM</h2><p>把所有的通用工具函数都转成汇编程序</p><h2 id="用-QBASIC"><a href="#用-QBASIC" class="headerlink" title="用 QBASIC"></a>用 QBASIC</h2><p>所有重要的库函数都要用 <code>QBASIC</code> 写，然后再写个汇编的封包程序来处理 <code>large</code> 到 <code>medium</code> 的内存模型映射</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>在你的代码里混杂一些内联的汇编程序，这样很好玩。这年头几乎没人懂汇编程序了。只要放几行汇编代码就能让维护代码的程序员望而却步</p><h2 id="宏汇编调用C"><a href="#宏汇编调用C" class="headerlink" title="宏汇编调用C"></a>宏汇编调用C</h2><p>如果你有个汇编模块被 <code>C</code> 调用，那就尽可能经常从汇编模块再去调用 <code>C</code> ，即使只是出于微不足道的用途，另外要充分利用 <code>goto</code>, <code>bcc</code> 和其他炫目的汇编秘籍。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="不要重编译"><a href="#不要重编译" class="headerlink" title="不要重编译"></a>不要重编译</h2><p>让我们从一条可能是有史以来最友好的技巧开始：把代码编译成可执行文件。如果它能用，就在源代码里做一两个微小的改动 — 每个模块都照此办理。但是不要费劲巴拉地再编译一次了。 你可以留着等以后有空而且需要调试的时候再说。多年以后，等可怜的维护代码的程序员更改了代码之后发现出错了，他会有一种错觉，觉得这些肯定是他自己最近修改的。这样你就能让他毫无头绪地忙碌很长时间。</p><h2 id="挫败调试工具"><a href="#挫败调试工具" class="headerlink" title="挫败调试工具"></a>挫败调试工具</h2><p>对于试图用行调试工具追踪来看懂你的代码的人，简单的一招就能让他狼狈不堪，那就是把每一行代码都写得很长。特别要把 then 语句 和 if 语句放在同一行里。他们无法设置断点。他们也无法分清在看的分支是哪个 if 里的。</p><h2 id="公制和美制"><a href="#公制和美制" class="headerlink" title="公制和美制"></a>公制和美制</h2><p>在工程方面有两种编码方式。一种是把所有输入都转换为公制（米制）计量单位，然后在输出的时候自己换算回各种民用计量单位。另一种是从头到尾都保持各种计量单位混合在一起。总是选择第二种方式，这就是美国之道！</p><h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><p>要持续不懈地改进。要常常对你的代码做出“改进”，并强迫用户经常升级 — 毕竟没人愿意用一个过时的版本嘛。即便他们觉得他们对现有的程序满意了，想想看，如果他们看到你又“完善“了它，他们会多么开心啊！不要告诉任何人版本之间的差别，除非你被逼无奈 — 毕竟，为什么要告诉他们本来永远也不会注意到的一些 <code>bug</code> 呢？</p><h2 id="quot-关于-quot"><a href="#quot-关于-quot" class="headerlink" title="&quot;关于&quot;"></a>&quot;关于&quot;</h2><p>”关于“一栏应该只包含程序名、程序员姓名和一份用法律用语写的版权声明。理想情况下，它还应该链接到几 MB 的代码，产生有趣的动画效果。但是，里边永远不要包含程序用途的描述、它的版本号、或最新代码修改日期、或获取更新的网站地址、或作者的 <code>email</code> 地址等。这样，所有的用户很快就会运行在各种不同的版本上，在安装 <code>N+1</code> 版之前就试图安装 <code>N+2</code> 版</p><h2 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h2><p>在两个版本之间，你能做的变更自然是多多益善。你不会希望用户年复一年地面对同一套老的接口或用户界面，这样会很无聊。最后，如果你能在用户不注意的情况下做出这些变更，那就更好了 — 这会让他们保持警惕，戒骄戒躁。</p><h2 id="无需技能"><a href="#无需技能" class="headerlink" title="无需技能"></a>无需技能</h2><p>写无法维护代码不需要多高的技术水平。喊破嗓子不如甩开膀子，不管三七二十一开始写代码就行了。记住，管理层还在按代码行数考核生产率，即使以后这些代码里的大部分都得删掉。</p><h2 id="只带一把锤子"><a href="#只带一把锤子" class="headerlink" title="只带一把锤子"></a>只带一把锤子</h2><p>一招鲜吃遍天，会干什么就吆喝什么，轻装前进。如果你手头只有一把锤子，那么所有的问题都是钉子。</p><h2 id="规范体系"><a href="#规范体系" class="headerlink" title="规范体系"></a>规范体系</h2><p>有可能的话，忽略当前你的项目所用语言和环境中被普罗大众所接受的编程规范。比如，编写基于 <code>MFC</code> 的应用时，就坚持使用 <code>STL</code> 编码风格。</p><h2 id="翻转通常的-True-False-惯例"><a href="#翻转通常的-True-False-惯例" class="headerlink" title="翻转通常的 True False 惯例"></a>翻转通常的 True False 惯例</h2><p>把常用的 <code>true</code> 和 <code>false</code> 的定义反过来用。这一招听起来平淡无奇，但是往往收获奇效。你可以先藏好下面的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 1</span></span><br></pre></td></tr></table></figure><p>把这个定义深深地藏在代码中某个没人会再去看的文件里不易被发现的地方，然后让程序做下面这样的比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( var == TRUE )</span><br><span class="line"><span class="keyword">if</span> ( var != FALSE )</span><br></pre></td></tr></table></figure><p>某些人肯定会迫不及待地跳出来“修正”这种明显的冗余，并且在其他地方照着常规去使用变量var：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( var )</span><br></pre></td></tr></table></figure><p>还有一招是为 <code>TRUE</code> 和 <code>FALSE</code> 赋予相同的值，虽然大部分人可能会看穿这种骗局。给它们分别赋值 <code>1</code> 和 <code>2</code> 或者 <code>-1</code> 和 <code>0</code> 是让他们瞎忙乎的方式里更精巧的，而且这样做看起来也不失对他们的尊重。你在 <code>Java</code> 里也可以用这一招，定义一个叫 <code>TRUE</code> 的静态常量。在这种情况下，其他程序员更有可能怀疑你干的不是好事，因为 <code>Java</code> 里已经有了内建的标识符 <code>true</code></p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>在你的项目里引入功能强大的第三方库，然后不要用它们。潜规则就是这样，虽然你对这些工具仍然一无所知，却可以在你简历的“其他工具”一节中写上这些没用过的库</p><h2 id="不要用库"><a href="#不要用库" class="headerlink" title="不要用库"></a>不要用库</h2><p>假装不知道有些库已经直接在你的开发工具中引入了。如果你用 <code>VC++</code> 编程，忽略 <code>MFC</code> 或 <code>STL</code> 的存在，手工编写所有字符串和数组的实现；这样有助于保持你玩指针技术的高水平，并自动阻止任何扩展代码功能的企图</p><h2 id="创建一套Build顺序"><a href="#创建一套Build顺序" class="headerlink" title="创建一套Build顺序"></a>创建一套Build顺序</h2><p>把这套顺序规则做得非常晦涩，让维护者根本无法编译任何他的修改代码。秘密保留 <code>SmartJ</code> ，它会让 <code>make</code> 脚本形同废物。类似地，偷偷地定义一个 <code>javac</code> 类，让它和编译程序同名。说到大招，那就是编写和维护一个定制的小程序，在程序里找到需要编译的文件，然后通过直接调用 <code>sun.tools.javac.Main</code> 编译类来进行编译。</p><h2 id="Make-的更多玩法"><a href="#Make-的更多玩法" class="headerlink" title="Make 的更多玩法"></a>Make 的更多玩法</h2><p>用一个 makefile-generated-batch-file 批处理文件从多个目录复制源文件，文件之间的覆盖规则在文档中是没有的。这样，无需任何炫酷的源代码控制系统，就能实现代码分支，并阻止你的后继者弄清哪个版本的 DoUsefulWork() 才是他需要修改的那个。</p><h2 id="搜集编码规范"><a href="#搜集编码规范" class="headerlink" title="搜集编码规范"></a>搜集编码规范</h2><p>尽可能搜集所有关于编写可维护代码的建议，例如 SquareBox 的建议 ，然后明目张胆地违反它们。</p><h2 id="规避公司的编码规则"><a href="#规避公司的编码规则" class="headerlink" title="规避公司的编码规则"></a>规避公司的编码规则</h2><p>某些公司有严格的规定，不允许使用数字标识符，你必须使用预先命名的常量。要挫败这种规定背后的意图太容易了。比如，一位聪明的 C++ 程序员是这么写的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_ONE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_TWO 2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_THOUSAND 999</span></span><br></pre></td></tr></table></figure><h2 id="编译器警告"><a href="#编译器警告" class="headerlink" title="编译器警告"></a>编译器警告</h2><p>一定要保留一些编译器警告。在 <code>make</code> 里使用 “<code>-</code>” 前缀强制执行，忽视任何编译器报告的错误。这样，即使维护代码的程序员不小心在你的源代码里造成了一个语法错误，<code>make</code> 工具还是会重新把整个包 <code>build</code> 一遍，甚至可能会成功！而任何程序员要是手工编译你的代码，看到屏幕上冒出一堆其实无关紧要的警告，他们肯定会觉得是自己搞坏了代码。同样，他们一定会感谢你让他们有找错的机会。学有余力的同学可以做点手脚让编译器在打开编译错误诊断工具时就没法编译你的程序。当然了，编译器也许能做一些脚本边界检查，但是真正的程序员是不用这些特性的，所以你也不该用。既然你用自己的宝贵时间就能找到这些精巧的bug，何必还多此一举让编译器来检查错误呢？</p><h2 id="把-bug-修复和升级混在一起"><a href="#把-bug-修复和升级混在一起" class="headerlink" title="把 bug 修复和升级混在一起"></a>把 bug 修复和升级混在一起</h2><p>永远不要发布什么“<code>bug</code> 修复”版本。一定要把 <code>bug</code> 修复和数据库结构变更、复杂的用户界面修改，还有管理界面重写等混在一起。那样的话，升级就变成一件非常困难的事情，人们会慢慢习惯 <code>bug</code> 的存在并开始称他们为特性。那些真心希望改变这些”特性“的人们就会有动力升级到新版本。这样从长期来说可以节省你的维护工作量，并从你的客户那里获得更多收入。</p><h2 id="在你的产品发布每个新版本的时候都改变文件结构"><a href="#在你的产品发布每个新版本的时候都改变文件结构" class="headerlink" title="在你的产品发布每个新版本的时候都改变文件结构"></a>在你的产品发布每个新版本的时候都改变文件结构</h2><p>没错，你的客户会要求向上兼容，那就去做吧。不过一定要确保向下是不兼容的。这样可以阻止客户从新版本回退，再配合一套合理的 bug 修复规则（见上一条），就可以确保每次新版本发布后，客户都会留在新版本。学有余力的话，还可以想办法让旧版本压根无法识别新版本产生的文件。那样的话，老版本系统不但无法读取新文件，甚至会否认这些文件是自己的应用系统产生的！温馨提示：PC 上的 Word 文字处理软件就典型地精于此道。</p><h2 id="抵消-Bug"><a href="#抵消-Bug" class="headerlink" title="抵消 Bug"></a>抵消 Bug</h2><p>不用费劲去代码里找 bug 的根源。只要在更高级的例程里加入一些抵销它的代码就行了。这是一种很棒的智力测验，类似于玩3D棋，而且能让将来的代码维护者忙乎很长时间都想不明白问题到底出在哪里：是产生数据的低层例程，还是莫名其妙改了一堆东西的高层代码。这一招对天生需要多回合执行的编译器也很好用。你可以在较早的回合完全避免修复问题，让较晚的回合变得更加复杂。如果运气好，你永远都不用和编译器前端打交道。学有余力的话，在后端做点手脚，一旦前端产生的是正确的数据，就让后端报错。</p><h2 id="使用旋转锁"><a href="#使用旋转锁" class="headerlink" title="使用旋转锁"></a>使用旋转锁</h2><p>不要用真正的同步原语，多种多样的旋转锁更好 — 反复休眠然后测试一个(non-volatile的) 全局变量，直到它符合你的条件为止。相比系统对象，旋转锁使用简便，”通用“性强，”灵活“多变，实为居家旅行必备。</p><h2 id="随意安插-sync-代码"><a href="#随意安插-sync-代码" class="headerlink" title="随意安插 sync 代码"></a>随意安插 sync 代码</h2><p>把某些系统同步原语安插到一些用不着它们的地方。本人曾经在一段不可能会有第二个线程的代码中看到一个临界区（<code>critical section</code>）代码。本人当时就质问写这段代码的程序员，他居然理直气壮地说这么写是为了表明这段代码是很”关键“（单词也是<code>critical</code>）的！</p><h2 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h2><p>如果你的系统包含了一套 NT 设备驱动，就让应用程序负责给驱动分配 I/O 缓冲区，然后在任何事务过程中对内存中的驱动加锁，并在事务完成后释放或解锁。这样一旦应用非正常终止，I/O缓存又没有被解锁，NT服务器就会当机。但是在客户现场不太可能会有人知道怎么弄好设备驱动，所以他们就没有选择（只能请你去免费旅游了）。</p><h2 id="定制脚本语言"><a href="#定制脚本语言" class="headerlink" title="定制脚本语言"></a>定制脚本语言</h2><p>在你的 <code>C/S</code> 应用里嵌入一个在运行时按字节编译的脚本命令语言。</p><h2 id="依赖于编译器的代码"><a href="#依赖于编译器的代码" class="headerlink" title="依赖于编译器的代码"></a>依赖于编译器的代码</h2><p>如果你发现在你的编译器或解释器里有个 <code>bug</code> ，一定要确保这个 <code>bug</code> 的存在对于你的代码正常工作是至关重要的。毕竟你又不会使用其他的编译器，其他任何人也不允许！</p><h2 id="一个货真价实的例子"><a href="#一个货真价实的例子" class="headerlink" title="一个货真价实的例子"></a>一个货真价实的例子</h2><p>下面是一位大师编写的真实例子。让我们来瞻仰一下他在这样短短几行 <code>C</code> 函数里展示的高超技巧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Realocate</span><span class="params">(<span class="keyword">void</span>*buf, <span class="keyword">int</span> os, <span class="keyword">int</span> ns)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>*temp; </span><br><span class="line">    temp = <span class="built_in">malloc</span>(os); </span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)temp, (<span class="keyword">void</span>*)buf, os); </span><br><span class="line">    <span class="built_in">free</span>(buf); </span><br><span class="line">    buf = <span class="built_in">malloc</span>(ns); </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, ns); </span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)buf, (<span class="keyword">void</span>*)temp, ns); </span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重新发明了标准库里已有的简单函数</li><li><code>Realocate</code> 这个单词拼写错误。所以说，永远不要低估创造性拼写的威力</li><li>无缘无故地给输入缓冲区产生一个临时的副本</li><li>无缘无故地造型。 <code>memcpy()</code> 里有 (<code>void*</code>)，这样即使我们的指针已经是 (<code>void*</code>) 了也要再造型一次。另外，这样做可以传递任何东西作为参数，加 <code>10</code> 分</li><li>永远不必费力去释放临时内存空间。这样会导致缓慢的内存泄露，一开始看不出来，要程序运行一段时间才行</li><li>把用不着的东西也从缓冲区里拷贝出来，以防万一。这样只会在 <code>Unix</code> 上产生 <code>core dump</code>，<code>Windows</code> 就不会</li><li>很显然，<code>os</code> 和 <code>ns</code> 的含义分别是”<code>old size</code>” 和 “<code>new size</code>”</li><li>给 <code>buf</code> 分配内存之后，<code>memset</code> 初始化它为 <code>0</code>。不要使用 <code>calloc()</code>，因为某些人会重写 <code>ANSI</code> 规范，这样将来保不齐 <code>calloc()</code> 往 <code>buf</code> 里填的就不是 <code>0</code> 了。（虽然我们复制过去的数据量和 <code>buf</code> 的大小是一样的，不需要初始化，不过这也无所谓啦）</li></ul><h2 id="如何修复-“unused-variable”-错误"><a href="#如何修复-“unused-variable”-错误" class="headerlink" title="如何修复 “unused variable” 错误"></a>如何修复 “unused variable” 错误</h2><p>如果你的编译器冒出了 “unused local variable” 警告，不要去掉那个变量。相反，要找个聪明的办法把它用起来。我最喜欢的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i;</span><br></pre></td></tr></table></figure><h2 id="大小很关键"><a href="#大小很关键" class="headerlink" title="大小很关键"></a>大小很关键</h2><p>差点忘了说了，函数是越大越好。跳转和 GOTO 语句越多越好。那样的话，想做任何修改都需要分析很多场景。这会让维护代码的程序员陷入千头万绪之中。如果函数真的体型庞大的话，对于维护代码的程序员就是哥斯拉怪兽了，它会在他搞清楚情况之前就残酷无情地将他踩翻在地。</p><h2 id="一张图片顶1000句话，一个函数就是1000行"><a href="#一张图片顶1000句话，一个函数就是1000行" class="headerlink" title="一张图片顶1000句话，一个函数就是1000行"></a>一张图片顶1000句话，一个函数就是1000行</h2><p>把每个方法体写的尽可能的长 — 最好是你写的任何一个方法或函数都不会少于1000行代码，而且里边是深度嵌套，这是必须的。</p><h2 id="少个文件"><a href="#少个文件" class="headerlink" title="少个文件"></a>少个文件</h2><p>一定要保证一个或多个关键文件无法找到。利用 <code>includes</code> 里边再 <code>includes</code> 就能做到这一点。例如，在你的 <code>main</code> 模块里，你写上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdcode.h&gt;</span><br></pre></td></tr></table></figure><p><code>Stdcode.h</code> 是有的。但是在 <code>stdcode.h</code> 里，还有个引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;a:\\refcode.h&quot;</span><br></pre></td></tr></table></figure><p>然后，<code>refcode.h</code> 就没地方能找到了</p><blockquote><p>Shq tips: 有谁知道 <code>a:</code> 盘是什么吗......就是传说中的软盘...</p></blockquote><h2 id="到处都写，无处会读"><a href="#到处都写，无处会读" class="headerlink" title="到处都写，无处会读"></a>到处都写，无处会读</h2><p>至少要把一个变量弄成这样：到处被设置，但是几乎没有哪里用到它。不幸的是，现代编译器通常会阻止你做相反的事：到处读，没处写。不过你在 <code>C</code> 或 <code>C++</code> 里还是可以这样做的。</p></div><div><div><blockquote class="blockquote-center">-------------本文结束<i class="fa fa-apple"></i>感谢您的阅读-------------</blockquote></div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="Shq 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="Shq 支付宝"><p>支付宝</p></div></div></div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Shq</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.ishq.site/articles/How-to-Make-A-Uneasy-to-Maintain-Code/" title="「代码规范」如何编写无法维护的代码">https://blog.ishq.site/articles/How-to-Make-A-Uneasy-to-Maintain-Code/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/优化/" rel="tag"><i class="fa fa-tag"></i> 优化</a> <a href="/tags/毒瘤/" rel="tag"><i class="fa fa-tag"></i> 毒瘤</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/articles/Kernel-privilege-escalation/" rel="next" title="「Linux / Windows」内核提权脚本"><i class="fa fa-chevron-left"></i> 「Linux / Windows」内核提权脚本</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/articles/2018-五校联考-Round1/" rel="prev" title="「2018 五校联考 Round1」题目讲解">「2018 五校联考 Round1」题目讲解 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Shq"><p class="site-author-name" itemprop="name">Shq</p><p class="site-description motion-element" itemprop="description">我不知道能否会成功，但我仍想试一试，哪怕只有一线希望</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">93</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">201</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Blog-Shq" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.luogu.org/space/show?uid=52556" target="_blank" title="洛谷"><i class="fa fa-fw fa-code"></i>洛谷</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/shq666" target="_blank" title="知乎"><i class="fa fa-fw fa-comment-o"></i>知乎</a> </span><span class="links-of-author-item"><a href="https://ly.men.ci" target="_blank" title="LYOI"><i class="fa fa-fw fa-star"></i>LYOI</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#总体原则"><span class="nav-number">1.</span> <span class="nav-text">总体原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#命名规则"><span class="nav-number">2.</span> <span class="nav-text">命名规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#妙用键盘"><span class="nav-number">2.1.</span> <span class="nav-text">妙用键盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单变量命名"><span class="nav-number">2.2.</span> <span class="nav-text">单变量命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创造性的拼写错误"><span class="nav-number">2.3.</span> <span class="nav-text">创造性的拼写错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象"><span class="nav-number">2.4.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#首字母大写的缩写"><span class="nav-number">2.5.</span> <span class="nav-text">首字母大写的缩写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#辞典大轮换"><span class="nav-number">2.6.</span> <span class="nav-text">辞典大轮换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#首字母大写"><span class="nav-number">2.7.</span> <span class="nav-text">首字母大写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重用命名"><span class="nav-number">2.8.</span> <span class="nav-text">重用命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用非英语字母"><span class="nav-number">2.9.</span> <span class="nav-text">使用非英语字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用编译器对于命名长度的限制"><span class="nav-number">2.10.</span> <span class="nav-text">利用编译器对于命名长度的限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下划线，真正的朋友"><span class="nav-number">2.11.</span> <span class="nav-text">下划线，真正的朋友</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合多语言"><span class="nav-number">2.12.</span> <span class="nav-text">混合多语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展-ASCII-字符"><span class="nav-number">2.13.</span> <span class="nav-text">扩展 ASCII 字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他语言的命名"><span class="nav-number">2.14.</span> <span class="nav-text">其他语言的命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学命名"><span class="nav-number">2.15.</span> <span class="nav-text">数学命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#令人眩晕的命名"><span class="nav-number">2.16.</span> <span class="nav-text">令人眩晕的命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何时使用-i"><span class="nav-number">2.17.</span> <span class="nav-text">何时使用 i</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惯例-—-明修栈道，暗度陈仓"><span class="nav-number">2.18.</span> <span class="nav-text">惯例 — 明修栈道，暗度陈仓</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小写的-l-看上去很像数字-1"><span class="nav-number">2.19.</span> <span class="nav-text">小写的 l 看上去很像数字 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把全局命名重用为私有"><span class="nav-number">2.20.</span> <span class="nav-text">把全局命名重用为私有</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#误导性的命名"><span class="nav-number">2.21.</span> <span class="nav-text">误导性的命名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#伪装"><span class="nav-number">3.</span> <span class="nav-text">伪装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用连接符隐藏变量"><span class="nav-number">3.1.</span> <span class="nav-text">用连接符隐藏变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文档"><span class="nav-number">4.</span> <span class="nav-text">文档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在注释中撒谎"><span class="nav-number">4.1.</span> <span class="nav-text">在注释中撒谎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只记录显而易见的东西"><span class="nav-number">4.2.</span> <span class="nav-text">只记录显而易见的东西</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#记录-How-而不是-Why"><span class="nav-number">4.3.</span> <span class="nav-text">记录 How 而不是 Why</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#该写的别写"><span class="nav-number">4.4.</span> <span class="nav-text">该写的别写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计量单位"><span class="nav-number">4.5.</span> <span class="nav-text">计量单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#坑"><span class="nav-number">4.6.</span> <span class="nav-text">坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说明变量"><span class="nav-number">4.7.</span> <span class="nav-text">说明变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在注释里挑拨离间"><span class="nav-number">4.8.</span> <span class="nav-text">在注释里挑拨离间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序设计"><span class="nav-number">5.</span> <span class="nav-text">程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-造型"><span class="nav-number">5.1.</span> <span class="nav-text">Java 造型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用Java的冗余"><span class="nav-number">5.2.</span> <span class="nav-text">利用Java的冗余</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#永远不做校验"><span class="nav-number">5.3.</span> <span class="nav-text">永远不做校验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有礼貌，无断言"><span class="nav-number">5.4.</span> <span class="nav-text">有礼貌，无断言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免封装"><span class="nav-number">5.5.</span> <span class="nav-text">避免封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制粘贴修改"><span class="nav-number">5.6.</span> <span class="nav-text">复制粘贴修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用静态数组"><span class="nav-number">5.7.</span> <span class="nav-text">使用静态数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#傻瓜接口"><span class="nav-number">5.8.</span> <span class="nav-text">傻瓜接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#巨型监听器"><span class="nav-number">5.9.</span> <span class="nav-text">巨型监听器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好事成堆"><span class="nav-number">5.10.</span> <span class="nav-text">好事成堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友好的朋友"><span class="nav-number">5.11.</span> <span class="nav-text">友好的朋友</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用三维数组"><span class="nav-number">5.12.</span> <span class="nav-text">使用三维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#混合与匹配"><span class="nav-number">5.13.</span> <span class="nav-text">混合与匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#没有秘密"><span class="nav-number">5.14.</span> <span class="nav-text">没有秘密!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全堆一块"><span class="nav-number">5.15.</span> <span class="nav-text">全堆一块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#就是-Final"><span class="nav-number">5.16.</span> <span class="nav-text">就是 Final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免布局"><span class="nav-number">5.17.</span> <span class="nav-text">避免布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量，怎么强调都不过分"><span class="nav-number">5.18.</span> <span class="nav-text">全局变量，怎么强调都不过分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再一次说说全局变量"><span class="nav-number">5.19.</span> <span class="nav-text">再一次说说全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部变量"><span class="nav-number">5.20.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件"><span class="nav-number">5.21.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子类"><span class="nav-number">5.22.</span> <span class="nav-text">子类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码迷局"><span class="nav-number">6.</span> <span class="nav-text">代码迷局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符重载"><span class="nav-number">6.1.</span> <span class="nav-text">操作符重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迷惑-C"><span class="nav-number">6.2.</span> <span class="nav-text">迷惑 C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#追求极致"><span class="nav-number">6.3.</span> <span class="nav-text">追求极致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一致性的小淘气"><span class="nav-number">6.4.</span> <span class="nav-text">一致性的小淘气</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#造型"><span class="nav-number">6.5.</span> <span class="nav-text">造型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套-switch"><span class="nav-number">6.6.</span> <span class="nav-text">嵌套 switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用隐式转化"><span class="nav-number">6.7.</span> <span class="nav-text">利用隐式转化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分号"><span class="nav-number">6.8.</span> <span class="nav-text">分号!</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用八进制数"><span class="nav-number">6.9.</span> <span class="nav-text">使用八进制数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套"><span class="nav-number">6.10.</span> <span class="nav-text">嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C数组"><span class="nav-number">6.11.</span> <span class="nav-text">C数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#放长线钓大鱼"><span class="nav-number">6.12.</span> <span class="nav-text">放长线钓大鱼</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">6.13.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用异常的时机"><span class="nav-number">6.14.</span> <span class="nav-text">使用异常的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#狂热奔放地使用线程"><span class="nav-number">6.15.</span> <span class="nav-text">狂热奔放地使用线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试"><span class="nav-number">7.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#永不测试"><span class="nav-number">7.1.</span> <span class="nav-text">永不测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#永远不要做性能测试"><span class="nav-number">7.2.</span> <span class="nav-text">永远不要做性能测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#永远不要写任何测试用例"><span class="nav-number">7.3.</span> <span class="nav-text">永远不要写任何测试用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试是给懦夫用的"><span class="nav-number">7.4.</span> <span class="nav-text">测试是给懦夫用的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#选择你的编程语言"><span class="nav-number">8.</span> <span class="nav-text">选择你的编程语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FORTRAN"><span class="nav-number">8.1.</span> <span class="nav-text">FORTRAN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-ASM"><span class="nav-number">8.2.</span> <span class="nav-text">用 ASM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-QBASIC"><span class="nav-number">8.3.</span> <span class="nav-text">用 QBASIC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联汇编"><span class="nav-number">8.4.</span> <span class="nav-text">内联汇编</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏汇编调用C"><span class="nav-number">8.5.</span> <span class="nav-text">宏汇编调用C</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不要重编译"><span class="nav-number">9.1.</span> <span class="nav-text">不要重编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#挫败调试工具"><span class="nav-number">9.2.</span> <span class="nav-text">挫败调试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公制和美制"><span class="nav-number">9.3.</span> <span class="nav-text">公制和美制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持续改进"><span class="nav-number">9.4.</span> <span class="nav-text">持续改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quot-关于-quot"><span class="nav-number">9.5.</span> <span class="nav-text">&quot;关于&quot;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变更"><span class="nav-number">9.6.</span> <span class="nav-text">变更</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无需技能"><span class="nav-number">9.7.</span> <span class="nav-text">无需技能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只带一把锤子"><span class="nav-number">9.8.</span> <span class="nav-text">只带一把锤子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规范体系"><span class="nav-number">9.9.</span> <span class="nav-text">规范体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻转通常的-True-False-惯例"><span class="nav-number">9.10.</span> <span class="nav-text">翻转通常的 True False 惯例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三方库"><span class="nav-number">9.11.</span> <span class="nav-text">第三方库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要用库"><span class="nav-number">9.12.</span> <span class="nav-text">不要用库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一套Build顺序"><span class="nav-number">9.13.</span> <span class="nav-text">创建一套Build顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Make-的更多玩法"><span class="nav-number">9.14.</span> <span class="nav-text">Make 的更多玩法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜集编码规范"><span class="nav-number">9.15.</span> <span class="nav-text">搜集编码规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#规避公司的编码规则"><span class="nav-number">9.16.</span> <span class="nav-text">规避公司的编码规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器警告"><span class="nav-number">9.17.</span> <span class="nav-text">编译器警告</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把-bug-修复和升级混在一起"><span class="nav-number">9.18.</span> <span class="nav-text">把 bug 修复和升级混在一起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在你的产品发布每个新版本的时候都改变文件结构"><span class="nav-number">9.19.</span> <span class="nav-text">在你的产品发布每个新版本的时候都改变文件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抵消-Bug"><span class="nav-number">9.20.</span> <span class="nav-text">抵消 Bug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用旋转锁"><span class="nav-number">9.21.</span> <span class="nav-text">使用旋转锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随意安插-sync-代码"><span class="nav-number">9.22.</span> <span class="nav-text">随意安插 sync 代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优雅降级"><span class="nav-number">9.23.</span> <span class="nav-text">优雅降级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定制脚本语言"><span class="nav-number">9.24.</span> <span class="nav-text">定制脚本语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖于编译器的代码"><span class="nav-number">9.25.</span> <span class="nav-text">依赖于编译器的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个货真价实的例子"><span class="nav-number">9.26.</span> <span class="nav-text">一个货真价实的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何修复-“unused-variable”-错误"><span class="nav-number">9.27.</span> <span class="nav-text">如何修复 “unused variable” 错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大小很关键"><span class="nav-number">9.28.</span> <span class="nav-text">大小很关键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一张图片顶1000句话，一个函数就是1000行"><span class="nav-number">9.29.</span> <span class="nav-text">一张图片顶1000句话，一个函数就是1000行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#少个文件"><span class="nav-number">9.30.</span> <span class="nav-text">少个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#到处都写，无处会读"><span class="nav-number">9.31.</span> <span class="nav-text">到处都写，无处会读</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Shq</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span>Shq已经写了 <span title="Site words total count">164.5k</span> 字辣qwq</div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv"> 本站访客数:<span id="busuanzi_value_site_pv">|</span></span></div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src=""></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: '',
        appKey: '',
        placeholder: 'Just go go',
        avatar:'mp',
        meta:guest,
        pageSize:'10' || 10,
        visitor: 
    });</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/love.js"></script><script type="test/javascript" src="/js/src/clock.js"></script><script type="text/javascript" src="/lib/zclip/clipboard.min.js"></script><script type="text/javascript" src="/js/src/custom.js"></script><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>