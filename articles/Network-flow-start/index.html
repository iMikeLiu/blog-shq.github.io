<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><script src="\js\src\custom\instantclick.min.js" data-no-instant></script><script data-no-instant>InstantClick.on("change",function(t){!1===t&&("undefined"!=typeof MathJax&&MathJax.Hub.Queue(["Typeset",MathJax.Hub]),"undefined"!=typeof prettyPrint&&prettyPrint(),"undefined"!=typeof _hmt&&_hmt.push(["_trackPageview",location.pathname+location.search]),"undefined"!=typeof ga&&ga("send","pageview",location.pathname+location.search))}),InstantClick.init()</script><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><script></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.png?v=5.1.3" color="#222"><meta name="keywords" content="网络流,教程,最大流,最小割,最小割最大流定理,玄学,Dinic,SAP,ISAP,HLPP,预留推进,EK算法,FF方法,"><link rel="alternate" href="/atom.xml" title="Shq's Blog" type="application/atom+xml"><meta name="description" content="网络流是个十分常用的方法，拥有很多用途之前的讲解太草率了qwq，这一篇我们来好好介绍一下网络流网络流 - 网络网络是一张有向图，有且仅有 一个汇点和一个源点"><meta name="keywords" content="网络流,教程,最大流,最小割,最小割最大流定理,玄学,Dinic,SAP,ISAP,HLPP,预留推进,EK算法,FF方法"><meta property="og:type" content="article"><meta property="og:title" content="网络流从入门到入土 - By Shq"><meta property="og:url" content="https://blog.ishq.site/articles/Network-flow-start/index.html"><meta property="og:site_name" content="Shq&#39;s Blog"><meta property="og:description" content="网络流是个十分常用的方法，拥有很多用途之前的讲解太草率了qwq，这一篇我们来好好介绍一下网络流网络流 - 网络网络是一张有向图，有且仅有 一个汇点和一个源点"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d68b16a1d9.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d718551a51.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d735eeef7e.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d790b5e298.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d7b691e958.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d883a08238.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d883a08238.png"><meta property="og:image" content="https://i.loli.net/2018/07/29/5b5d883a09e4e.png"><meta property="og:updated_time" content="2018-08-08T01:25:02.838Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="网络流从入门到入土 - By Shq"><meta name="twitter:description" content="网络流是个十分常用的方法，拥有很多用途之前的讲解太草率了qwq，这一篇我们来好好介绍一下网络流网络流 - 网络网络是一张有向图，有且仅有 一个汇点和一个源点"><meta name="twitter:image" content="https://i.loli.net/2018/07/29/5b5d68b16a1d9.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.3",sidebar:{position:"left",display:"post",offset:10,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:"",labels:""}}</script><link rel="canonical" href="https://blog.ishq.site/articles/Network-flow-start/"><title>网络流从入门到入土 - By Shq | Shq's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div id="vcomment" class="comment"></div><script src="//cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/npm/leancloud-storage@latest/dist/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><a href="https://github.com/Blog-Shq/blog-shq.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70b7fd;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Shq's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Real Artists simplify</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-bandcamp"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-id-card"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签<span class="badge">208</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>系列<span class="badge">4</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-paste"></i><br>归档<span class="badge">96</span></a></li><li class="menu-item menu-item-frlink"><a href="/frlink/" rel="section"><i class="menu-item-icon fa fa-fw fa-link"></i><br>友链</a></li><li class="menu-item menu-item-comments"><a href="/comments/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i><br>留言板</a></li><li class="menu-item menu-item-remittance"><a href="/remittance/" rel="section"><i class="menu-item-icon fa fa-fw fa-bitcoin"></i><br>给本站投食</a></li><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://blog.ishq.site/articles/Network-flow-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Shq"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Shq's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">网络流从入门到入土 - By Shq</h1><div class="post-meta"><i class="fa fa-thumb-tack"></i> <font color="0000CD">置顶</font> <span class="post-meta-divider">|</span> <span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T14:36:47+08:00">2018-07-30 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">属于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/OI/" itemprop="url" rel="index"><span itemprop="name">OI</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/articles/Network-flow-start/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/articles/Network-flow-start/" itemprop="commentCount"></span></a></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,457 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">21</span></div></div></header><div class="post-body" itemprop="articleBody"><p>网络流是个十分常用的方法，拥有很多用途</p><p>之前的讲解太草率了qwq，这一篇我们来好好介绍一下网络流</p><h2 id="网络流-网络"><a href="#网络流-网络" class="headerlink" title="网络流 - 网络"></a>网络流 - 网络</h2><p>网络是一张有向图，<strong>有且仅有</strong> 一个汇点和一个源点</p><a id="more"></a><p>我们来举一个 <em>简单易懂</em> 的栗子:</p><blockquote><p>你是一个工厂老板</p><p>你有一座超大的工厂，大到它可以制造任意多的货物。但是众所周知，工厂是不会建在市区的。</p><p>从工厂到销售处之间有若干车站，车站间有若干车次。每个车次有一个起点、一个终点（单向的），还有一个容量，指你最多可以利用个车次载多少货物。最大化你从工厂运到销售处的货物量</p></blockquote><p>这是一个很显然的栗子</p><p>栗子中你的工厂就是源点，销售处(我们规定只有一个销售处)就是汇点</p><p>画一个简单的图：</p><p><img src="https://i.loli.net/2018/07/29/5b5d68b16a1d9.png" alt="网络流"></p><center>By Shq + GeoGebra</center><p>图中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span></span></span></span> 代表源点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 代表汇点</p><p>每条边表明了流量</p><p>我们将⼀个合法解称作⼀个流，⼀条边被经过的次数称作其流量；</p><p>最终运输的货物总数称作整个流的流量</p><hr><p><strong>容量限制</strong>：每条边被经过的次数不得超过它的容量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.36687em"></span><span class="strut bottom" style="height:.36687em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> 每条边的流量不超过其流量</p><p><strong>流量平衡</strong>：流由若⼲从源点到汇点的路径组成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.36687em"></span><span class="strut bottom" style="height:.36687em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> 除源点和汇点外，对于每个点，流⼊它的流量和等于从它流出的流量和</p><p>最⼤化货物量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.36687em"></span><span class="strut bottom" style="height:.36687em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> 最⼤化整个流的流量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.36687em"></span><span class="strut bottom" style="height:.36687em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> 最⼤化从源点流出的流量</p><h2 id="网络的一些性质"><a href="#网络的一些性质" class="headerlink" title="网络的一些性质"></a>网络的一些性质</h2><p>网络流的性质有很多，这里先介绍一些常用的性质</p><ul><li>容量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{capacity}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">c</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">c</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm" style="margin-right:.01389em">y</span></span><span class="mopen">(</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span> 表示一条有向边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">e(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 的最大允许的流量</li><li>流量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi></mrow><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{flow}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span></span><span class="mopen">(</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span> 表示一条有向边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">e(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 总容量中已被占用的流量</li><li>剩余容量：即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">y</mi></mrow><mo>(</mo><mi>e</mi><mo>)</mo><mo>−</mo><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi></mrow><mo>(</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{capacity}(e) - \mathrm{flow}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">c</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">c</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm" style="margin-right:.01389em">y</span></span><span class="mopen">(</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span></span><span class="mopen">(</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span>，表示当前时刻某条有向边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">e</mi></mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{e}(u, v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 总流量中未被占用的部分</li><li>反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">∞</span></span></span></span>，容量的变化与原边相反；『<em>反向边</em>』的概念是相对的，即一条边的反向边的反向边是它本身</li><li>残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改</li><li>增广路（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{augmenting\ path}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span></span></span></span></span>）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为<strong>增广流量</strong></li><li>增广（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{augmenting}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.66786em"></span><span class="strut bottom" style="height:.8623000000000001em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span></span></span></span></span>）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上<strong>增广流量</strong>的过程</li><li>层次：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mrow><mo>(</mo><mi>u</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathrm{level}(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mclose">)</span></span></span></span> 表示节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 在层次图中与源点的距离</li><li>层次图：在原残量网络中按照每个节点的层次来分层，只保留<strong>相邻两层</strong>的节点的图，<strong>满载（即流量等于容量）的边不存在于层次图中</strong></li></ul><p>这里当然有一些 <code>dinic</code> 的内容，这里看看就好啦</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>现在我们想一种状况</p><p>你工厂生产的产品十分畅销，销售部经常卖光，你每次都要制造产品，再运过去很麻烦。于是，你制造了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.8141079999999999em"></span><span class="strut bottom" style="height:.897438em;vertical-align:-.08333em"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="vlist"><span style="top:-.363em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">9</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">7</span></span></span></span> 顿货物，但是由于每条边都有一个流量限制，到达销售部的货物肯定不会是你发出货物的数量</p><p>你开始思考，我们最多生产多少顿货物，可以让销售部收到同样多的货物</p><p>这个货物的数量就是这个网络的最大流</p><hr><p>我们先看一种 <em>看似正确的</em> 解法</p><blockquote><p>Shq 蒟蒻解法:</p><p>找⼀条任意的路径并流过去，直到找不到一条合法的路径qwq</p></blockquote><p>我们来考虑一下反例：</p><p><img src="https://i.loli.net/2018/07/29/5b5d718551a51.png" alt="反例"></p><p>我们要求这个网络的最大流</p><p>肉眼都能看出这个网络的最大流是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span></p><p>我们沿用刚刚的思路，假如我们看到了这样一条路径:</p><p><img src="https://i.loli.net/2018/07/29/5b5d735eeef7e.png" alt="反例2"></p><p>这个算法会有一个错误的答案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span></p><hr><p>我们想想如何改进这个算法，首先我们看一看我们失败的原因</p><p>我们失败的原因是我们选择了一条错误的路径</p><p>那个.....有什么办法可以 <em>反悔</em> 呢？</p><p>如何做到 <em>可以反悔</em> 呢</p><p>每次我们找到了道路后，我们可以建一条 <strong>反向边</strong> ,容量为这条边的容量</p><p><strong>减少⼀条边上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03148em">k</span></span></span></span> 的流量，相当于反向流过来 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03148em">k</span></span></span></span> 的流量</strong></p><p>这个还是⽐较显然的。假设你把⼀些货物从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 地运到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.625em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">y</span></span></span></span> 地，后来你发现 运错了，那就再运回来就⾏了qwq</p><blockquote><p>定义: ⼀条边的残量，是指它还能流多少流量（即容量减去当前流量）</p></blockquote><p><img src="https://i.loli.net/2018/07/29/5b5d790b5e298.png" alt="反向边"></p><p>这样，我们就又能发现一条道路！</p><p><img src="https://i.loli.net/2018/07/29/5b5d7b691e958.png" alt="新的道路"></p><p>现在这个网络的最大流就显然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 了</p><p>这条路径就叫做增广路 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{augmenting\ path}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span></span></span></span></span>)，当然，增广路不止这一条qwq</p><h2 id="最大流-EK-text-EK-EK-算法"><a href="#最大流-EK-text-EK-EK-算法" class="headerlink" title="最大流 - EK\text{EK}EK 算法"></a>最大流 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">E</mi><mi mathvariant="normal">K</mi></mtext></mrow><annotation encoding="application/x-tex">\text{EK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">K</span></span></span></span></span> 算法</h2><p>我们来给这个简单显然的方法整理一下:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">-</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">-</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mtext><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text {Ford-Fulkerson-Method}(G,S,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm">d</span><span class="mord mathrm">-</span><span class="mord mathrm">F</span><span class="mord mathrm">u</span><span class="mord mathrm">l</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">s</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm">-</span><span class="mord mathrm">M</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord mathit">G</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.13889em">T</span><span class="mclose">)</span></span></span></span></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi></mtext><mi>f</mi><mtext><mtext> </mtext><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mtext> </mtext></mtext><mn>0</mn></mrow><annotation encoding="application/x-tex">\text{initialize flow}f \text{ to } 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">z</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span></span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">o</span><span class="mord mspace"> </span></span><span class="mord mathrm">0</span></span></span></span></li><li><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.297ex" height="2.176ex" style="vertical-align:-.338ex" viewbox="0 -791.3 2280.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMAIN-77" d="M90 368Q84 378 76 380T40 385H18V431H24L43 430Q62 430 84 429T116 428Q206 428 221 431H229V385H215Q177 383 177 368Q177 367 221 239L265 113L339 328L333 345Q323 374 316 379Q308 384 278 385H258V431H264Q270 428 348 428Q439 428 454 431H461V385H452Q404 385 404 369Q404 366 418 324T449 234T481 143L496 100L537 219Q579 341 579 347Q579 363 564 373T530 385H522V431H529Q541 428 624 428Q692 428 698 431H703V385H697Q696 385 691 385T682 384Q635 377 619 334L559 161Q546 124 528 71Q508 12 503 1T487 -11H479Q460 -11 456 -4Q455 -3 407 133L361 267Q359 263 266 -4Q261 -11 243 -11H238Q225 -11 220 -3L90 368Z"/><path stroke-width="1" id="E1-MJMAIN-68" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 124T102 167T103 217T103 272T103 329Q103 366 103 407T103 482T102 542T102 586T102 603Q99 622 88 628T43 637H25V660Q25 683 27 683L37 684Q47 685 66 686T103 688Q120 689 140 690T170 693T181 694H184V367Q244 442 328 442Q451 442 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path stroke-width="1" id="E1-MJMAIN-69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"/><path stroke-width="1" id="E1-MJMAIN-6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"/><path stroke-width="1" id="E1-MJMAIN-65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMAIN-77"/><use xlink:href="#E1-MJMAIN-68" x="722" y="0"/><use xlink:href="#E1-MJMAIN-69" x="1279" y="0"/><use xlink:href="#E1-MJMAIN-6C" x="1557" y="0"/><use xlink:href="#E1-MJMAIN-65" x="1836" y="0"/></g></svg> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">h</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mtext> </mtext></mtext></mrow><annotation encoding="application/x-tex">\text{have an augmenting path }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">h</span><span class="mord mathrm">a</span><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mspace"> </span></span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.625em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi></mtext></mrow><annotation encoding="application/x-tex">\text{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.66786em"></span><span class="strut bottom" style="height:.66786em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">G_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.969438em;vertical-align:-.286108em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:.10764em">f</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mtext> </mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi><mtext> </mtext></mtext><mi>f</mi><mtext><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext></mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">\ \ \ \ \text{augment flow }f \text{ along } p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="text mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span><span class="mord mspace"> </span></span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span></span><span class="mord mathit">p</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">n</mi><mtext> </mtext></mtext><mi>f</mi></mrow><annotation encoding="application/x-tex">\text{return }f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span><span class="mord mathrm">u</span><span class="mord mathrm">r</span><span class="mord mathrm">n</span><span class="mord mspace"> </span></span><span class="mord mathit" style="margin-right:.10764em">f</span></span></span></span></li></ol><p>这明显就是贪心啊qwq</p><hr><p>我们来尝试证明一下：</p><blockquote><p>首先，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">-</mi><mi mathvariant="normal">F</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi></mtext></mrow><annotation encoding="application/x-tex">\text {Ford-Fulkerson}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm">d</span><span class="mord mathrm">-</span><span class="mord mathrm">F</span><span class="mord mathrm">u</span><span class="mord mathrm">l</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">s</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span></span></span></span></span> 算法求出的流为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.10764em">f</span></span></span></span> ,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.10764em">f</span></span></span></span> 对应的残余网络中从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span></span></span></span> 可达的顶点集合为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span> ，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.10764em">f</span></span></span></span> 对应的残余网络中不存在从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S\to T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span>的路径了</p><p>那么显然，在残余网络中，任意一条从 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.249ex" height="3.343ex" style="vertical-align:-1.171ex" viewbox="0 -934.9 3121 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMAIN-2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"/><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMATHI-73" x="0" y="0"/><use xlink:href="#E1-MJMAIN-2192" x="747" y="0"/><use xlink:href="#E1-MJMATHI-76" x="2025" y="0"/><g transform="translate(2511,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">§</text></g></g></svg> 中的边流量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mrel">=</span><span class="mord mathit">c</span></span></span></span> ,任意一条从反向弧 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span> ，这个一定是满足，如果不满足，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span> 集合还可以扩充顶点，与前提矛盾。因此，<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.249ex" height="3.343ex" style="vertical-align:-1.171ex" viewbox="0 -934.9 3121 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMAIN-2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"/><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMATHI-73" x="0" y="0"/><use xlink:href="#E1-MJMAIN-2192" x="747" y="0"/><use xlink:href="#E1-MJMATHI-76" x="2025" y="0"/><g transform="translate(2511,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">§</text></g></g></svg> 的割的容量等于流的大小。则可以证明裸的増广路 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">d</mi></mtext></mrow><annotation encoding="application/x-tex">\text{ford}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">o</span><span class="mord mathrm">r</span><span class="mord mathrm">d</span></span></span></span></span> 算法是正确的</p></blockquote><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>我们刚刚在证明的时候出现了一个十分神奇的 <code>割</code> 字，那么他到底是啥呢？</p><p>所谓图的割，指的是某个顶点集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span> 属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">v</span></span></span></span> ，从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span> 出发的所有边的集合成为割 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.478ex" height="3.343ex" style="vertical-align:-1.171ex" viewbox="0 -934.9 2789.1 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMAIN-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path stroke-width="1" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMAIN-28" x="0" y="0"/><use xlink:href="#E1-MJMATHI-73" x="389" y="0"/><use xlink:href="#E1-MJMAIN-2C" x="859" y="0"/><use xlink:href="#E1-MJMATHI-76" x="1304" y="0"/><g transform="translate(1789,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">§</text></g><use xlink:href="#E1-MJMAIN-29" x="2399" y="0"/></g></svg> ,这些边的容量和被称为割的容量，如果有源点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span></span></span></span> 属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span></span></span></span> ，汇点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 属于 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.544ex" height="3.343ex" style="vertical-align:-1.171ex" viewbox="0 -934.9 1095.5 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="#E1-MJMATHI-76" x="0" y="0"/><g transform="translate(485,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">§</text></g></g></svg> ，则称之为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S-T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.76666em;vertical-align:-.08333em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 割，如果将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S-T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.76666em;vertical-align:-.08333em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 割的所有边都在原图中去掉，则不再有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S\to T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mrel">→</span><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span>的路径</p><p>我们还是举个栗子：</p><p>又双叒叕是这个图：</p><p><img src="https://i.loli.net/2018/07/29/5b5d883a08238.png" alt="img"></p><p>你和某家工厂的老板有仇</p><p>你想破坏他的工厂销售，但是明显的，你破坏工厂和销售部明显是不明智的，你可以破坏他工厂的运输即可qwq</p><p>你需要找到一些 <strong>道路</strong>，使从工厂到销售部没有道路链接，但是你并非想花费很大力气，你想找到一些花费力气最小的道路，选出⼀些边的集合，使得删除它们之后从源点⽆法到达汇点，那么这个集合就叫做⼀个<strong>割</strong></p><p>这些边的容量之和称作这个割的<strong>容量</strong></p><hr><p>我们任取一个割，我们发现它始终好像比最大流大的流量？</p><p>从源点到汇点的每条路径都会经过割上的⾄少⼀条边。割掉这些边之后，把源点能到达的点放到左边，不能到达的放到右边。显然源点到汇点的流量<strong>不会超过</strong>从左边⾛向右边的次数，⽽这⼜<strong>不会超过</strong>从左边到右边的边的容量之和。</p><p>直观⼀点，假设你是在⻋装着货物的时候炸掉了它。</p><p>每个货物你⾄少付出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 的代价炸掉（流量⼩于容量的时候你要付出⽐货物 数更多的代价），所以你炸的代价 <strong>不会⼩于</strong> 货物数</p><p>对于一个网络</p><p><img src="https://i.loli.net/2018/07/29/5b5d883a08238.png" alt="网络"></p><p>我们可以直观的看出来从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.36687em"></span><span class="strut bottom" style="height:.36687em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mrel">→</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 的最大流是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span></p><p>它的最小割为</p><p><img src="https://i.loli.net/2018/07/29/5b5d883a09e4e.png" alt="网络的最小割"></p><p>经过我们的实验发现，最小割的容量等于最大流的流量</p><p>这个和最小割最大流有关，我们就干脆命名为 <strong>最小割最大流定理</strong></p><p>这意味着⼀个惊⼈的事实：你能够仅付出和货物数相同的代价，就把你的仇⼈的财路炸断！</p><p>这自然是看起来很玄学的，我们想想为什么这个是成立的</p><h2 id="最小割最大流定理"><a href="#最小割最大流定理" class="headerlink" title="最小割最大流定理"></a>最小割最大流定理</h2><blockquote><p>求证：<em>最小割的容量等于最大流的流量，并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mtext></mrow><annotation encoding="application/x-tex">\text{FF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">F</span></span></span></span></span> 能够正确地求出来它</em></p></blockquote><hr><p>考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mtext></mrow><annotation encoding="application/x-tex">\text{FF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">F</span></span></span></span></span> 算法结束时，残量⽹络上没有了增⼴路。那么我们假设这时候，从源点经过残量⽹络能到达的点组成的集合为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> ，不能到达的点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 。显然汇点在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> ⾥，并且残量⽹络上没有从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的边。</p><p>可以发现以下事实成⽴：</p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 的边流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span> 。如果流量不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span> 那么应该存在⼀条从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的反向边，于是⽭盾。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的边流量等于其容量。只有这样它才不会在残量⽹络中出现。</li></ol><p>根据第⼀个条件，我们可以得知：没有流量从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 之后⼜回到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 。所以当前流量应该等于从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的边的流量之和，⽽根据第⼆个条件它⼜等于从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的边容量之和.⽽所有从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.07847em">X</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.22222em">Y</span></span></span></span> 的边⼜构成⼀个割，其容量等于这些边的容量之和</p><p>这意味着我们找到⼀个流和⼀个割，使得前者的流量等于后者的容量。⽽根据前⾯的结论，最⼤流的流量不会超过这个割的容量，所以这个流⼀定是最⼤流！</p><p>同样的，最⼩割的容量也不会⼩于这个流的流量，所以这个割也⼀定是最⼩割。</p><p>⽽这就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mtext></mrow><annotation encoding="application/x-tex">\text{FF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">F</span></span></span></span></span> ⽅法最后的局⾯（由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">F</mi><mi mathvariant="normal">F</mi></mtext></mrow><annotation encoding="application/x-tex">\text{FF}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">F</span></span></span></span></span> 会终⽌，所以它必定求出这样⼀个局⾯），由此我们得出结论：</p><p>FF是正确的，并且最大流等于最小割。 <del>（⽽最⼩割最⼤流定理还可以通过线性规划对偶定理证明）</del>不⽤管这个⻤玩意。</p><p>证毕撒花.</p><h2 id="其他最大流算法"><a href="#其他最大流算法" class="headerlink" title="其他最大流算法"></a>其他最大流算法</h2><p>窝就扔一个最大流板子的链接：<a href="http://poj.org/problem?id=1273" target="_blank" rel="noopener">[POJ]最大流板子</a></p><hr><p>我们发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">E</mi><mi mathvariant="normal">K</mi></mtext></mrow><annotation encoding="application/x-tex">\text{EK}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">K</span></span></span></span></span> 算法的复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.8141079999999999em"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mord"><span class="mord mathit">m</span><span class="vlist"><span style="top:-.363em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span> 太⾼（虽然⽹络流⼏乎没有跑到上界的情况，但复杂度还是在⼀定程度上代表了算法效率）</p><p>有⼀个显然的优化：</p><p>如果增⼴⼀次之后发现最短路没有变化，那么可以继续增⼴；直到从源点到汇点的增⼴路增⼤，才需要再跑⼀遍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mord mathit">s</span></span></span></span> 。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mord mathit">s</span></span></span></span> 之后，我们取出那些可能在最短路上的边，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">[</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">]</mi><mtext> </mtext><mi mathvariant="normal">=</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">[</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">]</mi><mtext> </mtext><mi mathvariant="normal">+</mi><mtext> </mtext><mn>1</mn></mtext></mrow><annotation encoding="application/x-tex">\text{dis[to] = dis[from] + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">[</span><span class="mord mathrm">t</span><span class="mord mathrm">o</span><span class="mord mathrm">]</span><span class="mord mspace"> </span><span class="mord mathrm">=</span><span class="mord mspace"> </span><span class="mord mathrm">d</span><span class="mord mathrm">i</span><span class="mord mathrm">s</span><span class="mord mathrm">[</span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">r</span><span class="mord mathrm">o</span><span class="mord mathrm">m</span><span class="mord mathrm">]</span><span class="mord mspace"> </span><span class="mord mathrm">+</span><span class="mord mspace"> </span><span class="mord mathrm">1</span></span></span></span></span> 的那些边。显然这些边构成的图中没有环。我们只需要沿着这种边尽可能的增⼴即可。</p><p>我们利⽤ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mord mathit">s</span></span></span></span> 增广。</p><p>有⼀个函数 <code>int dfs(int x, int T, int maxflow)</code> 表示从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 出发寻找到汇点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 的增广路，寻找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi></mtext></mrow><annotation encoding="application/x-tex">\text{maxflow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span></span></span></span></span> 个流量为止，并相应的增广。其返回值为实际增广了多少（因为有可能找不到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi></mtext></mrow><annotation encoding="application/x-tex">\text{maxflow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">x</span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span></span></span></span></span> 条增广路）</p><hr><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mtext></mrow><annotation encoding="application/x-tex">\text{Dinic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">D</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span></span></span></span></span> 复杂度可以证明为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2 m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.8141079999999999em"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-.363em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span> 。在某些特殊情况下（每个点要么仅有⼀条⼊边且容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>，要么仅有⼀条出边且容量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> ）其复杂度甚至能做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.8002800000000001em"></span><span class="strut bottom" style="height:1.05028em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="sqrt mord"><span class="sqrt-sign" style="top:.03971999999999998em"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span><span class="mord mathit">n</span></span><span style="top:-.72028em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></p><h3 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mtext></mrow><annotation encoding="application/x-tex">\text{Dinic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">D</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span></span></span></span></span> 算法的过程:</p><ol><li>遍历残量网络，建立层次图；</li><li>在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；</li><li>重复第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 步，直至层次图中不存在增广路，回到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 步重新建立层次图；</li><li>直到层次图无法建立，则当前流量即为最大流量。</li></ol><p>每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mtext><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{Dinic}(G,S,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">D</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span></span><span class="mopen">(</span><span class="mord mathit">G</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.13889em">T</span><span class="mclose">)</span></span></span></span></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mtext> </mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">h</mi><mtext> </mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mtext> </mtext></mtext><mi>G</mi></mrow><annotation encoding="application/x-tex">\text{make Layered graph in }G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm">L</span><span class="mord mathrm">a</span><span class="mord mathrm" style="margin-right:.01389em">y</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">d</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mathrm">h</span><span class="mord mspace"> </span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mspace"> </span></span><span class="mord mathit">G</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi></mtext></mrow><annotation encoding="application/x-tex">\text{do}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">o</span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mtext> </mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi><mtext> </mtext></mtext><mi>f</mi><mtext><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext></mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">\ \ \ \ \text{augment flow }f \text{ along } p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="mord mspace"> </span><span class="text mord textstyle uncramped"><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span><span class="mord mspace"> </span></span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span></span><span class="mord mathit">p</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mtext> </mtext><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi><mtext> </mtext><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">y</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi><mtext> </mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mtext> </mtext></mtext><mi>G</mi></mrow><annotation encoding="application/x-tex">\text{until there do not any augmenting flow in } G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">u</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">l</span><span class="mord mspace"> </span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm">d</span><span class="mord mathrm">o</span><span class="mord mspace"> </span><span class="mord mathrm">n</span><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">y</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:.01389em">w</span><span class="mord mspace"> </span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mspace"> </span></span><span class="mord mathit">G</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mtext> </mtext><mn>1</mn><mtext> </mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mtext> </mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">h</mi><mtext> </mtext><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mtext> </mtext><mi mathvariant="normal">c</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mtext> </mtext><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">k</mi><mi mathvariant="normal">e</mi><mtext> </mtext><mi mathvariant="normal">L</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mtext> </mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">h</mi></mtext></mrow><annotation encoding="application/x-tex">\text{goto 1 remake Layered graph until cannot make Layered graph}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mathrm">o</span><span class="mord mspace"> </span><span class="mord mathrm">1</span><span class="mord mspace"> </span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm">L</span><span class="mord mathrm">a</span><span class="mord mathrm" style="margin-right:.01389em">y</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">d</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mathrm">h</span><span class="mord mspace"> </span><span class="mord mathrm">u</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">l</span><span class="mord mspace"> </span><span class="mord mathrm">c</span><span class="mord mathrm">a</span><span class="mord mathrm">n</span><span class="mord mathrm">n</span><span class="mord mathrm">o</span><span class="mord mathrm">t</span><span class="mord mspace"> </span><span class="mord mathrm">m</span><span class="mord mathrm">a</span><span class="mord mathrm">k</span><span class="mord mathrm">e</span><span class="mord mspace"> </span><span class="mord mathrm">L</span><span class="mord mathrm">a</span><span class="mord mathrm" style="margin-right:.01389em">y</span><span class="mord mathrm">e</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">d</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">r</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mathrm">h</span></span></span></span></span></li></ol><h3 id="dinic-text-dinic-dinic-伪代码"><a href="#dinic-text-dinic-dinic-伪代码" class="headerlink" title="dinic\text{dinic}dinic 伪代码"></a><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mtext></mrow><annotation encoding="application/x-tex">\text{dinic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">d</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span></span></span></span></span> 伪代码</h3><p>（假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.13889em">T</span></span></span></span> 是⼀个全局变量，表示汇点）邻接表存储，<code>head[x]</code> 表示从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span></span></span></span> 出发 的第⼀条边，<code>next[i]</code> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.65952em"></span><span class="strut bottom" style="height:.65952em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 的下⼀条边。最后⼀条边的 <code>next</code> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.72777em;vertical-align:-.08333em"></span><span class="base textstyle uncramped"><span class="mord">−</span><span class="mord mathrm">1</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> T, <span class="keyword">int</span> maxflow)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == T) <span class="keyword">return</span> maxflow;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x];i != <span class="number">-1</span> &amp;&amp; ans &lt; maxflow; i = next[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dis[to[i]] != dis[x] + <span class="number">1</span> || ret[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> f = dfs(to[i], T, min(maxflow - ans, ret[i]))</span><br><span class="line">		ret[i] -= f;</span><br><span class="line">		ret[rev[i]] += f;</span><br><span class="line">		ans += f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi></mtext></mrow><annotation encoding="application/x-tex">\text{Dinic}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">D</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">c</span></span></span></span></span> 的主过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bfs(S, T)) ans += dfs(S, T, <span class="number">0x7fffffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码⼗分简洁qwq</p><hr><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">Dinic</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">D</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit">c</span></span></span></span> 有一个常见的优化 — 当前弧优化</p><p>该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">DFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">D</span><span class="mord mathit" style="margin-right:.13889em">F</span><span class="mord mathit" style="margin-right:.05764em">S</span></span></span></span> 这个点的时候直接可以从这条边的下一条边开始</p><hr><h3 id="SAP-算法"><a href="#SAP-算法" class="headerlink" title="SAP 算法"></a>SAP 算法</h3><h4 id="距离标号："><a href="#距离标号：" class="headerlink" title="距离标号："></a>距离标号：</h4><p>所谓距离标号 ，就是某个点到汇点的最少的弧的数量（即边权值为1时某个点到汇点的最短路径长度）</p><p>设点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.65952em"></span><span class="strut bottom" style="height:.65952em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 的标号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">level_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.84444em;vertical-align:-.15em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mord mathit">e</span><span class="mord"><span class="mord mathit" style="margin-right:.01968em">l</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:-.01968em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span></span></span></span>，那么如果将满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><msub><mi>l</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">level_i=level_j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.980548em;vertical-align:-.286108em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mord mathit">e</span><span class="mord"><span class="mord mathit" style="margin-right:.01968em">l</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:-.01968em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:.01968em">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mord mathit">e</span><span class="mord"><span class="mord mathit" style="margin-right:.01968em">l</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:-.01968em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:.05724em">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span> 的弧 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 叫做允许弧 ，且增广时只走允许弧</p><h4 id="断层（本算法的-GapGapGap-优化思想）"><a href="#断层（本算法的-GapGapGap-优化思想）" class="headerlink" title="断层（本算法的 GapGapGap 优化思想）"></a>断层（本算法的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Gap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.8777699999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">G</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span> 优化思想）</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">gap_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.625em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">a</span><span class="mord"><span class="mord mathit">p</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span></span></span></span> 数组表示距离标号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.65952em"></span><span class="strut bottom" style="height:.65952em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 的点有多少个，如果到某一点没有符合距离标号的允许弧，我那么需要修改距离标号来找到增广路</p><p>如果重标号使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">gap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.625em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">g</span><span class="mord mathit">a</span><span class="mord mathit">p</span></span></span></span> 数组中原标号数目变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span> ，则算法结束</p><p>我们学过毒瘤的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">EK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">E</span><span class="mord mathit" style="margin-right:.07153em">K</span></span></span></span>算法，我们想想优化－如果能让每次寻找增广路时的时间复杂度降下来，那么就能提高算法效率了，使用 <strong>距离标号的最短增广路算法</strong> 就是这样的</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">S</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">P</mi></mtext><mo>(</mo><mi>G</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text{SAP}(G,S,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">A</span><span class="mord mathrm">P</span></span><span class="mopen">(</span><span class="mord mathit">G</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.13889em">T</span><span class="mclose">)</span></span></span></span></p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">z</mi><mi mathvariant="normal">e</mi></mtext><mtext><mtext> </mtext><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">,</mi><mtext> </mtext><mi mathvariant="normal">g</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mtext> </mtext></mtext></mrow><annotation encoding="application/x-tex">\text{initialize} \text{ level, gap }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">i</span><span class="mord mathrm">z</span><span class="mord mathrm">e</span></span><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span><span class="mord mathrm">,</span><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">a</span><span class="mord mathrm">p</span><span class="mord mspace"> </span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mtext> </mtext></mtext><mi>e</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><msub><mtext><mtext> </mtext><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mtext> </mtext><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mtext><mi>i</mi></msub><mo>=</mo><msub><mtext><mi mathvariant="normal">l</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">l</mi></mtext><mi>j</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\text{find }e(u,v)\text{ with level}_i=\text{level}_j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-.286108em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mspace"> </span></span><span class="mord mathit">e</span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mclose">)</span><span class="mord"><span class="text mord textstyle uncramped"><span class="mord mspace"> </span><span class="mord mathrm" style="margin-right:.01389em">w</span><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mspace"> </span><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span></span><span class="vlist"><span style="top:.15em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="text mord textstyle uncramped"><span class="mord mathrm">l</span><span class="mord mathrm">e</span><span class="mord mathrm" style="margin-right:.01389em">v</span><span class="mord mathrm">e</span><span class="mord mathrm">l</span></span><span class="vlist"><span style="top:.15em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:.05724em">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">f</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mtext> </mtext><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">g</mi><mtext> </mtext><mi mathvariant="normal">e</mi></mtext><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\text {find augmenting path along e}(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm" style="margin-right:.07778em">f</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">u</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mathrm">m</span><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">t</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm">p</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span><span class="mord mathrm">h</span><span class="mord mspace"> </span><span class="mord mathrm">a</span><span class="mord mathrm">l</span><span class="mord mathrm">o</span><span class="mord mathrm">n</span><span class="mord mathrm" style="margin-right:.01389em">g</span><span class="mord mspace"> </span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span></li></ol><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>A</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">SAP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.05764em">S</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:.13889em">P</span></span></span></span> Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*qwq窝才不会给你代码*/</span></span><br></pre></td></tr></table></figure><h3 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h3><p>原图存在两种子图，一个是残量网络，一个是允许弧组成的图</p><p>残量网络保证可增广，允许弧保证最短路（时间界较优）</p><p>所以，在寻找增广路的过程中，一直是在残量网络中沿着允许弧寻找。因此，<strong>允许弧应该是属于残量网络的，而非原图的</strong></p><p>换句话说，我们沿着允许弧，走的是残量网络（而非原图）中的最短路径</p><p>当我们找到沿着残量网络找到一条增广路，增广后，残量网络肯定会变化（至少少了一条边），因此决定允许弧的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 数组要进行相应的更新（顺便提一句，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">Dinic</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.68333em"></span><span class="strut bottom" style="height:.68333em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">D</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">i</span><span class="mord mathit">c</span></span></span></span> 的做法就是每次增广都重新计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 数组）</p><p>然而，ISAP 「改进」的地方之一就是，其实没有必要马上更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 数组。这是因为，去掉一条边只可能令路径变得更长，而如果增广之前的残量网络存在另一条最短路，并且在增广后的残量网络中仍存在，那么这条路径毫无疑问是最短的。所以，ISAP 的做法是继续增广，直到遇到死路，才执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mtext></mrow><annotation encoding="application/x-tex">\text{retreat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span></span></span></span></span> 操作</p><p>说到这里，大家应该都猜到了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mtext></mrow><annotation encoding="application/x-tex">\text{retreat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span></span></span></span></span> 操作的主要任务就是更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 数组。那么怎么更新呢？</p><p>非常简单：假设是从节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 找遍了邻接边也没找到允许弧的；再设一变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span>，令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span></span></span></span> 等于残量网络中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 的所有邻接点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 数组的最小值，然后令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mopen">[</span><span class="mord mathit">u</span><span class="mclose">]</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.72777em;vertical-align:-.08333em"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span> 即可。这是因为，进入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mtext></mrow><annotation encoding="application/x-tex">\text{retreat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="text mord textstyle uncramped"><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span><span class="mord mathrm">r</span><span class="mord mathrm">e</span><span class="mord mathrm">a</span><span class="mord mathrm">t</span></span></span></span></span> 环节说明残量网络中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span> 已经不能通过（已过时）的允许弧相连</p><p>那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span> 实际上在残量网络中的最短路的长是多少呢？（这正是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 的定义！）</p><p>显然是残量网络中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 的所有邻接点和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span> 的距离加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.64444em"></span><span class="strut bottom" style="height:.64444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 的最小情况。特殊情况是，残量网络中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 根本没有邻接点。</p><p>如果是这样，只需要把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">d[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mopen">[</span><span class="mord mathit">u</span><span class="mclose">]</span></span></span></span> 设为一个比较大的数即可，这会导致任何点到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 的边被排除到残量网络以外</p><p>（严格来说只要大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:.22222em">V</span><span class="mord mathrm">∣</span></span></span></span> 即可。由于最短路一定是无环的，因此任意路径长最大是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|V|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:.22222em">V</span><span class="mord mathrm">∣</span></span></span></span> ）修改之后，只需要把正在研究的节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 沿着刚才走的路退一步，然后继续搜索即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> source;         <span class="comment">// 源点</span></span><br><span class="line"><span class="keyword">int</span> sink;           <span class="comment">// 汇点</span></span><br><span class="line"><span class="keyword">int</span> p[max_nodes];   <span class="comment">// 可增广路上的上一条弧的编号</span></span><br><span class="line"><span class="keyword">int</span> num[max_nodes]; <span class="comment">// 和 t 的最短距离等于 i 的节点数量</span></span><br><span class="line"><span class="keyword">int</span> cur[max_nodes]; <span class="comment">// 当前弧下标</span></span><br><span class="line"><span class="keyword">int</span> d[max_nodes];   <span class="comment">// 残量网络中节点 i 到汇点 t 的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> visited[max_nodes];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理, 反向 BFS 构造 d 数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(sink);</span><br><span class="line">    visited[sink] = <span class="number">1</span>;</span><br><span class="line">    d[sink] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">iterator_t</span> ix = G[u].begin(); ix != G[u].end(); ++ix) &#123;</span><br><span class="line">            Edge &amp;e = edges[(*ix)^<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!visited[e.from] &amp;&amp; e.capacity &gt; e.flow) &#123;</span><br><span class="line">                visited[e.from] = <span class="literal">true</span>;</span><br><span class="line">                d[e.from] = d[u] + <span class="number">1</span>;</span><br><span class="line">                Q.push(e.from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visited[source];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增广</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = sink, df = __inf;</span><br><span class="line">    <span class="comment">// 从汇点到源点通过 p 追踪增广路径, df 为一路上最小的残量</span></span><br><span class="line">    <span class="keyword">while</span> (u != source) &#123;</span><br><span class="line">        Edge &amp;e = edges[p[u]];</span><br><span class="line">        df = min(df, e.capacity - e.flow);</span><br><span class="line">        u = edges[p[u]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    u = sink;</span><br><span class="line">    <span class="comment">// 从汇点到源点更新流量</span></span><br><span class="line">    <span class="keyword">while</span> (u != source) &#123;</span><br><span class="line">        edges[p[u]].flow += df;</span><br><span class="line">        edges[p[u]^<span class="number">1</span>].flow -= df;</span><br><span class="line">        u = edges[p[u]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> df;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_nodes; i++) num[d[i]]++;</span><br><span class="line">    <span class="keyword">int</span> u = source;</span><br><span class="line">    <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span>(cur));</span><br><span class="line">    <span class="keyword">while</span> (d[source] &lt; num_nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == sink) &#123;</span><br><span class="line">            flow += augment();</span><br><span class="line">            u = source;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> advanced = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u]; i &lt; G[u].size(); i++) &#123; </span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.capacity &gt; e.flow &amp;&amp; d[u] == d[e.to] + <span class="number">1</span>) &#123;</span><br><span class="line">                advanced = <span class="literal">true</span>;</span><br><span class="line">                p[e.to] = G[u][i];</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                u = e.to;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!advanced) &#123; <span class="comment">// retreat</span></span><br><span class="line">            <span class="keyword">int</span> m = num_nodes - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">iterator_t</span> ix = G[u].begin(); ix != G[u].end(); ++ix)</span><br><span class="line">                <span class="keyword">if</span> (edges[*ix].capacity &gt; edges[*ix].flow)</span><br><span class="line">                    m = min(m, d[edges[*ix].to]);</span><br><span class="line">            <span class="keyword">if</span> (--num[d[u]] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// gap 优化</span></span><br><span class="line">            num[d[u] = m+<span class="number">1</span>]++;</span><br><span class="line">            cur[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (u != source)</span><br><span class="line">                u = edges[p[u]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最高标号预流推进-HLPP-算法"><a href="#最高标号预流推进-HLPP-算法" class="headerlink" title="最高标号预流推进(HLPP) 算法"></a>最高标号预流推进(HLPP) 算法</h3><hr><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ul><li>预流推进算法将每个点看做一个可以存储流的“水池”，其中存有流的点称为活动节点</li><li>对于每个非s或t的点，流入该点的流只可能有两个去向：流入汇点t，流回源点s;</li><li>预流推进算法从源点开始沿边向其它点推流，之后每次选一个活动节点通过推流，试图使其变得不活动。当所有节点都是不活动节点时，算法就结束了;</li><li>以上是<strong>传统</strong>预流推进算法的主要思想。而<strong>最高标号预流推进算法</strong>就是先预处理了一个<strong>距离标号h</strong>，通过<code>堆</code>或<code>优先队列</code>，没次选出<strong>h最大</strong>的点进行推流，以减少重复操作，降低了复杂度。</li></ul><hr><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>通过 <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="base textstyle uncramped"><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:.10764em">f</span><span class="mord mathit">s</span></span></span></span></strong> 预处理出距离标号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.69444em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">h</span></span></span></span> ，即到达汇点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.61508em"></span><span class="strut bottom" style="height:.61508em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">t</span></span></span></span> 的<strong>最短距离</strong>;</li><li>将从源点s出发的边设为<strong>满流</strong>，到达的点 <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">v</span></span></span></span></strong> 标记为<strong>活动节点</strong>并加入到优先队列中;</li><li>从优先队列中不断取出点 <strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span></strong> 进行 <strong>推流</strong> 操作，要求到达点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.03588em">v</span></span></span></span> 的<strong>必须满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>u</mi></msub><mo>=</mo><msub><mi>h</mi><mi>v</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_u=h_v+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.84444em;vertical-align:-.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">u</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:.03588em">v</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></strong></li><li>若推流后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.43056em"></span><span class="strut bottom" style="height:.43056em;vertical-align:0"></span><span class="base textstyle uncramped"><span class="mord mathit">u</span></span></span></span> 中仍有余流，则进行<strong>重标号</strong>。将<strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">h_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.69444em"></span><span class="strut bottom" style="height:.84444em;vertical-align:-.15em"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">u</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span></span></span></span> 设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>{</mo><msub><mi>h</mi><mi>v</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">\min \{h_v\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.75em"></span><span class="strut bottom" style="height:1em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mop">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathit">h</span><span class="vlist"><span style="top:.15em;margin-right:.05em;margin-left:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:.03588em">v</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="mclose">}</span></span></span></span></strong>，<strong>再次</strong>加入优先队列并重复步骤 3.</li><li>当优先队列为<strong>空</strong>时，结束算法</li></ol><hr><p>算法复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><msqrt><mi>m</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2\sqrt m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:.8141079999999999em"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-.25em"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-.363em;margin-right:.05em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0">​</span></span>​</span></span></span><span class="sqrt mord"><span class="sqrt-sign" style="top:.03971999999999998em"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span><span class="mord mathit">m</span></span><span style="top:-.72028em"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>！！！</p><p>Code :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* www.google.com */</span></span><br></pre></td></tr></table></figure><hr><p>End.</p></div><div><div><blockquote class="blockquote-center">-------------本文结束<i class="fa fa-apple"></i>感谢您的阅读-------------</blockquote></div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="Shq 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="Shq 支付宝"><p>支付宝</p></div></div></div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Shq</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.ishq.site/articles/Network-flow-start/" title="网络流从入门到入土 - By Shq">https://blog.ishq.site/articles/Network-flow-start/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/网络流/" rel="tag"><i class="fa fa-tag"></i> 网络流</a> <a href="/tags/教程/" rel="tag"><i class="fa fa-tag"></i> 教程</a> <a href="/tags/最大流/" rel="tag"><i class="fa fa-tag"></i> 最大流</a> <a href="/tags/最小割/" rel="tag"><i class="fa fa-tag"></i> 最小割</a> <a href="/tags/最小割最大流定理/" rel="tag"><i class="fa fa-tag"></i> 最小割最大流定理</a> <a href="/tags/玄学/" rel="tag"><i class="fa fa-tag"></i> 玄学</a> <a href="/tags/Dinic/" rel="tag"><i class="fa fa-tag"></i> Dinic</a> <a href="/tags/SAP/" rel="tag"><i class="fa fa-tag"></i> SAP</a> <a href="/tags/ISAP/" rel="tag"><i class="fa fa-tag"></i> ISAP</a> <a href="/tags/HLPP/" rel="tag"><i class="fa fa-tag"></i> HLPP</a> <a href="/tags/预留推进/" rel="tag"><i class="fa fa-tag"></i> 预留推进</a> <a href="/tags/EK算法/" rel="tag"><i class="fa fa-tag"></i> EK算法</a> <a href="/tags/FF方法/" rel="tag"><i class="fa fa-tag"></i> FF方法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/articles/lyoi-Poetry/" rel="next" title="「诗歌」OI无悔 - by Shq"><i class="fa fa-chevron-left"></i> 「诗歌」OI无悔 - by Shq</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/articles/Computed-geometry/" rel="prev" title="「计算几何」计算几何从入门到入土">「计算几何」计算几何从入门到入土 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Shq"><p class="site-author-name" itemprop="name">Shq</p><p class="site-description motion-element" itemprop="description">我不知道能否会成功，但我仍想试一试，哪怕只有一线希望</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">96</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">208</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Blog-Shq" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://www.luogu.org/space/show?uid=52556" target="_blank" title="洛谷"><i class="fa fa-fw fa-code"></i>洛谷</a> </span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/shq666" target="_blank" title="知乎"><i class="fa fa-fw fa-comment-o"></i>知乎</a> </span><span class="links-of-author-item"><a href="https://ly.men.ci" target="_blank" title="LYOI"><i class="fa fa-fw fa-star"></i>LYOI</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络流-网络"><span class="nav-number">1.</span> <span class="nav-text">网络流 - 网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络的一些性质"><span class="nav-number">2.</span> <span class="nav-text">网络的一些性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大流"><span class="nav-number">3.</span> <span class="nav-text">最大流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最大流-EK-text-EK-EK-算法"><span class="nav-number">4.</span> <span class="nav-text">最大流 - EK\text{EK}EK 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小割"><span class="nav-number">5.</span> <span class="nav-text">最小割</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小割最大流定理"><span class="nav-number">6.</span> <span class="nav-text">最小割最大流定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他最大流算法"><span class="nav-number">7.</span> <span class="nav-text">其他最大流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dinic-算法"><span class="nav-number">7.1.</span> <span class="nav-text">Dinic 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dinic-text-dinic-dinic-伪代码"><span class="nav-number">7.2.</span> <span class="nav-text">dinic\text{dinic}dinic 伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SAP-算法"><span class="nav-number">7.3.</span> <span class="nav-text">SAP 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#距离标号："><span class="nav-number">7.3.1.</span> <span class="nav-text">距离标号：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#断层（本算法的-GapGapGap-优化思想）"><span class="nav-number">7.3.2.</span> <span class="nav-text">断层（本算法的 GapGapGap 优化思想）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISAP算法"><span class="nav-number">7.4.</span> <span class="nav-text">ISAP算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最高标号预流推进-HLPP-算法"><span class="nav-number">7.5.</span> <span class="nav-text">最高标号预流推进(HLPP) 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#算法思想"><span class="nav-number">7.5.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法步骤"><span class="nav-number">7.5.2.</span> <span class="nav-text">算法步骤</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Shq</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span>Shq已经写了 <span title="Site words total count">174.9k</span> 字辣qwq</div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv"> 本站访客数:<span id="busuanzi_value_site_pv">|</span></span></div><span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src=""></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: '',
        appKey: '',
        placeholder: 'Just go go',
        avatar:'mp',
        meta:guest,
        pageSize:'10' || 10,
        visitor: 
    });</script><script type="text/javascript">// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === '') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/javascript" src="/js/src/love.js"></script><script type="test/javascript" src="/js/src/clock.js"></script><script type="text/javascript" src="/lib/zclip/clipboard.min.js"></script><script type="text/javascript" src="/js/src/custom.js"></script><link href="//cdn.staticfile.org/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>